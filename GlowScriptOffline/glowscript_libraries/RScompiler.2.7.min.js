(function(){})();(function(){"use strict";var VPython_import=null;var VPython_names=[];var waitlist=[new RegExp("^rate\\s*\\("),new RegExp("sleep\\s*\\("),new RegExp("^get_library\\s*\\("),new RegExp("\\.waitfor\\s*\\("),new RegExp("\\.pause\\s*\\("),new RegExp("\\s*read_local_file\\s*\\(")];var GS_wait="_";function waits(line,lang){for(var i=0;i<waitlist.length;i++){var patt=waitlist[i];if(line.search(patt)>=0){var m=line.match(patt);var wname=m[0].slice(0,-1);var end=line.lastIndexOf(")");var ending=line.slice(end);var parencnt=1;var name="";while(end>=0){end--;if(end<0)break;switch(line[end]){case"'":case'"':return[line.slice(0,end+1)+","+GS_wait+ending,true,wname];case")":parencnt++;break;case"(":parencnt--;if(parencnt===0){if(name=="wait"||name=="_")return[line.slice(0,end+1)+GS_wait+ending,true,wname];if(name.length===0)return[line.slice(0,end+1)+GS_wait+ending,true,wname];return[line.slice(0,end+1)+name+","+GS_wait+ending,true,wname]}break;case",":if(parencnt===1){if(name=="wait")return[line.slice(0,end+1)+GS_wait+ending,true,wname];else return[line,false,""]}break;case" ":break;default:name=line[end]+name}}}}return[line,false,""]}var lineno_string="RS_ls = ";function preprocess(program,lang){var c,lineno,lines,line,m,start;var waitfcts={};var parens=0,brackets=0,braces=0;var prebraces;var infunction=false;var lastleftparens=null,lastleftbracket=null,lastleftbrace=null;var indent="";var getline=/(^\s*)(.*)/;var newprogram="",lastindent="";var firstquote=0;var continuedline=false;var indef=false;var classindent=-1;var delim='"';var defindents=[];var pickpatt=/(\.pick)\s*(.)/;var classpatt=new RegExp("^classs*[^:]:");var defpatt=new RegExp("def\\W*(\\w*)\\s*\\(");var fctpatt=new RegExp("(\\w*)\\W*(\\w*)\\s*\\(");var print_optionspatt=/^print_options/;var decoration;lines=program.split("\n");for(lineno=0;lineno<lines.length;lineno++){decoration="";m=lines[lineno].match(getline);indent=m[1];line=m[2];if(lang!="javascript"){if(line[0]=="#")continue;var c=line.replace(/\s+$/g,"")}m=line.match(print_optionspatt);if(m)line=line.replace(/delete/,"remove");if(lang!="javascript"&&line[0]=="@"){var nextline=lines[lineno+1];m=nextline.match(getline);if(m[2].slice(0,3)=="def"||m[2].slice(0,6)=="module"){decoration=line;indent=m[1];line=m[2];lineno++}else{continue}}if(line.length===0)continue;prebraces=braces;if(lang!="javascript"){if(classindent===indent.length)classindent=-1;if(defindents.length>0&&indent.length<=defindents[defindents.length-1][1]){ret=defindents.pop();infunction=false}}else{if(defindents.length>0&&braces===defindents[defindents.length-1][3]){ret=defindents.pop();infunction=false}}if(lang!="javascript"&&line.match(classpatt))classindent=indent.length;if(lang=="vpython"){if(VPython_import===null)VPython_names=[];var w=line.split(" ");if(w[1]=="__future__")continue;if(w[1]=="visual.factorial")continue;if(w[0]=="from"&&w[2]=="import"&&w.length>=4){if(w[1]=="visual.graph"){if(w[3]=="*")continue;return'ERROR: Currently only "from visual.graph import *" is supported, line '+(lineno+2)+": "+lines[lineno]}if(!(w[1]=="vpython"||w[1]=="visual"||w[1]=="vis")){throw new Error("Line "+(lineno+2)+": cannot import from "+w[1])}if(VPython_import===null){if(w[3]=="*")continue;VPython_import=w[1];for(var j=3;j<w.length;j++){if(w[j].length>0&&w[j]!=","){if(w[j].slice(-1)==",")w[j]=w[j].slice(0,-1);if(w[j]==" "||w[j]=="("||w[j]==")"||w[j][0]=="("||w[j][-1]==")")continue;VPython_names.push(w[j])}}}continue}else if(w[0]=="import"&&w.length==2){if(w[1]=="visual.graph")return'ERROR: Currently only "from visual.graph import *" is supported, line '+(lineno+2)+": "+lines[lineno];if(!(w[1]=="vpython"||w[1]=="visual"||w[1]=="vis"))return"ERROR: Cannot import from "+w[1]+", line "+(lineno+2)+": "+lines[lineno];if(VPython_import===null){VPython_import=w[1]}continue}else if(w[0]=="import"){if(w[1]=="vpython"||w[1]=="visual"||w[1]=="vis"){if(w.length==4&&w[2]=="as"){VPython_import=w[3];continue}else return"ERROR: improper import statement, line "+(lineno+2)+": "+lines[lineno]}else{return"ERROR: Cannot import from "+w[1]+", line "+(lineno+2)+": "+lines[lineno]}}}var doublequote=false,singlequote=false,backslash=false;var previouscontinuedline=continuedline;var triplequote=false;var processedtriplequote=false;var tline="";for(var i=0;i<line.length;i++){var previousquote=singlequote||doublequote||triplequote;var char=line[i];if(char=="\\"&&i<line.length-1&&line[i+1]!==" "){i++;continue}switch(char){case"#":if(lang=="javascript")break;if(!singlequote&&!doublequote&&!triplequote){line=line.slice(0,i)}break;case"'":case'"':if(lang=="javascript")break;if(i<=line.length-3&&line[i+1]==char&&line[i+2]==char){triplequote=!triplequote;processedtriplequote=true;i+=2}else{if(char=="'"){if(!doublequote&&!triplequote)singlequote=!singlequote}else{if(!singlequote&&!triplequote)doublequote=!doublequote}}break}if(triplequote&&i==line.length-1&&lineno<lines.length-1){lineno++;line+="\n"+lines[lineno]}if(singlequote||doublequote||triplequote){if(i<line.length-1)continue;if(lineno===lines.length-1){var q="single";if(doublequote)q="double";else q="triple";return"ERROR: Unbalanced "+q+" quotes, line "+(lineno+2)+": "+lines[lineno]}}switch(char){case":":if(parens==1&&braces===0&&brackets===0){indef=true}break;case"(":if(i>0&&line[i-1]=="\\")break;if(parens===0)lastleftparens=lineno;parens++;break;case")":if(i>0&&line[i-1]=="\\")break;parens--;if(indef&&parens==0)indef=false;break;case"[":if(i>0&&line[i-1]=="\\")break;if(brackets===0)lastleftbracket=lineno;brackets++;break;case"]":if(i>0&&line[i-1]=="\\")break;brackets--;break;case"{":if(i>0&&line[i-1]=="\\")break;if(braces===0)lastleftbrace=lineno;braces++;break;case"}":if(i>0&&line[i-1]=="\\")break;braces--;break}if(char=="\\"){if(i==line.length-1||line[i+1]==" "||line[i+1]=="#")line=line.slice(0,i);backslash=true;break}}continuedline=!indef&&(backslash||parens>0||brackets>0||braces>0);if(!previousquote){if(lang=="vpython"){var m=pickpatt.exec(line+" ");if(m){if(m[2]!="("&&m[2].search(/\w/)!=0){var i=m.index;line=line.slice(0,i)+".pick()"+line.slice(i+5)}}}if(!processedtriplequote){var more=true;if(lang!="javascript"){var m=defpatt.exec(line);if(m!==null){var fname=m[1];if(classindent>=0)fname="."+fname;defindents.push([newprogram.length,indent.length,fname,prebraces]);more=false}}else{var m=fctpatt.exec(line);if(m!==null&&(m[1]=="function"||m[2]=="function")){var fname;if(m[1]=="function")fname=m[2];else if(m[2]=="function")fname=m[1];defindents.push([newprogram.length,indent.length,fname,prebraces]);more=false}}if(more){var L=line.length;var ret=waits(line,lang);line=ret[0];if(ret[1]&&defindents.length>0){var definfo=defindents[defindents.length-1];if(!infunction){infunction=true;if(waitfcts[definfo[2]]===undefined)waitfcts[definfo[2]]=ret[2];var end;var start=definfo[0];if(lang!="javascript"){end=newprogram.slice(start).search(/:/)+start;while(newprogram[end]!==")")end--}else{end=newprogram.slice(start).search(/\(/);var parencnt=1;while(parencnt>0){end++;switch(newprogram[start+end]){case"(":parencnt++;break;case")":parencnt--;break}}end+=start}var i=end-1;while(newprogram[i]==" ")i--;var insert;if(newprogram[i]=="(")newprogram=newprogram.slice(0,end)+GS_wait+newprogram.slice(end);else{var iend=i;while(true){i--;var c=newprogram[i];if(c==","||c==" "||c=="(")break}insert=newprogram.slice(i+1,iend+1);if(insert!=GS_wait){if(insert=="wait")newprogram=newprogram.slice(0,i+1)+GS_wait+newprogram.slice(end);else newprogram=newprogram.slice(0,end)+","+GS_wait+newprogram.slice(end)}}}}}}}if(lang=="vpython"||lang=="rapydscript"){c="";if(indent.length<lastindent.length&&(line.charAt(0)==")"||line.substr(0,4)=="else"||line.substr(0,4)=="elif"||line.substr(0,6)=="except"||line.substr(0,7)=="finally")){c=lastindent+lineno_string+delim+(lineno+2)+delim+"\n"}else c=indent+lineno_string+delim+(lineno+2)+delim+"\n";if(indent.length==lastindent.length&&(line.substr(0,4)=="elif"||line.substr(0,4)=="else")){c=""}else if(line.substr(0,3)=='"""'||line.substr(0,3)=="'''"||line[0]==")"){c=""}if(line[line.length-1]=="=")return"ERROR: Line "+(lineno+2)+" ends with equal sign: "+lines[lineno];if(previouscontinuedline){newprogram=newprogram.slice(0,-1)+indent+line+"\n";indent=lastindent}else if(c==""){newprogram+="  "+indent+line+"\n"}else{if(decoration.length>0){newprogram+="  "+c+"  "+indent+decoration+"\n";newprogram+="  "+indent+line+"\n"}else{newprogram+="  "+c+"  "+indent+line+"\n"}}}else{newprogram+=indent+line+"\n"}lastindent=indent;if(parens<0)return"ERROR: Too many right parentheses, line "+(lineno+2)+": "+lines[lineno];if(brackets<0)return"ERROR: Too many right brackets, line "+(lineno+2)+": "+lines[lineno];if(braces<0)return"ERROR: Too many right braces, line "+(lineno+2)+": "+lines[lineno]}for(var i in waitfcts){var fname=i;var wname=waitfcts[i];var reduced_wname=wname[0]=="."?wname.slice(1):wname;var p=new RegExp("\\.bind[^,]*,\\s*"+fname+"\\s*\\)");var n=newprogram.search(p);if(n>=0)throw new Error("Cannot bind function '"+fname+"' to an event because it contains a "+reduced_wname+" statement.");p=new RegExp("\\s*bind\\s*=\\s*"+fname+"\\s*\\)");n=newprogram.search(p);if(n>=0)throw new Error("Cannot bind function '"+fname+"' to a widget because it contains a "+reduced_wname+" statement.");p=new RegExp("(\\w*)\\W*"+fname+"\\s*\\(","g");while(true){var m=p.exec(newprogram);if(m===null)break;if(m[1]=="def"||m[1]=="function")continue;var parencnt=1;var n=p.lastIndex-1;var startarg=n+1;var lastcomma=0;var arg="";var q1=false;var q2=false;while(parencnt>0){n++;switch(newprogram[n]){case"'":q1=!q1;break;case'"':q2=!q2;break;case" ":break;case"(":if(!(q1||q2))parencnt++;break;case",":if(parencnt==1){lastcomma=n;startarg=n+1;arg=""}break;case")":if(!(q1||q2))parencnt--;if(parencnt===0){if(arg.length>0){if(arg=="wait"||arg=="_"){if(lastcomma>0)newprogram=newprogram.slice(0,lastcomma+1)+GS_wait+newprogram.slice(n);else newprogram=newprogram.slice(0,startarg)+GS_wait+newprogram.slice(startarg+4)}else if(arg==GS_wait);else newprogram=newprogram.slice(0,n)+","+GS_wait+newprogram.slice(n)}else{newprogram=newprogram.slice(0,startarg)+GS_wait+newprogram.slice(n)}}break;default:arg+=newprogram[n]}}}}if(parens>0)return"ERROR: Missing right parenthesis, see line "+(lastleftparens+2)+": "+lines[lastleftparens];else if(brackets>0)return"ERROR: Missing right bracket, see line "+(lastleftbracket+2)+": "+lines[lastleftbracket];else if(braces>0)return"ERROR: Missing right brace, see line "+(lastleftbrace+2)+": "+lines[lastleftbrace];else return newprogram}var linenopatt=/"(\d*)"/;var RS_compiler;function compile_rapydscript(rs_input){if(rs_input.slice(0,7)=="ERROR: "){throw new Error(rs_input.slice(7))}else{if(RS_compiler===undefined)RS_compiler=RapydScript.create_embedded_compiler();rs_input+="\n";try{var output=RS_compiler.compile(rs_input,{js_version:5});return output.toString()}catch(err){if(err.line===undefined){throw new Error(err.message)}else{var lines=rs_input.split("\n");var L=lines[err.line];var m=L.match(linenopatt);if(m!==null){throw new Error(err.message+"; line "+m[1]+": "+lines[err.line+1])}else{throw new Error(err.message+": "+lines[err.line])}}}}}var vp_primitives=["box","sphere","cylinder","pyramid","cone","helix","ellipsoid","ring","arrow","compound"];var vp_other=["canvas","vec","vector","rate","sleep","update","color","extrusion","paths","shapes","vertex","triangle","quad","label","distant_light","local_light","attach_trail","attach_arrow","sqrt","pi","abs","sin","cos","tan","asin","acos","atan","atan2","exp","log","pow","factorial","combin","button","radio","checkbox","slider","checkbox","text","radians","degrees","get_library","read_local_file"];function compile(program,options){options=options||{};window.__original={text:program.split("\n")};window.__GSlang=options.lang;var version='["'+options.version+'", "glowscript"]';var findtext=/[^\.\w]text[\ ]*\(/;var findstart=/^text[\ ]*\(/;var loadfonts=findtext.exec(program);if(!loadfonts)loadfonts=findstart.exec(program);program=program.replace(/\.delete/g,".remove");if(options.lang=="rapydscript"||options.lang=="vpython"){program=preprocess(program,options.lang);var vars="";if(program.slice(0,7)=="ERROR: "){compile_rapydscript(program)}else{var prog;if(options.lang=="rapydscript"){prog="def main("+GS_wait+"):\n  version = "+version+"\n  window.__GSlang = 'rapydscript'\n  scene = canvas()\n  print = GSprint\n"+program+"main"}else{program=program.replace(/arange\s*\(/g,"range(");program=program.replace(/\.sort\s*\(/g,".pysort(");prog="def main("+GS_wait+"):\n  version = "+version+"\n";prog+="  window.__GSlang = 'vpython'\n";if(VPython_import===null){for(var i=0;i<vp_primitives.length;i++)prog+="  "+vp_primitives[i]+"=vp_"+vp_primitives[i]+"\n";prog+="  display=canvas\n  vector=vec\n"}else if(VPython_names.length>0){vars+="  vector=vec\n";for(var i=0;i<vp_primitives.length;i++){var name=vp_primitives[i];var n=VPython_names.indexOf(name);if(n>=0)vars+="  "+name+"=vp_"+name+"\n";else vars+="  "+name+"=undefined\n"}var hasvector=VPython_names.indexOf("vector")>=0;for(var i=0;i<vp_other.length;i++){var name=vp_other[i];if(name=="vec"&&hasvector)continue;var n=VPython_names.indexOf(name);if(n<0)vars+="  "+name+"=undefined\n"}prog+=vars}else{var importpatt=new RegExp(VPython_import+"\\.(\\w+)","g");var m=program.match(importpatt);importpatt=new RegExp(VPython_import+"\\.(\\w+)");var attrs={};for(var i=0;i<m.length;i++){var a=importpatt.exec(m[i])[1];if(!(a in attrs))attrs[a]=a}var purge="";vars+="    var "+VPython_import+"={";for(var i=0;i<vp_primitives.length;i++){var name=vp_primitives[i];if(name in attrs)vars+=name+":vp_"+name+", ";else purge+="  "+name+"=undefined\n"}vars+="canvas:canvas, ";for(var i=0;i<vp_other.length;i++){var name=vp_other[i];if(name=="canvas")continue;if(name in attrs){if(name=="vector")vars+="vector:vec, ";else vars+=name+":"+name+", "}else{if(name=="vec"&&"vector"in attrs)continue;purge+="  "+name+"=undefined\n"}}vars=vars.slice(0,-2)+"}\n";prog+=purge}prog+="  print=GSprint\n";if(VPython_import===null||VPython_names.length>0)prog+="  scene = canvas()\n";else prog+="  scene = "+VPython_import+".canvas()\n";prog+="  from pythonize import strings\n";prog+="  strings()\n";prog+=program}program=compile_rapydscript(prog);var start=program.indexOf("window.__GSlang");var arr="Array.prototype['+']=function(r) {return this.concat(r)}\n";arr+="    Array.prototype['*']=function(r) {return __array_times_number(this, r)}\n";arr+="    var __name__ = '__main__'\n";if(VPython_names.length<=0)arr+=vars;program=program.slice(0,start)+arr+program.slice(start-4)}}else{program=preprocess(program,options.lang);var prog="function main("+GS_wait+") {\n";prog+="var version = "+version+";\n";prog+="var scene = canvas();\n";program=prog+program+"\n};\nmain"}if(loadfonts){var s="scene = canvas();\n";var sc=program.indexOf(s)+s.length;s="    waitforfonts("+GS_wait+")\n";program=program.slice(0,sc)+s+program.slice(sc,program.length)}var parsed=papercompile(program);var prog=window.Streamline.transform(parsed,{alreadyParsed:true});program=prog.replace(/\n\n\n\n/g,"");if(options.lang!="javascript")program=program.replace(new RegExp(" "+lineno_string,"g")," ");program=program.replace(/Math.pow/g,"GS_power");if(loadfonts)program="fontloading();\n"+program;var s=GS_wait+"()";var sc=program.lastIndexOf(s);if(sc>-1)program=program.slice(0,sc)+program.slice(sc+s.length,program.length);return program}window.glowscript_compile=compile})();(function(external_namespace){"use strict;";var rs_version="0.7.18";var rs_commit_sha="69282051be6334f2d80a85a7a40e5727b839d8ea";var data={"compiler.js":'(function(){\n    "use strict";\n    var RS_iterator_symbol = (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") ? Symbol.iterator : "iterator-Symbol-5d0927e5554349048cf0e3762a228256";\n    var RS_kwargs_symbol = (typeof Symbol === "function") ? Symbol("kwargs-object") : "kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256";\n    var RS_cond_temp, RS_expr_temp, RS_last_exception;\n    var RS_object_counter = 0;\nvar RS_len;\nfunction RS_bool(val) {\n    return !!val;\n};\nif (!RS_bool.__argnames__) Object.defineProperties(RS_bool, {\n    __argnames__ : {value: ["val"]}\n});\n\nfunction RS_print() {\n    var parts;\n    if (typeof console === "object") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(RS_str(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]));\n        }\n        console.log(parts.join(" "));\n    }\n};\n\nfunction RS_int(val, base) {\n    var ans;\n    if (typeof val === "number") {\n        ans = val | 0;\n    } else {\n        ans = parseInt(val, base || 10);\n    }\n    if (isNaN(ans)) {\n        throw new ValueError("Invalid literal for int with base " + (base || 10) + ": " + val);\n    }\n    return ans;\n};\nif (!RS_int.__argnames__) Object.defineProperties(RS_int, {\n    __argnames__ : {value: ["val", "base"]}\n});\n\nfunction RS_float(val) {\n    var ans;\n    if (typeof val === "number") {\n        ans = val;\n    } else {\n        ans = parseFloat(val);\n    }\n    if (isNaN(ans)) {\n        throw new ValueError("Could not convert string to float: " + arguments[0]);\n    }\n    return ans;\n};\nif (!RS_float.__argnames__) Object.defineProperties(RS_float, {\n    __argnames__ : {value: ["val"]}\n});\n\nfunction RS_arraylike_creator() {\n    var names;\n    names = "Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" ");\n    if (typeof HTMLCollection === "function") {\n        names = names.concat("HTMLCollection NodeList NamedNodeMap TouchList".split(" "));\n    }\n    return (function() {\n        var RS_anonfunc = function (x) {\n            if (Array.isArray(x) || typeof x === "string" || names.indexOf(Object.prototype.toString.call(x).slice(8, -1)) > -1) {\n                return true;\n            }\n            return false;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["x"]}\n        });\n        return RS_anonfunc;\n    })();\n};\n\nfunction options_object(f) {\n    return function () {\n        if (typeof arguments[arguments.length - 1] === "object") {\n            arguments[RS_bound_index(arguments.length - 1, arguments)][RS_kwargs_symbol] = true;\n        }\n        return f.apply(this, arguments);\n    };\n};\nif (!options_object.__argnames__) Object.defineProperties(options_object, {\n    __argnames__ : {value: ["f"]}\n});\n\nfunction RS_id(x) {\n    return x.RS_object_id;\n};\nif (!RS_id.__argnames__) Object.defineProperties(RS_id, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_dir(item) {\n    var arr;\n    arr = RS_list_decorate([]);\n    for (var i in item) {\n        arr.push(i);\n    }\n    return arr;\n};\nif (!RS_dir.__argnames__) Object.defineProperties(RS_dir, {\n    __argnames__ : {value: ["item"]}\n});\n\nfunction RS_ord(x) {\n    var ans, second;\n    ans = x.charCodeAt(0);\n    if (55296 <= ans && ans <= 56319) {\n        second = x.charCodeAt(1);\n        if (56320 <= second && second <= 57343) {\n            return (ans - 55296) * 1024 + second - 56320 + 65536;\n        }\n        throw new TypeError("string is missing the low surrogate char");\n    }\n    return ans;\n};\nif (!RS_ord.__argnames__) Object.defineProperties(RS_ord, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_chr(code) {\n    if (code <= 65535) {\n        return String.fromCharCode(code);\n    }\n    code -= 65536;\n    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n};\nif (!RS_chr.__argnames__) Object.defineProperties(RS_chr, {\n    __argnames__ : {value: ["code"]}\n});\n\nfunction RS_callable(x) {\n    return typeof x === "function";\n};\nif (!RS_callable.__argnames__) Object.defineProperties(RS_callable, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_bin(x) {\n    var ans;\n    if (typeof x !== "number" || x % 1 !== 0) {\n        throw new TypeError("integer required");\n    }\n    ans = x.toString(2);\n    if (ans[0] === "-") {\n        ans = "-" + "0b" + ans.slice(1);\n    } else {\n        ans = "0b" + ans;\n    }\n    return ans;\n};\nif (!RS_bin.__argnames__) Object.defineProperties(RS_bin, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_hex(x) {\n    var ans;\n    if (typeof x !== "number" || x % 1 !== 0) {\n        throw new TypeError("integer required");\n    }\n    ans = x.toString(16);\n    if (ans[0] === "-") {\n        ans = "-" + "0x" + ans.slice(1);\n    } else {\n        ans = "0x" + ans;\n    }\n    return ans;\n};\nif (!RS_hex.__argnames__) Object.defineProperties(RS_hex, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_enumerate(iterable) {\n    var ans, iterator;\n    ans = {"_i":-1};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    if (RS_arraylike(iterable)) {\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {\'done\':false, \'value\':[this._i, iterable[this._i]]};\n            }\n            return {\'done\':true};\n        };\n        return ans;\n    }\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        ans["_iterator"] = iterator;\n        ans["next"] = function () {\n            var r;\n            r = this._iterator.next();\n            if (r.done) {\n                return {\'done\':true};\n            }\n            this._i += 1;\n            return {\'done\':false, \'value\':[this._i, r.value]};\n        };\n        return ans;\n    }\n    return RS_enumerate(Object.keys(iterable));\n};\nif (!RS_enumerate.__argnames__) Object.defineProperties(RS_enumerate, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_reversed(iterable) {\n    var ans;\n    if (RS_arraylike(iterable)) {\n        ans = {"_i": iterable.length};\n        ans["next"] = function () {\n            this._i -= 1;\n            if (this._i > -1) {\n                return {\'done\':false, \'value\':iterable[this._i]};\n            }\n            return {\'done\':true};\n        };\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        return ans;\n    }\n    throw new TypeError("reversed() can only be called on arrays or strings");\n};\nif (!RS_reversed.__argnames__) Object.defineProperties(RS_reversed, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_iter(iterable) {\n    var ans;\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        return (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n    }\n    if (RS_arraylike(iterable)) {\n        ans = {"_i":-1};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {\'done\':false, \'value\':iterable[this._i]};\n            }\n            return {\'done\':true};\n        };\n        return ans;\n    }\n    return RS_iter(Object.keys(iterable));\n};\nif (!RS_iter.__argnames__) Object.defineProperties(RS_iter, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_range_next(step, length) {\n    var RS_unpack;\n    this._i += step;\n    this._idx += 1;\n    if (this._idx >= length) {\n        RS_unpack = [this.__i, -1];\n        this._i = RS_unpack[0];\n        this._idx = RS_unpack[1];\n        return {\'done\':true};\n    }\n    return {\'done\':false, \'value\':this._i};\n};\nif (!RS_range_next.__argnames__) Object.defineProperties(RS_range_next, {\n    __argnames__ : {value: ["step", "length"]}\n});\n\nfunction RS_range(start, stop, step) {\n    var length, ans;\n    if (arguments.length <= 1) {\n        stop = start || 0;\n        start = 0;\n    }\n    step = arguments[2] || 1;\n    length = Math.max(Math.ceil((stop - start) / step), 0);\n    ans = {start:start, step:step, stop:stop};\n    ans[RS_iterator_symbol] = function () {\n        var it;\n        it = {"_i": start - step, "_idx": -1};\n        it.next = RS_range_next.bind(it, step, length);\n        it[RS_iterator_symbol] = function () {\n            return this;\n        };\n        return it;\n    };\n    ans.count = (function() {\n        var RS_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.count(val);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["val"]}\n        });\n        return RS_anonfunc;\n    })();\n    ans.index = (function() {\n        var RS_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.index(val);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["val"]}\n        });\n        return RS_anonfunc;\n    })();\n    if (typeof Proxy === "function") {\n        ans = new Proxy(ans, (function(){\n            var RS_d = {};\n            RS_d["get"] = (function() {\n                var RS_anonfunc = function (obj, prop) {\n                    var iprop;\n                    if (typeof prop === "string") {\n                        iprop = parseInt(prop);\n                        if (!isNaN(iprop)) {\n                            prop = iprop;\n                        }\n                    }\n                    if (typeof prop === "number") {\n                        if (!obj._cached) {\n                            obj._cached = list(obj);\n                        }\n                        return (RS_expr_temp = obj._cached)[(typeof prop === "number" && prop < 0) ? RS_expr_temp.length + prop : prop];\n                    }\n                    return obj[(typeof prop === "number" && prop < 0) ? obj.length + prop : prop];\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["obj", "prop"]}\n                });\n                return RS_anonfunc;\n            })();\n            return RS_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!RS_range.__argnames__) Object.defineProperties(RS_range, {\n    __argnames__ : {value: ["start", "stop", "step"]}\n});\n\nfunction RS_getattr(obj, name, defval) {\n    var ret;\n    try {\n        ret = obj[(typeof name === "number" && name < 0) ? obj.length + name : name];\n    } catch (RS_Exception) {\n        RS_last_exception = RS_Exception;\n        if (RS_Exception instanceof TypeError) {\n            if (defval === undefined) {\n                throw new AttributeError("The attribute " + name + " is not present");\n            }\n            return defval;\n        } else {\n            throw RS_Exception;\n        }\n    }\n    if (ret === undefined && !(name in obj)) {\n        if (defval === undefined) {\n            throw new AttributeError("The attribute " + name + " is not present");\n        }\n        ret = defval;\n    }\n    return ret;\n};\nif (!RS_getattr.__argnames__) Object.defineProperties(RS_getattr, {\n    __argnames__ : {value: ["obj", "name", "defval"]}\n});\n\nfunction RS_setattr(obj, name, value) {\n    obj[(typeof name === "number" && name < 0) ? obj.length + name : name] = value;\n};\nif (!RS_setattr.__argnames__) Object.defineProperties(RS_setattr, {\n    __argnames__ : {value: ["obj", "name", "value"]}\n});\n\nfunction RS_hasattr(obj, name) {\n    return name in obj;\n};\nif (!RS_hasattr.__argnames__) Object.defineProperties(RS_hasattr, {\n    __argnames__ : {value: ["obj", "name"]}\n});\n\nRS_len = function () {\n    function len(obj) {\n        if (RS_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === "function") {\n            return obj.__len__();\n        }\n        if (obj instanceof Set || obj instanceof Map) {\n            return obj.size;\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len.__argnames__) Object.defineProperties(len, {\n        __argnames__ : {value: ["obj"]}\n    });\n\n    function len5(obj) {\n        if (RS_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === "function") {\n            return obj.__len__();\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len5.__argnames__) Object.defineProperties(len5, {\n        __argnames__ : {value: ["obj"]}\n    });\n\n    return (typeof Set === "function" && typeof Map === "function") ? len : len5;\n}();\nfunction RS_get_module(name) {\n    return RS_modules[(typeof name === "number" && name < 0) ? RS_modules.length + name : name];\n};\nif (!RS_get_module.__argnames__) Object.defineProperties(RS_get_module, {\n    __argnames__ : {value: ["name"]}\n});\n\nfunction RS_pow(x, y, z) {\n    var ans;\n    ans = Math.pow(x, y);\n    if (z !== undefined) {\n        ans %= z;\n    }\n    return ans;\n};\nif (!RS_pow.__argnames__) Object.defineProperties(RS_pow, {\n    __argnames__ : {value: ["x", "y", "z"]}\n});\n\nfunction RS_type(x) {\n    return x.constructor;\n};\nif (!RS_type.__argnames__) Object.defineProperties(RS_type, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_divmod(x, y) {\n    var d;\n    if (y === 0) {\n        throw new ZeroDivisionError("integer division or modulo by zero");\n    }\n    d = Math.floor(x / y);\n    return [d, x - d * y];\n};\nif (!RS_divmod.__argnames__) Object.defineProperties(RS_divmod, {\n    __argnames__ : {value: ["x", "y"]}\n});\n\nfunction RS_max() {\n    var kwargs = arguments[arguments.length-1];\n    if (kwargs === null || typeof kwargs !== "object" || kwargs [RS_kwargs_symbol] !== true) kwargs = {};\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (kwargs !== null && typeof kwargs === "object" && kwargs [RS_kwargs_symbol] === true) args.pop();\n    var args, x;\n    if (args.length === 0) {\n        if (kwargs.defval !== undefined) {\n            return kwargs.defval;\n        }\n        throw new TypeError("expected at least one argument");\n    }\n    if (args.length === 1) {\n        args = args[0];\n    }\n    if (kwargs.key) {\n        args = (function() {\n            var RS_Iter = RS_Iterable(args), RS_Result = [], x;\n            for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                x = RS_Iter[RS_Index];\n                RS_Result.push(kwargs.key(x));\n            }\n            RS_Result = RS_list_constructor(RS_Result);\n            return RS_Result;\n        })();\n    }\n    if (!Array.isArray(args)) {\n        args = list(args);\n    }\n    if (args.length) {\n        return this.apply(null, args);\n    }\n    if (kwargs.defval !== undefined) {\n        return kwargs.defval;\n    }\n    throw new TypeError("expected at least one argument");\n};\nif (!RS_max.__handles_kwarg_interpolation__) Object.defineProperties(RS_max, {\n    __handles_kwarg_interpolation__ : {value: true}\n});\n\nvar abs = Math.abs, max = RS_max.bind(Math.max), min = RS_max.bind(Math.min), bool = RS_bool, type = RS_type;\nvar float = RS_float, int = RS_int, arraylike = RS_arraylike_creator(), RS_arraylike = arraylike;\nvar print = RS_print, id = RS_id, get_module = RS_get_module, pow = RS_pow, divmod = RS_divmod;\nvar dir = RS_dir, ord = RS_ord, chr = RS_chr, bin = RS_bin, hex = RS_hex, callable = RS_callable;\nvar enumerate = RS_enumerate, iter = RS_iter, reversed = RS_reversed, len = RS_len;\nvar range = RS_range, getattr = RS_getattr, setattr = RS_setattr, hasattr = RS_hasattr;function RS_equals(a, b) {\n    var RS_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === "function") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === "function") {\n        return b.__eq__(a);\n    }\n    if (RS_arraylike(a) && RS_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== "object" || RS_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[(typeof i === "number" && i < 0) ? a.length + i : i] === b[(typeof i === "number" && i < 0) ? b.length + i : i] || typeof a[(typeof i === "number" && i < 0) ? a.length + i : i] === "object" && RS_equals(a[(typeof i === "number" && i < 0) ? a.length + i : i], b[(typeof i === "number" && i < 0) ? b.length + i : i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof a === "object" && typeof b === "object" && a !== null && b !== null && (a.constructor === Object && b.constructor === Object || Object.getPrototypeOf(a) === null && Object.getPrototypeOf(b) === null)) {\n        RS_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = RS_unpack[0];\n        bkeys = RS_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var j=0; j < akeys.length; j++) {\n            key = akeys[(typeof j === "number" && j < 0) ? akeys.length + j : j];\n            if (!((a[(typeof key === "number" && key < 0) ? a.length + key : key] === b[(typeof key === "number" && key < 0) ? b.length + key : key] || typeof a[(typeof key === "number" && key < 0) ? a.length + key : key] === "object" && RS_equals(a[(typeof key === "number" && key < 0) ? a.length + key : key], b[(typeof key === "number" && key < 0) ? b.length + key : key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\nif (!RS_equals.__argnames__) Object.defineProperties(RS_equals, {\n    __argnames__ : {value: ["a", "b"]}\n});\n\nfunction RS_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === "function") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === "function") {\n        return b.__ne__(a);\n    }\n    return !RS_equals(a, b);\n};\nif (!RS_not_equals.__argnames__) Object.defineProperties(RS_not_equals, {\n    __argnames__ : {value: ["a", "b"]}\n});\n\nvar equals = RS_equals;\nfunction RS_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === "string") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            (RS_expr_temp = this)[RS_bound_index(start + i, RS_expr_temp)] = iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i];\n        }\n    } else {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n};\nif (!RS_list_extend.__argnames__) Object.defineProperties(RS_list_extend, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + " is not in list");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + " is not in list");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if (((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === val || typeof (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === "object" && RS_equals((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + " is not in list");\n};\nif (!RS_list_index.__argnames__) Object.defineProperties(RS_list_index, {\n    __argnames__ : {value: ["val", "start", "stop"]}\n});\n\nfunction RS_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError("list is empty");\n    }\n    if (index === undefined) {\n        index = -1;\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError("pop index out of range");\n    }\n    return ans[0];\n};\nif (!RS_list_pop.__argnames__) Object.defineProperties(RS_list_pop, {\n    __argnames__ : {value: ["index"]}\n});\n\nfunction RS_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + " not in list");\n    }\n    this.splice(idx, 1);\n};\nif (!RS_list_remove.__argnames__) Object.defineProperties(RS_list_remove, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_to_string() {\n    return "[" + this.join(", ") + "]";\n};\n\nfunction RS_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] = (RS_expr_temp = this)[RS_bound_index(i - 1, RS_expr_temp)];\n    }\n    (RS_expr_temp = this)[(typeof index === "number" && index < 0) ? RS_expr_temp.length + index : index] = val;\n};\nif (!RS_list_insert.__argnames__) Object.defineProperties(RS_list_insert, {\n    __argnames__ : {value: ["index", "val"]}\n});\n\nfunction RS_list_copy() {\n    return RS_list_constructor(this);\n};\n\nfunction RS_list_clear() {\n    this.length = 0;\n};\n\nfunction RS_list_as_array() {\n    return Array.prototype.slice.call(this);\n};\n\nfunction RS_list_count(value) {\n    return this.reduce((function() {\n        var RS_anonfunc = function (n, val) {\n            return n + (val === value);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["n", "val"]}\n        });\n        return RS_anonfunc;\n    })(), 0);\n};\nif (!RS_list_count.__argnames__) Object.defineProperties(RS_list_count, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === "string" || t === "number") {\n        return value;\n    }\n    return value.toString();\n};\nif (!RS_list_sort_key.__argnames__) Object.defineProperties(RS_list_sort_key, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_sort_cmp(a, b, ap, bp) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return ap - bp;\n};\nif (!RS_list_sort_cmp.__argnames__) Object.defineProperties(RS_list_sort_cmp, {\n    __argnames__ : {value: ["a", "b", "ap", "bp"]}\n});\n\nfunction RS_list_sort() {\n    var key = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? RS_list_sort.__defaults__.key : arguments[0];\n    var reverse = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? RS_list_sort.__defaults__.reverse : arguments[1];\n    var RS_kwargs_obj = arguments[arguments.length-1];\n    if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "key")){\n        key = RS_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "reverse")){\n        reverse = RS_kwargs_obj.reverse;\n    }\n    var mult, keymap, posmap, k;\n    key = key || RS_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    posmap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n        keymap.set(k, key(k));\n        posmap.set(k, i);\n    }\n    this.sort((function() {\n        var RS_anonfunc = function (a, b) {\n            return mult * RS_list_sort_cmp(keymap.get(a), keymap.get(b), posmap.get(a), posmap.get(b));\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["a", "b"]}\n        });\n        return RS_anonfunc;\n    })());\n};\nif (!RS_list_sort.__defaults__) Object.defineProperties(RS_list_sort, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: ["key", "reverse"]}\n});\n\nfunction RS_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    RS_list_decorate(ans);\n    return ans;\n};\n\nfunction RS_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    RS_list_decorate(ans);\n    return ans;\n};\n\nfunction RS_list_iterator(value) {\n    var self;\n    self = this;\n    return (function(){\n        var RS_d = {};\n        RS_d["_i"] = -1;\n        RS_d["_list"] = self;\n        RS_d["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._list.length) {\n                return (function(){\n                    var RS_d = {};\n                    RS_d["done"] = true;\n                    return RS_d;\n                }).call(this);\n            }\n            return (function(){\n                var RS_d = {};\n                RS_d["done"] = false;\n                RS_d["value"] = (RS_expr_temp = this._list)[RS_bound_index(this._i, RS_expr_temp)];\n                return RS_d;\n            }).call(this);\n        };\n        return RS_d;\n    }).call(this);\n};\nif (!RS_list_iterator.__argnames__) Object.defineProperties(RS_list_iterator, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_len() {\n    return this.length;\n};\n\nfunction RS_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if (((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === val || typeof (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === "object" && RS_equals((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i], val))) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!RS_list_contains.__argnames__) Object.defineProperties(RS_list_contains, {\n    __argnames__ : {value: ["val"]}\n});\n\nfunction RS_list_eq(other) {\n    if (!RS_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== "object" || RS_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!(((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === other[(typeof i === "number" && i < 0) ? other.length + i : i] || typeof (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === "object" && RS_equals((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i], other[(typeof i === "number" && i < 0) ? other.length + i : i])))) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!RS_list_eq.__argnames__) Object.defineProperties(RS_list_eq, {\n    __argnames__ : {value: ["other"]}\n});\n\nfunction RS_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = RS_list_to_string;\n    ans.inspect = RS_list_to_string;\n    ans.extend = RS_list_extend;\n    ans.index = RS_list_index;\n    ans.pypop = RS_list_pop;\n    ans.remove = RS_list_remove;\n    ans.insert = RS_list_insert;\n    ans.copy = RS_list_copy;\n    ans.clear = RS_list_clear;\n    ans.count = RS_list_count;\n    ans.concat = RS_list_concat;\n    ans.pysort = RS_list_sort;\n    ans.slice = RS_list_slice;\n    ans.as_array = RS_list_as_array;\n    ans.__len__ = RS_list_len;\n    ans.__contains__ = RS_list_contains;\n    ans.__eq__ = RS_list_eq;\n    ans.constructor = RS_list_constructor;\n    if (typeof ans[RS_iterator_symbol] !== "function") {\n        ans[RS_iterator_symbol] = RS_list_iterator;\n    }\n    return ans;\n};\nif (!RS_list_decorate.__argnames__) Object.defineProperties(RS_list_decorate, {\n    __argnames__ : {value: ["ans"]}\n});\n\nfunction RS_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (RS_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[(typeof i === "number" && i < 0) ? ans.length + i : i] = iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i];\n        }\n    } else if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        ans = RS_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === "number") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return RS_list_decorate(ans);\n};\nif (!RS_list_constructor.__argnames__) Object.defineProperties(RS_list_constructor, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_list_constructor.__name__ = "list";\nvar list = RS_list_constructor, list_wrap = RS_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? sorted.__defaults__.key : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? sorted.__defaults__.reverse : arguments[2];\n    var RS_kwargs_obj = arguments[arguments.length-1];\n    if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "key")){\n        key = RS_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "reverse")){\n        reverse = RS_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = RS_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n};\nif (!sorted.__defaults__) Object.defineProperties(sorted, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: ["iterable", "key", "reverse"]}\n});\n\nvar RS_global_object_id = 0, RS_set_implementation;\nfunction RS_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === "string" || t === "number" || t === "boolean") {\n        return "_" + t[0] + x;\n    }\n    if (x === null) {\n        return "__!@#$0";\n    }\n    ans = x.RS_hash_key_prop;\n    if (ans === undefined) {\n        ans = "_!@#$" + (++RS_global_object_id);\n        Object.defineProperty(x, "RS_hash_key_prop", (function(){\n            var RS_d = {};\n            RS_d["value"] = ans;\n            return RS_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!RS_set_keyfor.__argnames__) Object.defineProperties(RS_set_keyfor, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nRS_set_polyfill.prototype.add = (function() {\n    var RS_anonfunc = function (x) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n            (RS_expr_temp = this._store)[(typeof key === "number" && key < 0) ? RS_expr_temp.length + key : key] = x;\n        }\n        return this;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.clear = (function() {\n    var RS_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.delete = (function() {\n    var RS_anonfunc = function (x) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.has = (function() {\n    var RS_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, RS_set_keyfor(x));\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.values = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nif (typeof Set !== "function" || typeof Set.prototype.delete !== "function") {\n    RS_set_implementation = RS_set_polyfill;\n} else {\n    RS_set_implementation = Set;\n}\nfunction RS_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof RS_set) {\n        this.jsset = new RS_set_implementation;\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (RS_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i]);\n            }\n        } else if (typeof iterable[RS_iterator_symbol] === "function") {\n            iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                s.add(keys[(typeof j === "number" && j < 0) ? keys.length + j : j]);\n            }\n        }\n        return ans;\n    } else {\n        return new RS_set(iterable);\n    }\n};\nif (!RS_set.__argnames__) Object.defineProperties(RS_set, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_set.prototype.__name__ = "set";\nObject.defineProperties(RS_set.prototype, (function(){\n    var RS_d = {};\n    RS_d["length"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsset.size;\n        };\n        return RS_d;\n    }).call(this);\n    RS_d["size"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsset.size;\n        };\n        return RS_d;\n    }).call(this);\n    return RS_d;\n}).call(this));\nRS_set.prototype.__len__ = function () {\n    return this.jsset.size;\n};\nRS_set.prototype.has = RS_set.prototype.__contains__ = (function() {\n    var RS_anonfunc = function (x) {\n        return this.jsset.has(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.add = (function() {\n    var RS_anonfunc = function (x) {\n        this.jsset.add(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.clear = function () {\n    this.jsset.clear();\n};\nRS_set.prototype.copy = function () {\n    return RS_set(this);\n};\nRS_set.prototype.discard = (function() {\n    var RS_anonfunc = function (x) {\n        this.jsset.delete(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype[RS_iterator_symbol] = function () {\n    return this.jsset.values();\n};\nRS_set.prototype.difference = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new RS_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = false;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = true;\n                break;\n            }\n        }\n        if (!has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nRS_set.prototype.difference_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === "number" && j < 0) ? remove.length + j : j]);\n    }\n};\nRS_set.prototype.intersection = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new RS_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = true;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = false;\n                break;\n            }\n        }\n        if (has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nRS_set.prototype.intersection_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === "number" && j < 0) ? remove.length + j : j]);\n    }\n};\nRS_set.prototype.isdisjoint = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.issubset = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.issuperset = (function() {\n    var RS_anonfunc = function (other) {\n        var s, iterator, r, x;\n        s = this.jsset;\n        iterator = other.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!s.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.pop = function () {\n    var iterator, r;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    if (r.done) {\n        throw new KeyError("pop from an empty set");\n    }\n    this.jsset.delete(r.value);\n    return r.value;\n};\nRS_set.prototype.remove = (function() {\n    var RS_anonfunc = function (x) {\n        if (!this.jsset.delete(x)) {\n            throw new KeyError(x.toString());\n        }\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.symmetric_difference = (function() {\n    var RS_anonfunc = function (other) {\n        return this.union(other).difference(this.intersection(other));\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.symmetric_difference_update = (function() {\n    var RS_anonfunc = function (other) {\n        var common;\n        common = this.intersection(other);\n        this.update(other);\n        this.difference_update(common);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.union = function () {\n    var ans;\n    ans = RS_set(this);\n    ans.update.apply(ans, arguments);\n    return ans;\n};\nRS_set.prototype.update = function () {\n    var s, iterator, r;\n    s = this.jsset;\n    for (var i=0; i < arguments.length; i++) {\n        iterator = arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i][RS_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            s.add(r.value);\n            r = iterator.next();\n        }\n    }\n};\nRS_set.prototype.toString = RS_set.prototype.__repr__ = RS_set.prototype.__str__ = RS_set.prototype.inspect = function () {\n    return "{" + list(this).join(", ") + "}";\n};\nRS_set.prototype.__eq__ = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r;\n        if (!other instanceof this.constructor) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other[RS_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            if (!this.has(r.value)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nfunction RS_set_wrap(x) {\n    var ans;\n    ans = new RS_set;\n    ans.jsset = x;\n    return ans;\n};\nif (!RS_set_wrap.__argnames__) Object.defineProperties(RS_set_wrap, {\n    __argnames__ : {value: ["x"]}\n});\n\nvar set = RS_set, set_wrap = RS_set_wrap;\nvar RS_dict_implementation;\nfunction RS_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nRS_dict_polyfill.prototype.set = (function() {\n    var RS_anonfunc = function (x, value) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n        }\n        (RS_expr_temp = this._store)[(typeof key === "number" && key < 0) ? RS_expr_temp.length + key : key] = [x, value];\n        return this;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x", "value"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.clear = (function() {\n    var RS_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.delete = (function() {\n    var RS_anonfunc = function (x) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.has = (function() {\n    var RS_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, RS_set_keyfor(x));\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.get = (function() {\n    var RS_anonfunc = function (x) {\n        try {\n            return (RS_expr_temp = this._store)[RS_bound_index(RS_set_keyfor(x), RS_expr_temp)][1];\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            if (RS_Exception instanceof TypeError) {\n                return undefined;\n            } else {\n                throw RS_Exception;\n            }\n        }\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.values = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]][1]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.keys = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]][0]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.entries = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nif (typeof Map !== "function" || typeof Map.prototype.delete !== "function") {\n    RS_dict_implementation = RS_dict_polyfill;\n} else {\n    RS_dict_implementation = Map;\n}\nfunction RS_dict() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true) ? undefined : arguments[0];\n    var kw = arguments[arguments.length-1];\n    if (kw === null || typeof kw !== "object" || kw [RS_kwargs_symbol] !== true) kw = {};\n    if (this instanceof RS_dict) {\n        this.jsmap = new RS_dict_implementation;\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        this.update(kw);\n        return this;\n    } else {\n        return RS_interpolate_kwargs_constructor.call(Object.create(RS_dict.prototype), false, RS_dict, [iterable].concat([RS_desugar_kwargs(kw)]));\n    }\n};\nif (!RS_dict.__handles_kwarg_interpolation__) Object.defineProperties(RS_dict, {\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_dict.prototype.__name__ = "dict";\nObject.defineProperties(RS_dict.prototype, (function(){\n    var RS_d = {};\n    RS_d["length"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsmap.size;\n        };\n        return RS_d;\n    }).call(this);\n    RS_d["size"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsmap.size;\n        };\n        return RS_d;\n    }).call(this);\n    return RS_d;\n}).call(this));\nRS_dict.prototype.__len__ = function () {\n    return this.jsmap.size;\n};\nRS_dict.prototype.has = RS_dict.prototype.__contains__ = (function() {\n    var RS_anonfunc = function (x) {\n        return this.jsmap.has(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.set = RS_dict.prototype.__setitem__ = (function() {\n    var RS_anonfunc = function (key, value) {\n        this.jsmap.set(key, value);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "value"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.__delitem__ = (function() {\n    var RS_anonfunc = function (key) {\n        this.jsmap.delete(key);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.clear = function () {\n    this.jsmap.clear();\n};\nRS_dict.prototype.copy = function () {\n    return RS_dict(this);\n};\nRS_dict.prototype.keys = function () {\n    return this.jsmap.keys();\n};\nRS_dict.prototype.values = function () {\n    return this.jsmap.values();\n};\nRS_dict.prototype.items = RS_dict.prototype.entries = function () {\n    return this.jsmap.entries();\n};\nRS_dict.prototype[RS_iterator_symbol] = function () {\n    return this.jsmap.keys();\n};\nRS_dict.prototype.__getitem__ = (function() {\n    var RS_anonfunc = function (key) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            throw new KeyError(key + "");\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.get = (function() {\n    var RS_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            return (defval === undefined) ? null : defval;\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "defval"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.set_default = (function() {\n    var RS_anonfunc = function (key, defval) {\n        var j;\n        j = this.jsmap;\n        if (!j.has(key)) {\n            j.set(key, defval);\n            return defval;\n        }\n        return j.get(key);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "defval"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.fromkeys = RS_dict.prototype.fromkeys = (function() {\n    var RS_anonfunc = function () {\n        var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true) ? undefined : arguments[0];\n        var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? RS_anonfunc.__defaults__.value : arguments[1];\n        var RS_kwargs_obj = arguments[arguments.length-1];\n        if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n        if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "value")){\n            value = RS_kwargs_obj.value;\n        }\n        var ans, iterator, r;\n        ans = RS_dict();\n        iterator = iter(iterable);\n        r = iterator.next();\n        while (!r.done) {\n            ans.set(r.value, value);\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__defaults__) Object.defineProperties(RS_anonfunc, {\n        __defaults__ : {value: {value:null}},\n        __handles_kwarg_interpolation__ : {value: true},\n        __argnames__ : {value: ["iterable", "value"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.pop = (function() {\n    var RS_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            if (defval === undefined) {\n                throw new KeyError(key);\n            }\n            return defval;\n        }\n        this.jsmap.delete(key);\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "defval"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.popitem = function () {\n    var r;\n    r = this.jsmap.entries().next();\n    if (r.done) {\n        throw new KeyError("dict is empty");\n    }\n    this.jsmap.delete(r.value[0]);\n    return r.value;\n};\nRS_dict.prototype.update = function () {\n    var m, iterable, iterator, result, keys;\n    if (arguments.length === 0) {\n        return;\n    }\n    m = this.jsmap;\n    iterable = arguments[0];\n    if (Array.isArray(iterable)) {\n        for (var i = 0; i < iterable.length; i++) {\n            m.set(iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i][0], iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i][1]);\n        }\n    } else if (iterable instanceof RS_dict) {\n        iterator = iterable.items();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof Map === "function" && iterable instanceof Map) {\n        iterator = iterable.entries();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = iterable[RS_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else {\n        keys = Object.keys(iterable);\n        for (var j=0; j < keys.length; j++) {\n            if (keys[(typeof j === "number" && j < 0) ? keys.length + j : j] !== RS_iterator_symbol) {\n                m.set(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], iterable[RS_bound_index(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], iterable)]);\n            }\n        }\n    }\n    if (arguments.length > 1) {\n        RS_dict.prototype.update.call(this, arguments[1]);\n    }\n};\nRS_dict.prototype.toString = RS_dict.prototype.inspect = RS_dict.prototype.__str__ = RS_dict.prototype.__repr__ = function () {\n    var entries, iterator, r;\n    entries = [];\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        entries.push(RS_repr(r.value[0]) + ": " + RS_repr(r.value[1]));\n        r = iterator.next();\n    }\n    return "{" + entries.join(", ") + "}";\n};\nRS_dict.prototype.__eq__ = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r, x;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other.items();\n        r = iterator.next();\n        while (!r.done) {\n            x = this.jsmap.get(r.value[0]);\n            if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.as_object = (function() {\n    var RS_anonfunc = function (other) {\n        var ans, iterator, r;\n        ans = {};\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            ans[RS_bound_index(r.value[0], ans)] = r.value[1];\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nfunction RS_dict_wrap(x) {\n    var ans;\n    ans = new RS_dict;\n    ans.jsmap = x;\n    return ans;\n};\nif (!RS_dict_wrap.__argnames__) Object.defineProperties(RS_dict_wrap, {\n    __argnames__ : {value: ["x"]}\n});\n\nvar dict = RS_dict, dict_wrap = RS_dict_wrap;var NameError;\nNameError = ReferenceError;\nfunction Exception() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    Exception.prototype.__init__.apply(this, arguments);\n}\nRS_extends(Exception, Error);\nException.prototype.__init__ = function __init__(message) {\n    var self = this;\n    self.message = message;\n    self.stack = (new Error).stack;\n    self.name = self.constructor.name;\n};\nif (!Exception.prototype.__init__.__argnames__) Object.defineProperties(Exception.prototype.__init__, {\n    __argnames__ : {value: ["message"]}\n});\nException.__argnames__ = Exception.prototype.__init__.__argnames__;\nException.__handles_kwarg_interpolation__ = Exception.prototype.__init__.__handles_kwarg_interpolation__;\nException.prototype.__repr__ = function __repr__() {\n    var self = this;\n    return self.name + ": " + self.message;\n};\nException.prototype.__str__ = function __str__ () {\n    if(Error.prototype.__str__) return Error.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(Exception.prototype, "__bases__", {value: [Error]});\n\nfunction AttributeError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(AttributeError, Exception);\nAttributeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAttributeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AttributeError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction IndexError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(IndexError, Exception);\nIndexError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nIndexError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(IndexError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction KeyError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(KeyError, Exception);\nKeyError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nKeyError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(KeyError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction ValueError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(ValueError, Exception);\nValueError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nValueError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nValueError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ValueError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction UnicodeDecodeError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    UnicodeDecodeError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(UnicodeDecodeError, Exception);\nUnicodeDecodeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nUnicodeDecodeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nUnicodeDecodeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(UnicodeDecodeError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction AssertionError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    AssertionError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(AssertionError, Exception);\nAssertionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAssertionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nAssertionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AssertionError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction ZeroDivisionError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    ZeroDivisionError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(ZeroDivisionError, Exception);\nZeroDivisionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nZeroDivisionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nZeroDivisionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ZeroDivisionError.prototype, "__bases__", {value: [Exception]});\n\nvar RS_in, RS_desugar_kwargs, RS_exists;\nfunction RS_eslice(arr, step, start, end) {\n    var is_string;\n    if (typeof arr === "string" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split("");\n    }\n    if (step < 0) {\n        step = -step;\n        arr = arr.slice().reverse();\n        if (typeof start !== "undefined") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== "undefined") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === "undefined") {\n        start = 0;\n    }\n    if (typeof end === "undefined") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter((function() {\n        var RS_anonfunc = function (e, i) {\n            return i % step === 0;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["e", "i"]}\n        });\n        return RS_anonfunc;\n    })());\n    if (is_string) {\n        arr = arr.join("");\n    }\n    return arr;\n};\nif (!RS_eslice.__argnames__) Object.defineProperties(RS_eslice, {\n    __argnames__ : {value: ["arr", "step", "start", "end"]}\n});\n\nfunction RS_delslice(arr, step, start, end) {\n    var is_string, RS_unpack, indices;\n    if (typeof arr === "string" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split("");\n    }\n    if (step < 0) {\n        if (typeof start === "undefined") {\n            start = arr.length;\n        }\n        if (typeof end === "undefined") {\n            end = 0;\n        }\n        RS_unpack = [end, start, -step];\n        start = RS_unpack[0];\n        end = RS_unpack[1];\n        step = RS_unpack[2];\n    }\n    if (typeof start === "undefined") {\n        start = 0;\n    }\n    if (typeof end === "undefined") {\n        end = arr.length;\n    }\n    if (step === 1) {\n        arr.splice(start, end - start);\n    } else {\n        if (end > start) {\n            indices = [];\n            for (var i = start; i < end; i += step) {\n                indices.push(i);\n            }\n            for (var i = indices.length - 1; i >= 0; i--) {\n                arr.splice(indices[(typeof i === "number" && i < 0) ? indices.length + i : i], 1);\n            }\n        }\n    }\n    if (is_string) {\n        arr = arr.join("");\n    }\n    return arr;\n};\nif (!RS_delslice.__argnames__) Object.defineProperties(RS_delslice, {\n    __argnames__ : {value: ["arr", "step", "start", "end"]}\n});\n\nfunction RS_flatten(arr) {\n    var ans, value;\n    ans = RS_list_decorate([]);\n    for (var i=0; i < arr.length; i++) {\n        value = arr[(typeof i === "number" && i < 0) ? arr.length + i : i];\n        if (Array.isArray(value)) {\n            ans = ans.concat(RS_flatten(value));\n        } else {\n            ans.push(value);\n        }\n    }\n    return ans;\n};\nif (!RS_flatten.__argnames__) Object.defineProperties(RS_flatten, {\n    __argnames__ : {value: ["arr"]}\n});\n\nfunction RS_unpack_asarray(num, iterable) {\n    var ans, iterator, result;\n    if (RS_arraylike(iterable)) {\n        return iterable;\n    }\n    ans = [];\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done && ans.length < num) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    }\n    return ans;\n};\nif (!RS_unpack_asarray.__argnames__) Object.defineProperties(RS_unpack_asarray, {\n    __argnames__ : {value: ["num", "iterable"]}\n});\n\nfunction RS_extends(child, parent) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\nif (!RS_extends.__argnames__) Object.defineProperties(RS_extends, {\n    __argnames__ : {value: ["child", "parent"]}\n});\n\nRS_in = function () {\n    if (typeof Map === "function" && typeof Set === "function") {\n        return (function() {\n            var RS_anonfunc = function (val, arr) {\n                if (typeof arr === "string") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === "function") {\n                    return arr.__contains__(val);\n                }\n                if (arr instanceof Map || arr instanceof Set) {\n                    return arr.has(val);\n                }\n                if (RS_arraylike(arr)) {\n                    return RS_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["val", "arr"]}\n            });\n            return RS_anonfunc;\n        })();\n    }\n    return (function() {\n        var RS_anonfunc = function (val, arr) {\n            if (typeof arr === "string") {\n                return arr.indexOf(val) !== -1;\n            }\n            if (typeof arr.__contains__ === "function") {\n                return arr.__contains__(val);\n            }\n            if (RS_arraylike(arr)) {\n                return RS_list_contains.call(arr, val);\n            }\n            return Object.prototype.hasOwnProperty.call(arr, val);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["val", "arr"]}\n        });\n        return RS_anonfunc;\n    })();\n}();\nfunction RS_Iterable(iterable) {\n    var iterator, ans, result;\n    if (RS_arraylike(iterable)) {\n        return iterable;\n    }\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        ans = RS_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n        return ans;\n    }\n    return Object.keys(iterable);\n};\nif (!RS_Iterable.__argnames__) Object.defineProperties(RS_Iterable, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_desugar_kwargs = function () {\n    if (typeof Object.assign === "function") {\n        return function () {\n            var ans;\n            ans = Object.create(null);\n            ans[RS_kwargs_symbol] = true;\n            for (var i = 0; i < arguments.length; i++) {\n                Object.assign(ans, arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n            }\n            return ans;\n        };\n    }\n    return function () {\n        var ans, keys;\n        ans = Object.create(null);\n        ans[RS_kwargs_symbol] = true;\n        for (var i = 0; i < arguments.length; i++) {\n            keys = Object.keys(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n            for (var j = 0; j < keys.length; j++) {\n                ans[RS_bound_index(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], ans)] = (RS_expr_temp = arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i])[RS_bound_index(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], RS_expr_temp)];\n            }\n        }\n        return ans;\n    };\n}();\nfunction RS_interpolate_kwargs(f, supplied_args) {\n    var has_prop, kwobj, args, prop;\n    if (!f.__argnames__) {\n        return f.apply(this, supplied_args);\n    }\n    has_prop = Object.prototype.hasOwnProperty;\n    kwobj = supplied_args.pop();\n    if (f.__handles_kwarg_interpolation__) {\n        args = new Array(Math.max(supplied_args.length, f.__argnames__.length) + 1);\n        args[args.length-1] = kwobj;\n        for (var i = 0; i < args.length - 1; i++) {\n            if (i < f.__argnames__.length) {\n                prop = (RS_expr_temp = f.__argnames__)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n                if (has_prop.call(kwobj, prop)) {\n                    args[(typeof i === "number" && i < 0) ? args.length + i : i] = kwobj[(typeof prop === "number" && prop < 0) ? kwobj.length + prop : prop];\n                    delete kwobj[prop];\n                } else if (i < supplied_args.length) {\n                    args[(typeof i === "number" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === "number" && i < 0) ? supplied_args.length + i : i];\n                }\n            } else {\n                args[(typeof i === "number" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === "number" && i < 0) ? supplied_args.length + i : i];\n            }\n        }\n        return f.apply(this, args);\n    }\n    for (var i = 0; i < f.__argnames__.length; i++) {\n        prop = (RS_expr_temp = f.__argnames__)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n        if (has_prop.call(kwobj, prop)) {\n            supplied_args[(typeof i === "number" && i < 0) ? supplied_args.length + i : i] = kwobj[(typeof prop === "number" && prop < 0) ? kwobj.length + prop : prop];\n        }\n    }\n    return f.apply(this, supplied_args);\n};\nif (!RS_interpolate_kwargs.__argnames__) Object.defineProperties(RS_interpolate_kwargs, {\n    __argnames__ : {value: ["f", "supplied_args"]}\n});\n\nfunction RS_interpolate_kwargs_constructor(apply, f, supplied_args) {\n    if (apply) {\n        f.apply(this, supplied_args);\n    } else {\n        RS_interpolate_kwargs.call(this, f, supplied_args);\n    }\n    return this;\n};\nif (!RS_interpolate_kwargs_constructor.__argnames__) Object.defineProperties(RS_interpolate_kwargs_constructor, {\n    __argnames__ : {value: ["apply", "f", "supplied_args"]}\n});\n\nfunction RS_getitem(obj, key) {\n    if (obj.__getitem__) {\n        return obj.__getitem__(key);\n    }\n    if (typeof key === "number" && key < 0) {\n        key += obj.length;\n    }\n    return obj[(typeof key === "number" && key < 0) ? obj.length + key : key];\n};\nif (!RS_getitem.__argnames__) Object.defineProperties(RS_getitem, {\n    __argnames__ : {value: ["obj", "key"]}\n});\n\nfunction RS_setitem(obj, key, val) {\n    if (obj.__setitem__) {\n        obj.__setitem__(key, val);\n    } else {\n        if (typeof key === "number" && key < 0) {\n            key += obj.length;\n        }\n        obj[(typeof key === "number" && key < 0) ? obj.length + key : key] = val;\n    }\n};\nif (!RS_setitem.__argnames__) Object.defineProperties(RS_setitem, {\n    __argnames__ : {value: ["obj", "key", "val"]}\n});\n\nfunction RS_delitem(obj, key) {\n    if (obj.__delitem__) {\n        obj.__delitem__(key);\n    } else if (typeof obj.splice === "function") {\n        obj.splice(key, 1);\n    } else {\n        if (typeof key === "number" && key < 0) {\n            key += obj.length;\n        }\n        delete obj[key];\n    }\n};\nif (!RS_delitem.__argnames__) Object.defineProperties(RS_delitem, {\n    __argnames__ : {value: ["obj", "key"]}\n});\n\nfunction RS_bound_index(idx, arr) {\n    if (typeof idx === "number" && idx < 0) {\n        idx += arr.length;\n    }\n    return idx;\n};\nif (!RS_bound_index.__argnames__) Object.defineProperties(RS_bound_index, {\n    __argnames__ : {value: ["idx", "arr"]}\n});\n\nfunction RS_splice(arr, val, start, end) {\n    start = start || 0;\n    if (start < 0) {\n        start += arr.length;\n    }\n    if (end === undefined) {\n        end = arr.length;\n    }\n    if (end < 0) {\n        end += arr.length;\n    }\n    Array.prototype.splice.apply(arr, [start, end - start].concat(val));\n};\nif (!RS_splice.__argnames__) Object.defineProperties(RS_splice, {\n    __argnames__ : {value: ["arr", "val", "start", "end"]}\n});\n\nRS_exists = (function(){\n    var RS_d = {};\n    RS_d["n"] = (function() {\n        var RS_anonfunc = function (expr) {\n            return expr !== undefined && expr !== null;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["d"] = (function() {\n        var RS_anonfunc = function (expr) {\n            if (expr === undefined || expr === null) {\n                return Object.create(null);\n            }\n            return expr;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["c"] = (function() {\n        var RS_anonfunc = function (expr) {\n            if (typeof expr === "function") {\n                return expr;\n            }\n            return function () {\n                return undefined;\n            };\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["g"] = (function() {\n        var RS_anonfunc = function (expr) {\n            if (expr === undefined || expr === null || typeof expr.__getitem__ !== "function") {\n                return (function(){\n                    var RS_d = {};\n                    RS_d["__getitem__"] = function () {\n                        return undefined;\n                    };\n                    return RS_d;\n                }).call(this);\n            }\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["e"] = (function() {\n        var RS_anonfunc = function (expr, alt) {\n            return (expr === undefined || expr === null) ? alt : expr;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr", "alt"]}\n        });\n        return RS_anonfunc;\n    })();\n    return RS_d;\n}).call(this);\nfunction RS_mixin() {\n    var seen, resolved_props, p, target, props, name;\n    seen = Object.create(null);\n    seen.__argnames__ = seen.__handles_kwarg_interpolation__ = seen.__init__ = seen.__annotations__ = seen.__doc__ = seen.__bind_methods__ = seen.__bases__ = seen.constructor = seen.__class__ = true;\n    resolved_props = {};\n    p = target = arguments[0].prototype;\n    while (p && p !== Object.prototype) {\n        props = Object.getOwnPropertyNames(p);\n        for (var i = 0; i < props.length; i++) {\n            seen[RS_bound_index(props[(typeof i === "number" && i < 0) ? props.length + i : i], seen)] = true;\n        }\n        p = Object.getPrototypeOf(p);\n    }\n    for (var c = 1; c < arguments.length; c++) {\n        p = arguments[(typeof c === "number" && c < 0) ? arguments.length + c : c].prototype;\n        while (p && p !== Object.prototype) {\n            props = Object.getOwnPropertyNames(p);\n            for (var i = 0; i < props.length; i++) {\n                name = props[(typeof i === "number" && i < 0) ? props.length + i : i];\n                if (seen[(typeof name === "number" && name < 0) ? seen.length + name : name]) {\n                    continue;\n                }\n                seen[(typeof name === "number" && name < 0) ? seen.length + name : name] = true;\n                resolved_props[(typeof name === "number" && name < 0) ? resolved_props.length + name : name] = Object.getOwnPropertyDescriptor(p, name);\n            }\n            p = Object.getPrototypeOf(p);\n        }\n    }\n    Object.defineProperties(target, resolved_props);\n};\n\nfunction RS_instanceof() {\n    var obj, bases, q, cls, p;\n    obj = arguments[0];\n    bases = "";\n    if (obj && obj.constructor && obj.constructor.prototype) {\n        bases = obj.constructor.prototype.__bases__ || "";\n    }\n    for (var i = 1; i < arguments.length; i++) {\n        q = arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i];\n        if (obj instanceof q) {\n            return true;\n        }\n        if ((q === Array || q === RS_list_constructor) && Array.isArray(obj)) {\n            return true;\n        }\n        if (q === RS_str && (typeof obj === "string" || obj instanceof String)) {\n            return true;\n        }\n        if (bases.length > 1) {\n            for (var c = 1; c < bases.length; c++) {\n                cls = bases[(typeof c === "number" && c < 0) ? bases.length + c : c];\n                while (cls) {\n                    if (q === cls) {\n                        return true;\n                    }\n                    p = Object.getPrototypeOf(cls.prototype);\n                    if (!p) {\n                        break;\n                    }\n                    cls = p.constructor;\n                }\n            }\n        }\n    }\n    return false;\n};\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce((function() {\n            var RS_anonfunc = function (prev, cur) {\n                return prev + cur;\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["prev", "cur"]}\n            });\n            return RS_anonfunc;\n        })(), start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n};\nif (!sum.__argnames__) Object.defineProperties(sum, {\n    __argnames__ : {value: ["iterable", "start"]}\n});\n\nfunction map() {\n    var iterators, func, args, ans;\n    iterators = new Array(arguments.length - 1);\n    func = arguments[0];\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[RS_bound_index(i - 1, iterators)] = iter(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {\'_func\':func, \'_iterators\':iterators, \'_args\':args};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    ans["next"] = function () {\n        var r;\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (RS_expr_temp = this._iterators)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {\'done\':true};\n            }\n            (RS_expr_temp = this._args)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] = r.value;\n        }\n        return {\'done\':false, \'value\':this._func.apply(undefined, this._args)};\n    };\n    return ans;\n};\n\nfunction filter(func_or_none, iterable) {\n    var func, ans;\n    func = (func_or_none === null) ? RS_bool : func_or_none;\n    ans = {\'_func\':func, \'_iterator\':RS_iter(iterable)};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    ans["next"] = function () {\n        var r;\n        r = this._iterator.next();\n        while (!r.done) {\n            if (this._func(r.value)) {\n                return r;\n            }\n            r = this._iterator.next();\n        }\n        return {\'done\':true};\n    };\n    return ans;\n};\nif (!filter.__argnames__) Object.defineProperties(filter, {\n    __argnames__ : {value: ["func_or_none", "iterable"]}\n});\n\nfunction zip() {\n    var iterators, ans;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[(typeof i === "number" && i < 0) ? iterators.length + i : i] = iter(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {\'_iterators\':iterators};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    ans["next"] = function () {\n        var args, r;\n        args = new Array(this._iterators.length);\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (RS_expr_temp = this._iterators)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {\'done\':true};\n            }\n            args[(typeof i === "number" && i < 0) ? args.length + i : i] = r.value;\n        }\n        return {\'done\':false, \'value\':args};\n    };\n    return ans;\n};\n\nfunction any(iterable) {\n    var i;\n    var RS_Iter0 = RS_Iterable(iterable);\n    for (var RS_Index0 = 0; RS_Index0 < RS_Iter0.length; RS_Index0++) {\n        i = RS_Iter0[RS_Index0];\n        if (i) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!any.__argnames__) Object.defineProperties(any, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction all(iterable) {\n    var i;\n    var RS_Iter1 = RS_Iterable(iterable);\n    for (var RS_Index1 = 0; RS_Index1 < RS_Iter1.length; RS_Index1++) {\n        i = RS_Iter1[RS_Index1];\n        if (!i) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!all.__argnames__) Object.defineProperties(all, {\n    __argnames__ : {value: ["iterable"]}\n});\nvar define_str_func, RS_unpack, RS_orig_split, RS_orig_replace;\nfunction RS_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = "{}";\n    if (as_array) {\n        b = "[]";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(RS_repr(x[(typeof i === "number" && i < 0) ? x.length + i : i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[(typeof k === "number" && k < 0) ? keys.length + k : k];\n            ans.push(JSON.stringify(key) + ":" + RS_repr(x[(typeof key === "number" && key < 0) ? x.length + key : key]));\n        }\n    }\n    return b[0] + ans.join(", ") + b[1];\n};\nif (!RS_repr_js_builtin.__argnames__) Object.defineProperties(RS_repr_js_builtin, {\n    __argnames__ : {value: ["x", "as_array"]}\n});\n\nfunction RS_html_element_to_string(elem) {\n    var attrs, val, attr, ans;\n    attrs = [];\n    var RS_Iter0 = RS_Iterable(elem.attributes);\n    for (var RS_Index0 = 0; RS_Index0 < RS_Iter0.length; RS_Index0++) {\n        attr = RS_Iter0[RS_Index0];\n        if (attr.specified) {\n            val = attr.value;\n            if (val.length > 10) {\n                val = val.slice(0, 15) + "...";\n            }\n            val = JSON.stringify(val);\n            attrs.push("" + RS_str.format("{}", attr.name) + "=" + RS_str.format("{}", val) + "");\n        }\n    }\n    attrs = (attrs.length) ? " " + attrs.join(" ") : "";\n    ans = "<" + RS_str.format("{}", elem.tagName) + "" + RS_str.format("{}", attrs) + ">";\n    return ans;\n};\nif (!RS_html_element_to_string.__argnames__) Object.defineProperties(RS_html_element_to_string, {\n    __argnames__ : {value: ["elem"]}\n});\n\nfunction RS_repr(x) {\n    var ans, name;\n    if (x === null) {\n        return "None";\n    }\n    if (x === undefined) {\n        return "undefined";\n    }\n    ans = x;\n    if (typeof x.__repr__ === "function") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? "True" : "False";\n    } else if (Array.isArray(x)) {\n        ans = RS_repr_js_builtin(x, true);\n    } else if (typeof x === "function") {\n        ans = x.toString();\n    } else if (typeof x === "object" && !x.toString) {\n        ans = RS_repr_js_builtin(x);\n    } else {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (RS_not_equals("Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".indexOf(name), -1)) {\n            return name + "([" + x.map((function() {\n                var RS_anonfunc = function (i) {\n                    return str.format("0x{:02x}", i);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["i"]}\n                });\n                return RS_anonfunc;\n            })()).join(", ") + "])";\n        }\n        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {\n            ans = RS_html_element_to_string(x);\n        } else {\n            ans = (typeof x.toString === "function") ? x.toString() : x;\n        }\n        if (ans === "[object Object]") {\n            return RS_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            {\n            } \n        }\n    }\n    return ans + "";\n};\nif (!RS_repr.__argnames__) Object.defineProperties(RS_repr, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_str(x) {\n    var ans, name;\n    if (x === null) {\n        return "None";\n    }\n    if (x === undefined) {\n        return "undefined";\n    }\n    ans = x;\n    if (typeof x.__str__ === "function") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === "function") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? "True" : "False";\n    } else if (Array.isArray(x)) {\n        ans = RS_repr_js_builtin(x, true);\n    } else if (typeof x.toString === "function") {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (RS_not_equals("Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".indexOf(name), -1)) {\n            return name + "([" + x.map((function() {\n                var RS_anonfunc = function (i) {\n                    return str.format("0x{:02x}", i);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["i"]}\n                });\n                return RS_anonfunc;\n            })()).join(", ") + "])";\n        }\n        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {\n            ans = RS_html_element_to_string(x);\n        } else {\n            ans = x.toString();\n        }\n        if (ans === "[object Object]") {\n            ans = RS_repr_js_builtin(x);\n        }\n    } else if (typeof x === "object" && !x.toString) {\n        ans = RS_repr_js_builtin(x);\n    }\n    return ans + "";\n};\nif (!RS_str.__argnames__) Object.defineProperties(RS_str, {\n    __argnames__ : {value: ["x"]}\n});\n\ndefine_str_func = (function() {\n    var RS_anonfunc = function (name, func) {\n        var f;\n        (RS_expr_temp = RS_str.prototype)[(typeof name === "number" && name < 0) ? RS_expr_temp.length + name : name] = func;\n        RS_str[(typeof name === "number" && name < 0) ? RS_str.length + name : name] = f = func.call.bind(func);\n        if (func.__argnames__) {\n            Object.defineProperty(f, "__argnames__", (function(){\n                var RS_d = {};\n                RS_d["value"] = [\'string\'].concat(func.__argnames__);\n                return RS_d;\n            }).call(this));\n        }\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["name", "func"]}\n    });\n    return RS_anonfunc;\n})();\nRS_unpack = [String.prototype.split.call.bind(String.prototype.split), String.prototype.replace.call.bind(String.prototype.replace)];\nRS_orig_split = RS_unpack[0];\nRS_orig_replace = RS_unpack[1];\ndefine_str_func("format", function () {\n    var template, args, kwargs, explicit, implicit, idx, split, ans, pos, in_brace, markup, ch;\n    template = this;\n    if (template === undefined) {\n        throw new TypeError("Template is required");\n    }\n    args = Array.prototype.slice.call(arguments);\n    kwargs = {};\n    if (args[args.length-1] && args[args.length-1][RS_kwargs_symbol] !== undefined) {\n        kwargs = args[args.length-1];\n        args = args.slice(0, -1);\n    }\n    explicit = implicit = false;\n    idx = 0;\n    split = RS_orig_split;\n    if (RS_str.format._template_resolve_pat === undefined) {\n        RS_str.format._template_resolve_pat = /[.\\[]/;\n    }\n    function resolve(arg, object) {\n        var RS_unpack, first, key, rest, ans;\n        if (!arg) {\n            return object;\n        }\n        RS_unpack = [arg[0], arg.slice(1)];\n        first = RS_unpack[0];\n        arg = RS_unpack[1];\n        key = split(arg, RS_str.format._template_resolve_pat, 1)[0];\n        rest = arg.slice(key.length);\n        ans = (first === "[") ? object[RS_bound_index(key.slice(0, -1), object)] : getattr(object, key);\n        if (ans === undefined) {\n            throw new KeyError((first === "[") ? key.slice(0, -1) : key);\n        }\n        return resolve(rest, ans);\n    };\n    if (!resolve.__argnames__) Object.defineProperties(resolve, {\n        __argnames__ : {value: ["arg", "object"]}\n    });\n\n    function resolve_format_spec(format_spec) {\n        if (RS_str.format._template_resolve_fs_pat === undefined) {\n            RS_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n        }\n        return format_spec.replace(RS_str.format._template_resolve_fs_pat, (function() {\n            var RS_anonfunc = function (match, key) {\n                if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                    return "";\n                }\n                return "" + kwargs[(typeof key === "number" && key < 0) ? kwargs.length + key : key];\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["match", "key"]}\n            });\n            return RS_anonfunc;\n        })());\n    };\n    if (!resolve_format_spec.__argnames__) Object.defineProperties(resolve_format_spec, {\n        __argnames__ : {value: ["format_spec"]}\n    });\n\n    function set_comma(ans, comma) {\n        var sep;\n        if (comma !== ",") {\n            sep = 1234;\n            sep = sep.toLocaleString(undefined, {useGrouping: true})[1];\n            ans = str.replace(ans, sep, comma);\n        }\n        return ans;\n    };\n    if (!set_comma.__argnames__) Object.defineProperties(set_comma, {\n        __argnames__ : {value: ["ans", "comma"]}\n    });\n\n    function safe_comma(value, comma) {\n        try {\n            return set_comma(value.toLocaleString(undefined, {useGrouping: true}), comma);\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            {\n                return value.toString(10);\n            } \n        }\n    };\n    if (!safe_comma.__argnames__) Object.defineProperties(safe_comma, {\n        __argnames__ : {value: ["value", "comma"]}\n    });\n\n    function safe_fixed(value, precision, comma) {\n        if (!comma) {\n            return value.toFixed(precision);\n        }\n        try {\n            return set_comma(value.toLocaleString(undefined, {useGrouping: true, minimumFractionDigits: precision, maximumFractionDigits: precision}), comma);\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            {\n                return value.toFixed(precision);\n            } \n        }\n    };\n    if (!safe_fixed.__argnames__) Object.defineProperties(safe_fixed, {\n        __argnames__ : {value: ["value", "precision", "comma"]}\n    });\n\n    function apply_formatting(value, format_spec) {\n        var RS_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, prec, exp, nval, is_positive, left, right;\n        if (format_spec.indexOf("{") !== -1) {\n            format_spec = resolve_format_spec(format_spec);\n        }\n        if (RS_str.format._template_format_pat === undefined) {\n            RS_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?([,_])?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n        }\n        try {\n            RS_unpack = format_spec.match(RS_str.format._template_format_pat).slice(1);\nRS_unpack = RS_unpack_asarray(9, RS_unpack);\n            fill = RS_unpack[0];\n            align = RS_unpack[1];\n            sign = RS_unpack[2];\n            fhash = RS_unpack[3];\n            zeropad = RS_unpack[4];\n            width = RS_unpack[5];\n            comma = RS_unpack[6];\n            precision = RS_unpack[7];\n            ftype = RS_unpack[8];\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            if (RS_Exception instanceof TypeError) {\n                return value;\n            } else {\n                throw RS_Exception;\n            }\n        }\n        if (zeropad) {\n            fill = fill || "0";\n            align = align || "=";\n        } else {\n            fill = fill || " ";\n            align = align || ">";\n        }\n        is_numeric = Number(value) === value;\n        is_int = is_numeric && value % 1 === 0;\n        precision = parseInt(precision, 10);\n        lftype = (ftype || "").toLowerCase();\n        if (ftype === "n") {\n            is_numeric = true;\n            if (is_int) {\n                if (comma) {\n                    throw new ValueError("Cannot specify \',\' with \'n\'");\n                }\n                value = parseInt(value, 10).toLocaleString();\n            } else {\n                value = parseFloat(value).toLocaleString();\n            }\n        } else if ([\'b\', \'c\', \'d\', \'o\', \'x\'].indexOf(lftype) !== -1) {\n            value = parseInt(value, 10);\n            is_numeric = true;\n            if (!isNaN(value)) {\n                if (ftype === "b") {\n                    value = (value >>> 0).toString(2);\n                    if (fhash) {\n                        value = "0b" + value;\n                    }\n                } else if (ftype === "c") {\n                    if (value > 65535) {\n                        code = value - 65536;\n                        value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    } else {\n                        value = String.fromCharCode(value);\n                    }\n                } else if (ftype === "d") {\n                    if (comma) {\n                        value = safe_comma(value, comma);\n                    } else {\n                        value = value.toString(10);\n                    }\n                } else if (ftype === "o") {\n                    value = value.toString(8);\n                    if (fhash) {\n                        value = "0o" + value;\n                    }\n                } else if (lftype === "x") {\n                    value = value.toString(16);\n                    value = (ftype === "x") ? value.toLowerCase() : value.toUpperCase();\n                    if (fhash) {\n                        value = "0x" + value;\n                    }\n                }\n            }\n        } else if ([\'e\',\'f\',\'g\',\'%\'].indexOf(lftype) !== -1) {\n            is_numeric = true;\n            value = parseFloat(value);\n            prec = (isNaN(precision)) ? 6 : precision;\n            if (lftype === "e") {\n                value = value.toExponential(prec);\n                value = (ftype === "E") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === "f") {\n                value = safe_fixed(value, prec, comma);\n                value = (ftype === "F") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === "%") {\n                value *= 100;\n                value = safe_fixed(value, prec, comma) + "%";\n            } else if (lftype === "g") {\n                prec = max(1, prec);\n                exp = parseInt(split(value.toExponential(prec - 1).toLowerCase(), "e")[1], 10);\n                if (-4 <= exp && exp < prec) {\n                    value = safe_fixed(value, prec - 1 - exp, comma);\n                } else {\n                    value = value.toExponential(prec - 1);\n                }\n                value = value.replace(/0+$/g, "");\n                if (value[value.length-1] === ".") {\n                    value = value.slice(0, -1);\n                }\n                if (ftype === "G") {\n                    value = value.toUpperCase();\n                }\n            }\n        } else {\n            if (comma) {\n                value = parseInt(value, 10);\n                if (isNaN(value)) {\n                    throw new ValueError("Must use numbers with , or _");\n                }\n                value = safe_comma(value, comma);\n            }\n            value += "";\n            if (!isNaN(precision)) {\n                value = value.slice(0, precision);\n            }\n        }\n        value += "";\n        if (is_numeric && sign) {\n            nval = Number(value);\n            is_positive = !isNaN(nval) && nval >= 0;\n            if (is_positive && (sign === " " || sign === "+")) {\n                value = sign + value;\n            }\n        }\n        function repeat(char, num) {\n            return (new Array(num+1)).join(char);\n        };\n        if (!repeat.__argnames__) Object.defineProperties(repeat, {\n            __argnames__ : {value: ["char", "num"]}\n        });\n\n        if (is_numeric && width && width[0] === "0") {\n            width = width.slice(1);\n            RS_unpack = ["0", "="];\n            fill = RS_unpack[0];\n            align = RS_unpack[1];\n        }\n        width = parseInt(width || "-1", 10);\n        if (isNaN(width)) {\n            throw new ValueError("Invalid width specification: " + width);\n        }\n        if (fill && value.length < width) {\n            if (align === "<") {\n                value = value + repeat(fill, width - value.length);\n            } else if (align === ">") {\n                value = repeat(fill, width - value.length) + value;\n            } else if (align === "^") {\n                left = Math.floor((width - value.length) / 2);\n                right = width - left - value.length;\n                value = repeat(fill, left) + value + repeat(fill, right);\n            } else if (align === "=") {\n                if (RS_in(value[0], "+- ")) {\n                    value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                } else {\n                    value = repeat(fill, width - value.length) + value;\n                }\n            } else {\n                throw new ValueError("Unrecognized alignment: " + align);\n            }\n        }\n        return value;\n    };\n    if (!apply_formatting.__argnames__) Object.defineProperties(apply_formatting, {\n        __argnames__ : {value: ["value", "format_spec"]}\n    });\n\n    function parse_markup(markup) {\n        var key, transformer, format_spec, pos, state, ch;\n        key = transformer = format_spec = "";\n        pos = 0;\n        state = 0;\n        while (pos < markup.length) {\n            ch = markup[(typeof pos === "number" && pos < 0) ? markup.length + pos : pos];\n            if (state === 0) {\n                if (ch === "!") {\n                    state = 1;\n                } else if (ch === ":") {\n                    state = 2;\n                } else {\n                    key += ch;\n                }\n            } else if (state === 1) {\n                if (ch === ":") {\n                    state = 2;\n                } else {\n                    transformer += ch;\n                }\n            } else {\n                format_spec += ch;\n            }\n            pos += 1;\n        }\n        return [key, transformer, format_spec];\n    };\n    if (!parse_markup.__argnames__) Object.defineProperties(parse_markup, {\n        __argnames__ : {value: ["markup"]}\n    });\n\n    function render_markup(markup) {\n        var RS_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n        RS_unpack = parse_markup(markup);\nRS_unpack = RS_unpack_asarray(3, RS_unpack);\n        key = RS_unpack[0];\n        transformer = RS_unpack[1];\n        format_spec = RS_unpack[2];\n        if (transformer && [\'a\', \'r\', \'s\'].indexOf(transformer) === -1) {\n            throw new ValueError("Unknown conversion specifier: " + transformer);\n        }\n        lkey = key.length && split(key, /[.\\[]/, 1)[0];\n        if (lkey) {\n            explicit = true;\n            if (implicit) {\n                throw new ValueError("cannot switch from automatic field numbering to manual field specification");\n            }\n            nvalue = parseInt(lkey);\n            object = (isNaN(nvalue)) ? kwargs[(typeof lkey === "number" && lkey < 0) ? kwargs.length + lkey : lkey] : args[(typeof nvalue === "number" && nvalue < 0) ? args.length + nvalue : nvalue];\n            if (object === undefined) {\n                if (isNaN(nvalue)) {\n                    throw new KeyError(lkey);\n                }\n                throw new IndexError(lkey);\n            }\n            object = resolve(key.slice(lkey.length), object);\n        } else {\n            implicit = true;\n            if (explicit) {\n                throw new ValueError("cannot switch from manual field specification to automatic field numbering");\n            }\n            if (idx >= args.length) {\n                throw new IndexError("Not enough arguments to match template: " + template);\n            }\n            object = args[(typeof idx === "number" && idx < 0) ? args.length + idx : idx];\n            idx += 1;\n        }\n        if (typeof object === "function") {\n            object = object();\n        }\n        ans = "" + object;\n        if (format_spec) {\n            ans = apply_formatting(ans, format_spec);\n        }\n        return ans;\n    };\n    if (!render_markup.__argnames__) Object.defineProperties(render_markup, {\n        __argnames__ : {value: ["markup"]}\n    });\n\n    ans = "";\n    pos = 0;\n    in_brace = 0;\n    markup = "";\n    while (pos < template.length) {\n        ch = template[(typeof pos === "number" && pos < 0) ? template.length + pos : pos];\n        if (in_brace) {\n            if (ch === "{") {\n                in_brace += 1;\n                markup += "{";\n            } else if (ch === "}") {\n                in_brace -= 1;\n                if (in_brace > 0) {\n                    markup += "}";\n                } else {\n                    ans += render_markup(markup);\n                }\n            } else {\n                markup += ch;\n            }\n        } else {\n            if (ch === "{") {\n                if (template[RS_bound_index(pos + 1, template)] === "{") {\n                    pos += 1;\n                    ans += "{";\n                } else {\n                    in_brace = 1;\n                    markup = "";\n                }\n            } else {\n                ans += ch;\n                if (ch === "}" && template[RS_bound_index(pos + 1, template)] === "}") {\n                    pos += 1;\n                }\n            }\n        }\n        pos += 1;\n    }\n    if (in_brace) {\n        throw new ValueError("expected \'}\' before end of string");\n    }\n    return ans;\n});\ndefine_str_func("capitalize", function () {\n    var string;\n    string = this;\n    if (string) {\n        string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n    }\n    return string;\n});\ndefine_str_func("center", (function() {\n    var RS_anonfunc = function (width, fill) {\n        var left, right;\n        left = Math.floor((width - this.length) / 2);\n        right = width - left - this.length;\n        fill = fill || " ";\n        return new Array(left+1).join(fill) + this + new Array(right+1).join(fill);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width", "fill"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("count", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var string, RS_unpack, pos, step, ans;\n        string = this;\n        start = start || 0;\n        end = end || string.length;\n        if (start < 0 || end < 0) {\n            string = string.slice(start, end);\n            RS_unpack = [0, string.length];\n            start = RS_unpack[0];\n            end = RS_unpack[1];\n        }\n        pos = start;\n        step = needle.length;\n        if (!step) {\n            return 0;\n        }\n        ans = 0;\n        while (pos !== -1) {\n            pos = string.indexOf(needle, pos);\n            if (pos !== -1) {\n                ans += 1;\n                pos += step;\n            }\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("endswith", (function() {\n    var RS_anonfunc = function (suffixes, start, end) {\n        var string, q;\n        string = this;\n        start = start || 0;\n        if (typeof suffixes === "string") {\n            suffixes = [suffixes];\n        }\n        if (end !== undefined) {\n            string = string.slice(0, end);\n        }\n        for (var i = 0; i < suffixes.length; i++) {\n            q = suffixes[(typeof i === "number" && i < 0) ? suffixes.length + i : i];\n            if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["suffixes", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("startswith", (function() {\n    var RS_anonfunc = function (prefixes, start, end) {\n        var prefix;\n        start = start || 0;\n        if (typeof prefixes === "string") {\n            prefixes = [prefixes];\n        }\n        for (var i = 0; i < prefixes.length; i++) {\n            prefix = prefixes[(typeof i === "number" && i < 0) ? prefixes.length + i : i];\n            end = (end === undefined) ? this.length : end;\n            if (end - start >= prefix.length && prefix === this.slice(start, start + prefix.length)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["prefixes", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("find", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        while (start < 0) {\n            start += this.length;\n        }\n        ans = this.indexOf(needle, start);\n        if (end !== undefined && ans !== -1) {\n            while (end < 0) {\n                end += this.length;\n            }\n            if (ans >= end - needle.length) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rfind", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        while (end < 0) {\n            end += this.length;\n        }\n        ans = this.lastIndexOf(needle, end - 1);\n        if (start !== undefined && ans !== -1) {\n            while (start < 0) {\n                start += this.length;\n            }\n            if (ans < start) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("index", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = RS_str.prototype.find.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError("substring not found");\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rindex", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = RS_str.prototype.rfind.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError("substring not found");\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("islower", function () {\n    return this.length > 0 && this.toLowerCase() === this.toString();\n});\ndefine_str_func("isupper", function () {\n    return this.length > 0 && this.toUpperCase() === this.toString();\n});\ndefine_str_func("isspace", function () {\n    return this.length > 0 && /^\\s+$/.test(this);\n});\ndefine_str_func("join", (function() {\n    var RS_anonfunc = function (iterable) {\n        var ans, r;\n        if (Array.isArray(iterable)) {\n            return iterable.join(this);\n        }\n        ans = "";\n        r = iterable.next();\n        while (!r.done) {\n            if (ans) {\n                ans += this;\n            }\n            ans += r.value;\n            r = iterable.next();\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["iterable"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("ljust", (function() {\n    var RS_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || " ";\n            string += new Array(width - string.length + 1).join(fill);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width", "fill"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rjust", (function() {\n    var RS_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || " ";\n            string = new Array(width - string.length + 1).join(fill) + string;\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width", "fill"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("lower", function () {\n    return this.toLowerCase();\n});\ndefine_str_func("upper", function () {\n    return this.toUpperCase();\n});\ndefine_str_func("lstrip", (function() {\n    var RS_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = 0;\n        chars = chars || RS_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === "number" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos += 1;\n        }\n        if (pos) {\n            string = string.slice(pos);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["chars"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rstrip", (function() {\n    var RS_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = string.length - 1;\n        chars = chars || RS_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === "number" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos -= 1;\n        }\n        if (pos < string.length - 1) {\n            string = string.slice(0, pos + 1);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["chars"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("strip", (function() {\n    var RS_anonfunc = function (chars) {\n        return RS_str.prototype.lstrip.call(RS_str.prototype.rstrip.call(this, chars), chars);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["chars"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("partition", (function() {\n    var RS_anonfunc = function (sep) {\n        var idx;\n        idx = this.indexOf(sep);\n        if (idx === -1) {\n            return [this, "", ""];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rpartition", (function() {\n    var RS_anonfunc = function (sep) {\n        var idx;\n        idx = this.lastIndexOf(sep);\n        if (idx === -1) {\n            return ["", "", this];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("replace", (function() {\n    var RS_anonfunc = function (old, repl, count) {\n        var string, pos, idx;\n        string = this;\n        if (count === 1) {\n            return RS_orig_replace(string, old, repl);\n        }\n        if (count < 1) {\n            return string;\n        }\n        count = count || Number.MAX_VALUE;\n        pos = 0;\n        while (count > 0) {\n            count -= 1;\n            idx = string.indexOf(old, pos);\n            if (idx === -1) {\n                break;\n            }\n            pos = idx + repl.length;\n            string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["old", "repl", "count"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("split", (function() {\n    var RS_anonfunc = function (sep, maxsplit) {\n        var split, ans, extra, parts;\n        if (maxsplit === 0) {\n            return RS_list_decorate([ this ]);\n        }\n        split = RS_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = split(this, /(\\s+)/);\n                extra = "";\n                parts = [];\n                for (var i = 0; i < ans.length; i++) {\n                    if (parts.length >= maxsplit + 1) {\n                        extra += ans[(typeof i === "number" && i < 0) ? ans.length + i : i];\n                    } else if (i % 2 === 0) {\n                        parts.push(ans[(typeof i === "number" && i < 0) ? ans.length + i : i]);\n                    }\n                }\n                parts[parts.length-1] += extra;\n                ans = parts;\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === "") {\n                throw new ValueError("empty separator");\n            }\n            ans = split(this, sep);\n            if (maxsplit > 0 && ans.length > maxsplit) {\n                extra = ans.slice(maxsplit).join(sep);\n                ans = ans.slice(0, maxsplit);\n                ans.push(extra);\n            }\n        }\n        return RS_list_decorate(ans);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep", "maxsplit"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rsplit", (function() {\n    var RS_anonfunc = function (sep, maxsplit) {\n        var split, ans, is_space, pos, current, spc, ch, end, idx;\n        if (!maxsplit) {\n            return RS_str.prototype.split.call(this, sep);\n        }\n        split = RS_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = [];\n                is_space = /\\s/;\n                pos = this.length - 1;\n                current = "";\n                while (pos > -1 && maxsplit > 0) {\n                    spc = false;\n                    ch = (RS_expr_temp = this)[(typeof pos === "number" && pos < 0) ? RS_expr_temp.length + pos : pos];\n                    while (pos > -1 && is_space.test(ch)) {\n                        spc = true;\n                        ch = this[--pos];\n                    }\n                    if (spc) {\n                        if (current) {\n                            ans.push(current);\n                            maxsplit -= 1;\n                        }\n                        current = ch;\n                    } else {\n                        current += ch;\n                    }\n                    pos -= 1;\n                }\n                ans.push(this.slice(0, pos + 1) + current);\n                ans.reverse();\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === "") {\n                throw new ValueError("empty separator");\n            }\n            ans = [];\n            pos = end = this.length;\n            while (pos > -1 && maxsplit > 0) {\n                maxsplit -= 1;\n                idx = this.lastIndexOf(sep, pos);\n                if (idx === -1) {\n                    break;\n                }\n                ans.push(this.slice(idx + sep.length, end));\n                pos = idx - 1;\n                end = idx;\n            }\n            ans.push(this.slice(0, end));\n            ans.reverse();\n        }\n        return RS_list_decorate(ans);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep", "maxsplit"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("splitlines", (function() {\n    var RS_anonfunc = function (keepends) {\n        var split, parts, ans;\n        split = RS_orig_split;\n        if (keepends) {\n            parts = split(this, /((?:\\r?\\n)|\\r)/);\n            ans = [];\n            for (var i = 0; i < parts.length; i++) {\n                if (i % 2 === 0) {\n                    ans.push(parts[(typeof i === "number" && i < 0) ? parts.length + i : i]);\n                } else {\n                    ans[ans.length-1] += parts[(typeof i === "number" && i < 0) ? parts.length + i : i];\n                }\n            }\n        } else {\n            ans = split(this, /(?:\\r?\\n)|\\r/);\n        }\n        return RS_list_decorate(ans);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["keepends"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("swapcase", function () {\n    var ans, a, b;\n    ans = new Array(this.length);\n    for (var i = 0; i < ans.length; i++) {\n        a = (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n        b = a.toLowerCase();\n        if (a === b) {\n            b = a.toUpperCase();\n        }\n        ans[(typeof i === "number" && i < 0) ? ans.length + i : i] = b;\n    }\n    return ans.join("");\n});\ndefine_str_func("zfill", (function() {\n    var RS_anonfunc = function (width) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            string = new Array(width - string.length + 1).join("0") + string;\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width"]}\n    });\n    return RS_anonfunc;\n})());\nRS_str.uchrs = (function() {\n    var RS_anonfunc = function (string, with_positions) {\n        return (function(){\n            var RS_d = {};\n            RS_d["_string"] = string;\n            RS_d["_pos"] = 0;\n            RS_d[RS_iterator_symbol] = function () {\n                return this;\n            };\n            RS_d["next"] = function () {\n                var length, pos, value, ans, extra;\n                length = this._string.length;\n                if (this._pos >= length) {\n                    return (function(){\n                        var RS_d = {};\n                        RS_d["done"] = true;\n                        return RS_d;\n                    }).call(this);\n                }\n                pos = this._pos;\n                value = this._string.charCodeAt(this._pos++);\n                ans = "\\ufffd";\n                if (55296 <= value && value <= 56319) {\n                    if (this._pos < length) {\n                        extra = this._string.charCodeAt(this._pos++);\n                        if ((extra & 56320) === 56320) {\n                            ans = String.fromCharCode(value, extra);\n                        }\n                    }\n                } else if ((value & 56320) !== 56320) {\n                    ans = String.fromCharCode(value);\n                }\n                if (with_positions) {\n                    return (function(){\n                        var RS_d = {};\n                        RS_d["done"] = false;\n                        RS_d["value"] = RS_list_decorate([ pos, ans ]);\n                        return RS_d;\n                    }).call(this);\n                } else {\n                    return (function(){\n                        var RS_d = {};\n                        RS_d["done"] = false;\n                        RS_d["value"] = ans;\n                        return RS_d;\n                    }).call(this);\n                }\n            };\n            return RS_d;\n        }).call(this);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["string", "with_positions"]}\n    });\n    return RS_anonfunc;\n})();\nRS_str.uslice = (function() {\n    var RS_anonfunc = function (string, start, end) {\n        var items, iterator, r;\n        items = [];\n        iterator = RS_str.uchrs(string);\n        r = iterator.next();\n        while (!r.done) {\n            items.push(r.value);\n            r = iterator.next();\n        }\n        return items.slice(start || 0, (end === undefined) ? items.length : end).join("");\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["string", "start", "end"]}\n    });\n    return RS_anonfunc;\n})();\nRS_str.ulen = (function() {\n    var RS_anonfunc = function (string) {\n        var iterator, r, ans;\n        iterator = RS_str.uchrs(string);\n        r = iterator.next();\n        ans = 0;\n        while (!r.done) {\n            r = iterator.next();\n            ans += 1;\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["string"]}\n    });\n    return RS_anonfunc;\n})();\nRS_str.ascii_lowercase = "abcdefghijklmnopqrstuvwxyz";\nRS_str.ascii_uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";\nRS_str.ascii_letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";\nRS_str.digits = "0123456789";\nRS_str.punctuation = "!\\"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~";\nRS_str.printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f";\nRS_str.whitespace = " \\t\\n\\r\\u000b\\f";\ndefine_str_func = undefined;\nvar str = RS_str, repr = RS_repr;;\n    var RS_modules = {};\n    RS_modules.utils = {};\n    RS_modules.errors = {};\n    RS_modules.unicode_aliases = {};\n    RS_modules.ast = {};\n    RS_modules.string_interpolation = {};\n    RS_modules.tokenizer = {};\n    RS_modules.parse = {};\n    RS_modules.output = {};\n    RS_modules["output.stream"] = {};\n    RS_modules["output.statements"] = {};\n    RS_modules["output.exceptions"] = {};\n    RS_modules["output.utils"] = {};\n    RS_modules["output.loops"] = {};\n    RS_modules["output.operators"] = {};\n    RS_modules["output.functions"] = {};\n    RS_modules["output.classes"] = {};\n    RS_modules["output.literals"] = {};\n    RS_modules["output.modules"] = {};\n    RS_modules["output.codegen"] = {};\n\n    (function(){\n        var __name__ = "utils";\n        var has_prop, MAP;\n        has_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n        function array_to_hash(a) {\n            var ret, i;\n            ret = Object.create(null);\n            var RS_Iter0 = RS_Iterable(range(len(a)));\n            for (var RS_Index0 = 0; RS_Index0 < RS_Iter0.length; RS_Index0++) {\n                i = RS_Iter0[RS_Index0];\n                ret[RS_bound_index(a[(typeof i === "number" && i < 0) ? a.length + i : i], ret)] = true;\n            }\n            return ret;\n        };\n        if (!array_to_hash.__argnames__) Object.defineProperties(array_to_hash, {\n            __argnames__ : {value: ["a"]}\n        });\n\n        function slice(a, start) {\n            return Array.prototype.slice.call(a, start || 0);\n        };\n        if (!slice.__argnames__) Object.defineProperties(slice, {\n            __argnames__ : {value: ["a", "start"]}\n        });\n\n        function characters(str_) {\n            return str_.split("");\n        };\n        if (!characters.__argnames__) Object.defineProperties(characters, {\n            __argnames__ : {value: ["str_"]}\n        });\n\n        function member(name, array) {\n            var i;\n            for (var RS_Index1 = array.length - 1; RS_Index1 > -1; RS_Index1-=1) {\n                i = RS_Index1;\n                if (array[(typeof i === "number" && i < 0) ? array.length + i : i] === name) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (!member.__argnames__) Object.defineProperties(member, {\n            __argnames__ : {value: ["name", "array"]}\n        });\n\n        function repeat_string(str_, i) {\n            var d;\n            if (i <= 0) {\n                return "";\n            }\n            if (i === 1) {\n                return str_;\n            }\n            d = repeat_string(str_, i >> 1);\n            d += d;\n            if (i & 1) {\n                d += str_;\n            }\n            return d;\n        };\n        if (!repeat_string.__argnames__) Object.defineProperties(repeat_string, {\n            __argnames__ : {value: ["str_", "i"]}\n        });\n\n        function DefaultsError() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            DefaultsError.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(DefaultsError, ValueError);\n        DefaultsError.prototype.__init__ = function __init__(name, defs) {\n            var self = this;\n            ValueError.prototype.__init__.call(self, name + " is not a supported option. Supported options are: " + str(Object.keys(defs)));\n        };\n        if (!DefaultsError.prototype.__init__.__argnames__) Object.defineProperties(DefaultsError.prototype.__init__, {\n            __argnames__ : {value: ["name", "defs"]}\n        });\n        DefaultsError.__argnames__ = DefaultsError.prototype.__init__.__argnames__;\n        DefaultsError.__handles_kwarg_interpolation__ = DefaultsError.prototype.__init__.__handles_kwarg_interpolation__;\n        DefaultsError.prototype.__repr__ = function __repr__ () {\n            if(ValueError.prototype.__repr__) return ValueError.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        DefaultsError.prototype.__str__ = function __str__ () {\n            if(ValueError.prototype.__str__) return ValueError.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(DefaultsError.prototype, "__bases__", {value: [ValueError]});\n\n        function defaults(args, defs, croak) {\n            var ret, i;\n            if (args === true) {\n                args = Object.create(null);\n            }\n            ret = args || Object.create(null);\n            if (croak) {\n                var RS_Iter2 = RS_Iterable(ret);\n                for (var RS_Index2 = 0; RS_Index2 < RS_Iter2.length; RS_Index2++) {\n                    i = RS_Iter2[RS_Index2];\n                    if (!has_prop(defs, i)) {\n                        throw new DefaultsError(i, defs);\n                    }\n                }\n            }\n            var RS_Iter3 = RS_Iterable(defs);\n            for (var RS_Index3 = 0; RS_Index3 < RS_Iter3.length; RS_Index3++) {\n                i = RS_Iter3[RS_Index3];\n                ret[(typeof i === "number" && i < 0) ? ret.length + i : i] = (args && has_prop(args, i)) ? args[(typeof i === "number" && i < 0) ? args.length + i : i] : defs[(typeof i === "number" && i < 0) ? defs.length + i : i];\n            }\n            return ret;\n        };\n        if (!defaults.__argnames__) Object.defineProperties(defaults, {\n            __argnames__ : {value: ["args", "defs", "croak"]}\n        });\n\n        function merge(obj, ext) {\n            var i;\n            var RS_Iter4 = RS_Iterable(ext);\n            for (var RS_Index4 = 0; RS_Index4 < RS_Iter4.length; RS_Index4++) {\n                i = RS_Iter4[RS_Index4];\n                obj[(typeof i === "number" && i < 0) ? obj.length + i : i] = ext[(typeof i === "number" && i < 0) ? ext.length + i : i];\n            }\n            return obj;\n        };\n        if (!merge.__argnames__) Object.defineProperties(merge, {\n            __argnames__ : {value: ["obj", "ext"]}\n        });\n\n        function noop() {\n        };\n\n        MAP = function () {\n            var skip;\n            function MAP(a, f, backwards) {\n                var ret, top, i;\n                ret = RS_list_decorate([]);\n                top = RS_list_decorate([]);\n                function doit() {\n                    var val, is_last;\n                    val = f(a[(typeof i === "number" && i < 0) ? a.length + i : i], i);\n                    is_last = RS_instanceof(val, Last);\n                    if (is_last) {\n                        val = val.v;\n                    }\n                    if (RS_instanceof(val, AtTop)) {\n                        val = val.v;\n                        if (RS_instanceof(val, Splice)) {\n                            top.push.apply(top, (backwards) ? val.v.slice().reverse() : val.v);\n                        } else {\n                            top.push(val);\n                        }\n                    } else if (val !== skip) {\n                        if (RS_instanceof(val, Splice)) {\n                            ret.push.apply(ret, (backwards) ? val.v.slice().reverse() : val.v);\n                        } else {\n                            ret.push(val);\n                        }\n                    }\n                    return is_last;\n                };\n\n                if (Array.isArray(a)) {\n                    if (backwards) {\n                        for (var RS_Index5 = a.length - 1; RS_Index5 > -1; RS_Index5-=1) {\n                            i = RS_Index5;\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                        ret.reverse();\n                        top.reverse();\n                    } else {\n                        var RS_Iter6 = RS_Iterable(range(len(a)));\n                        for (var RS_Index6 = 0; RS_Index6 < RS_Iter6.length; RS_Index6++) {\n                            i = RS_Iter6[RS_Index6];\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    var RS_Iter7 = RS_Iterable(a);\n                    for (var RS_Index7 = 0; RS_Index7 < RS_Iter7.length; RS_Index7++) {\n                        i = RS_Iter7[RS_Index7];\n                        if (doit()) {\n                            break;\n                        }\n                    }\n                }\n                return top.concat(ret);\n            };\n            if (!MAP.__argnames__) Object.defineProperties(MAP, {\n                __argnames__ : {value: ["a", "f", "backwards"]}\n            });\n\n            MAP.at_top = (function() {\n                var RS_anonfunc = function (val) {\n                    return new AtTop(val);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["val"]}\n                });\n                return RS_anonfunc;\n            })();\n            MAP.splice = (function() {\n                var RS_anonfunc = function (val) {\n                    return new Splice(val);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["val"]}\n                });\n                return RS_anonfunc;\n            })();\n            MAP.last = (function() {\n                var RS_anonfunc = function (val) {\n                    return new Last(val);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["val"]}\n                });\n                return RS_anonfunc;\n            })();\n            skip = MAP.skip = Object.create(null);\n            function AtTop(val) {\n                this.v = val;\n            };\n            if (!AtTop.__argnames__) Object.defineProperties(AtTop, {\n                __argnames__ : {value: ["val"]}\n            });\n\n            function Splice(val) {\n                this.v = val;\n            };\n            if (!Splice.__argnames__) Object.defineProperties(Splice, {\n                __argnames__ : {value: ["val"]}\n            });\n\n            function Last(val) {\n                this.v = val;\n            };\n            if (!Last.__argnames__) Object.defineProperties(Last, {\n                __argnames__ : {value: ["val"]}\n            });\n\n            return MAP;\n        }.call(this);\n        function push_uniq(array, el) {\n            if (array.indexOf(el) < 0) {\n                array.push(el);\n            }\n        };\n        if (!push_uniq.__argnames__) Object.defineProperties(push_uniq, {\n            __argnames__ : {value: ["array", "el"]}\n        });\n\n        function string_template(text, props) {\n            return text.replace(/\\{(.+?)\\}/g, (function() {\n                var RS_anonfunc = function (str_, p) {\n                    return props[(typeof p === "number" && p < 0) ? props.length + p : p];\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["str_", "p"]}\n                });\n                return RS_anonfunc;\n            })());\n        };\n        if (!string_template.__argnames__) Object.defineProperties(string_template, {\n            __argnames__ : {value: ["text", "props"]}\n        });\n\n        function remove(array, el) {\n            var i;\n            for (var RS_Index8 = array.length - 1; RS_Index8 > -1; RS_Index8-=1) {\n                i = RS_Index8;\n                if (array[(typeof i === "number" && i < 0) ? array.length + i : i] === el) {\n                    array.splice(i, 1);\n                }\n            }\n        };\n        if (!remove.__argnames__) Object.defineProperties(remove, {\n            __argnames__ : {value: ["array", "el"]}\n        });\n\n        function mergeSort(array, cmp) {\n            if (array.length < 2) {\n                return array.slice();\n            }\n            function merge(a, b) {\n                var r, ai, bi, i;\n                r = RS_list_decorate([]);\n                ai = 0;\n                bi = 0;\n                i = 0;\n                while (ai < a.length && bi < b.length) {\n                    if (cmp(a[(typeof ai === "number" && ai < 0) ? a.length + ai : ai], b[(typeof bi === "number" && bi < 0) ? b.length + bi : bi]) <= 0) {\n                        r[(typeof i === "number" && i < 0) ? r.length + i : i] = a[(typeof ai === "number" && ai < 0) ? a.length + ai : ai];\n                        ai += 1;\n                    } else {\n                        r[(typeof i === "number" && i < 0) ? r.length + i : i] = b[(typeof bi === "number" && bi < 0) ? b.length + bi : bi];\n                        bi += 1;\n                    }\n                    i += 1;\n                }\n                if (ai < a.length) {\n                    r.push.apply(r, a.slice(ai));\n                }\n                if (bi < b.length) {\n                    r.push.apply(r, b.slice(bi));\n                }\n                return r;\n            };\n            if (!merge.__argnames__) Object.defineProperties(merge, {\n                __argnames__ : {value: ["a", "b"]}\n            });\n\n            function _ms(a) {\n                var m, left, right;\n                if (a.length <= 1) {\n                    return a;\n                }\n                m = Math.floor(a.length / 2);\n                left = a.slice(0, m);\n                right = a.slice(m);\n                left = _ms(left);\n                right = _ms(right);\n                return merge(left, right);\n            };\n            if (!_ms.__argnames__) Object.defineProperties(_ms, {\n                __argnames__ : {value: ["a"]}\n            });\n\n            return _ms(array);\n        };\n        if (!mergeSort.__argnames__) Object.defineProperties(mergeSort, {\n            __argnames__ : {value: ["array", "cmp"]}\n        });\n\n        function set_difference(a, b) {\n            return a.filter((function() {\n                var RS_anonfunc = function (el) {\n                    return b.indexOf(el) < 0;\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["el"]}\n                });\n                return RS_anonfunc;\n            })());\n        };\n        if (!set_difference.__argnames__) Object.defineProperties(set_difference, {\n            __argnames__ : {value: ["a", "b"]}\n        });\n\n        function set_intersection(a, b) {\n            return a.filter((function() {\n                var RS_anonfunc = function (el) {\n                    return b.indexOf(el) >= 0;\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["el"]}\n                });\n                return RS_anonfunc;\n            })());\n        };\n        if (!set_intersection.__argnames__) Object.defineProperties(set_intersection, {\n            __argnames__ : {value: ["a", "b"]}\n        });\n\n        function make_predicate(words) {\n            var a, k;\n            if (typeof words === "string") {\n                words = words.split(" ");\n            }\n            a = Object.create(null);\n            var RS_Iter9 = RS_Iterable(words);\n            for (var RS_Index9 = 0; RS_Index9 < RS_Iter9.length; RS_Index9++) {\n                k = RS_Iter9[RS_Index9];\n                a[(typeof k === "number" && k < 0) ? a.length + k : k] = true;\n            }\n            return a;\n        };\n        if (!make_predicate.__argnames__) Object.defineProperties(make_predicate, {\n            __argnames__ : {value: ["words"]}\n        });\n\n        function cache_file_name(src, cache_dir) {\n            if (cache_dir) {\n                src = str.replace(src, "\\\\", "/");\n                return cache_dir + "/" + str.lstrip(str.replace(src, "/", "-") + ".json", "-");\n            }\n            return src + "-cached";\n        };\n        if (!cache_file_name.__argnames__) Object.defineProperties(cache_file_name, {\n            __argnames__ : {value: ["src", "cache_dir"]}\n        });\n\n        RS_modules.utils.has_prop = has_prop;\n        RS_modules.utils.MAP = MAP;\n        RS_modules.utils.array_to_hash = array_to_hash;\n        RS_modules.utils.slice = slice;\n        RS_modules.utils.characters = characters;\n        RS_modules.utils.member = member;\n        RS_modules.utils.repeat_string = repeat_string;\n        RS_modules.utils.DefaultsError = DefaultsError;\n        RS_modules.utils.defaults = defaults;\n        RS_modules.utils.merge = merge;\n        RS_modules.utils.noop = noop;\n        RS_modules.utils.push_uniq = push_uniq;\n        RS_modules.utils.string_template = string_template;\n        RS_modules.utils.remove = remove;\n        RS_modules.utils.mergeSort = mergeSort;\n        RS_modules.utils.set_difference = set_difference;\n        RS_modules.utils.set_intersection = set_intersection;\n        RS_modules.utils.make_predicate = make_predicate;\n        RS_modules.utils.cache_file_name = cache_file_name;\n    })();\n\n    (function(){\n        var __name__ = "errors";\n        function SyntaxError() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            SyntaxError.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(SyntaxError, Error);\n        SyntaxError.prototype.__init__ = function __init__(message, filename, line, col, pos, is_eof) {\n            var self = this;\n            self.stack = (new Error).stack;\n            self.message = message;\n            self.line = line;\n            self.col = col;\n            self.pos = pos;\n            self.is_eof = is_eof;\n            self.filename = filename;\n            self.lineNumber = line;\n            self.fileName = filename;\n        };\n        if (!SyntaxError.prototype.__init__.__argnames__) Object.defineProperties(SyntaxError.prototype.__init__, {\n            __argnames__ : {value: ["message", "filename", "line", "col", "pos", "is_eof"]}\n        });\n        SyntaxError.__argnames__ = SyntaxError.prototype.__init__.__argnames__;\n        SyntaxError.__handles_kwarg_interpolation__ = SyntaxError.prototype.__init__.__handles_kwarg_interpolation__;\n        SyntaxError.prototype.toString = function toString() {\n            var self = this;\n            var ans;\n            ans = self.message + " (line: " + self.line + ", col: " + self.col + ", pos: " + self.pos + ")";\n            if (self.filename) {\n                ans = self.filename + ":" + ans;\n            }\n            if (self.stack) {\n                ans += "\\n\\n" + self.stack;\n            }\n            return ans;\n        };\n        SyntaxError.prototype.__repr__ = function __repr__ () {\n            if(Error.prototype.__repr__) return Error.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        SyntaxError.prototype.__str__ = function __str__ () {\n            if(Error.prototype.__str__) return Error.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(SyntaxError.prototype, "__bases__", {value: [Error]});\n\n        function ImportError() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            ImportError.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(ImportError, SyntaxError);\n        ImportError.prototype.__init__ = function __init__ () {\n            SyntaxError.prototype.__init__ && SyntaxError.prototype.__init__.apply(this, arguments);\n        };\n        ImportError.prototype.__repr__ = function __repr__ () {\n            if(SyntaxError.prototype.__repr__) return SyntaxError.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        ImportError.prototype.__str__ = function __str__ () {\n            if(SyntaxError.prototype.__str__) return SyntaxError.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(ImportError.prototype, "__bases__", {value: [SyntaxError]});\n        \n\n        RS_modules.errors.SyntaxError = SyntaxError;\n        RS_modules.errors.ImportError = ImportError;\n    })();\n\n    (function(){\n        var __name__ = "unicode_aliases";\n        var DB, ALIAS_MAP;\n        DB = "\\n# NameAliases-8.0.0.txt\\n# Date: 2014-11-19, 01:30:00 GMT [KW, LI]\\n#\\n# This file is a normative contributory data file in the\\n# Unicode Character Database.\\n#\\n# Copyright (c) 2005-2014 Unicode, Inc.\\n# For terms of use, see http://www.unicode.org/terms_of_use.html\\n#\\n# This file defines the formal name aliases for Unicode characters.\\n#\\n# For informative aliases, see NamesList.txt\\n#\\n# The formal name aliases are divided into five types, each with a distinct label.\\n#\\n# Type Labels:\\n#\\n# 1. correction\\n#      Corrections for serious problems in the character names\\n# 2. control\\n#      ISO 6429 names for C0 and C1 control functions, and other\\n#      commonly occurring names for control codes\\n# 3. alternate\\n#      A few widely used alternate names for format characters\\n# 4. figment\\n#      Several documented labels for C1 control code points which\\n#      were never actually approved in any standard\\n# 5. abbreviation\\n#      Commonly occurring abbreviations (or acronyms) for control codes,\\n#      format characters, spaces, and variation selectors\\n#\\n# The formal name aliases are part of the Unicode character namespace, which\\n# includes the character names and the names of named character sequences.\\n# The inclusion of ISO 6429 names and other commonly occurring names and\\n# abbreviations for control codes and format characters as formal name aliases\\n# is to help avoid name collisions between Unicode character names and the\\n# labels which commonly appear in text and/or in implementations such as regex, for\\n# control codes (which for historical reasons have no Unicode character name)\\n# or for format characters.\\n#\\n# For documentation, see NamesList.html and http://www.unicode.org/reports/tr44/\\n#\\n# FORMAT\\n#\\n# Each line has three fields, as described here:\\n#\\n# First field:  Code point\\n# Second field: Alias\\n# Third field:  Type\\n#\\n# The type labels used are defined above. As for property values, comparisons\\n# of type labels should ignore case.\\n#\\n# The type labels can be mapped to other strings for display, if desired.\\n#\\n# In case multiple aliases are assigned, additional aliases\\n# are provided on separate lines. Parsers of this data file should\\n# take note that the same code point can (and does) occur more than once.\\n#\\n# Note that currently the only instances of multiple aliases of the same\\n# type for a single code point are either of type \\"control\\" or \\"abbreviation\\".\\n# An alias of type \\"abbreviation\\" can, in principle, be added for any code\\n# point, although currently aliases of type \\"correction\\" do not have\\n# any additional aliases of type \\"abbreviation\\". Such relationships\\n# are not enforced by stability policies.\\n#\\n#-----------------------------------------------------------------\\n\\n0000;NULL;control\\n0000;NUL;abbreviation\\n0001;START OF HEADING;control\\n0001;SOH;abbreviation\\n0002;START OF TEXT;control\\n0002;STX;abbreviation\\n0003;END OF TEXT;control\\n0003;ETX;abbreviation\\n0004;END OF TRANSMISSION;control\\n0004;EOT;abbreviation\\n0005;ENQUIRY;control\\n0005;ENQ;abbreviation\\n0006;ACKNOWLEDGE;control\\n0006;ACK;abbreviation\\n\\n# Note that no formal name alias for the ISO 6429 \\"BELL\\" is\\n# provided for U+0007, because of the existing name collision\\n# with U+1F514 BELL.\\n\\n0007;ALERT;control\\n0007;BEL;abbreviation\\n\\n0008;BACKSPACE;control\\n0008;BS;abbreviation\\n0009;CHARACTER TABULATION;control\\n0009;HORIZONTAL TABULATION;control\\n0009;HT;abbreviation\\n0009;TAB;abbreviation\\n000A;LINE FEED;control\\n000A;NEW LINE;control\\n000A;END OF LINE;control\\n000A;LF;abbreviation\\n000A;NL;abbreviation\\n000A;EOL;abbreviation\\n000B;LINE TABULATION;control\\n000B;VERTICAL TABULATION;control\\n000B;VT;abbreviation\\n000C;FORM FEED;control\\n000C;FF;abbreviation\\n000D;CARRIAGE RETURN;control\\n000D;CR;abbreviation\\n000E;SHIFT OUT;control\\n000E;LOCKING-SHIFT ONE;control\\n000E;SO;abbreviation\\n000F;SHIFT IN;control\\n000F;LOCKING-SHIFT ZERO;control\\n000F;SI;abbreviation\\n0010;DATA LINK ESCAPE;control\\n0010;DLE;abbreviation\\n0011;DEVICE CONTROL ONE;control\\n0011;DC1;abbreviation\\n0012;DEVICE CONTROL TWO;control\\n0012;DC2;abbreviation\\n0013;DEVICE CONTROL THREE;control\\n0013;DC3;abbreviation\\n0014;DEVICE CONTROL FOUR;control\\n0014;DC4;abbreviation\\n0015;NEGATIVE ACKNOWLEDGE;control\\n0015;NAK;abbreviation\\n0016;SYNCHRONOUS IDLE;control\\n0016;SYN;abbreviation\\n0017;END OF TRANSMISSION BLOCK;control\\n0017;ETB;abbreviation\\n0018;CANCEL;control\\n0018;CAN;abbreviation\\n0019;END OF MEDIUM;control\\n0019;EOM;abbreviation\\n001A;SUBSTITUTE;control\\n001A;SUB;abbreviation\\n001B;ESCAPE;control\\n001B;ESC;abbreviation\\n001C;INFORMATION SEPARATOR FOUR;control\\n001C;FILE SEPARATOR;control\\n001C;FS;abbreviation\\n001D;INFORMATION SEPARATOR THREE;control\\n001D;GROUP SEPARATOR;control\\n001D;GS;abbreviation\\n001E;INFORMATION SEPARATOR TWO;control\\n001E;RECORD SEPARATOR;control\\n001E;RS;abbreviation\\n001F;INFORMATION SEPARATOR ONE;control\\n001F;UNIT SEPARATOR;control\\n001F;US;abbreviation\\n0020;SP;abbreviation\\n007F;DELETE;control\\n007F;DEL;abbreviation\\n\\n# PADDING CHARACTER and HIGH OCTET PRESET represent\\n# architectural concepts initially proposed for early\\n# drafts of ISO/IEC 10646-1. They were never actually\\n# approved or standardized: hence their designation\\n# here as the \\"figment\\" type. Formal name aliases\\n# (and corresponding abbreviations) for these code\\n# points are included here because these names leaked\\n# out from the draft documents and were published in\\n# at least one RFC whose names for code points was\\n# implemented in Perl regex expressions.\\n\\n0080;PADDING CHARACTER;figment\\n0080;PAD;abbreviation\\n0081;HIGH OCTET PRESET;figment\\n0081;HOP;abbreviation\\n\\n0082;BREAK PERMITTED HERE;control\\n0082;BPH;abbreviation\\n0083;NO BREAK HERE;control\\n0083;NBH;abbreviation\\n0084;INDEX;control\\n0084;IND;abbreviation\\n0085;NEXT LINE;control\\n0085;NEL;abbreviation\\n0086;START OF SELECTED AREA;control\\n0086;SSA;abbreviation\\n0087;END OF SELECTED AREA;control\\n0087;ESA;abbreviation\\n0088;CHARACTER TABULATION SET;control\\n0088;HORIZONTAL TABULATION SET;control\\n0088;HTS;abbreviation\\n0089;CHARACTER TABULATION WITH JUSTIFICATION;control\\n0089;HORIZONTAL TABULATION WITH JUSTIFICATION;control\\n0089;HTJ;abbreviation\\n008A;LINE TABULATION SET;control\\n008A;VERTICAL TABULATION SET;control\\n008A;VTS;abbreviation\\n008B;PARTIAL LINE FORWARD;control\\n008B;PARTIAL LINE DOWN;control\\n008B;PLD;abbreviation\\n008C;PARTIAL LINE BACKWARD;control\\n008C;PARTIAL LINE UP;control\\n008C;PLU;abbreviation\\n008D;REVERSE LINE FEED;control\\n008D;REVERSE INDEX;control\\n008D;RI;abbreviation\\n008E;SINGLE SHIFT TWO;control\\n008E;SINGLE-SHIFT-2;control\\n008E;SS2;abbreviation\\n008F;SINGLE SHIFT THREE;control\\n008F;SINGLE-SHIFT-3;control\\n008F;SS3;abbreviation\\n0090;DEVICE CONTROL STRING;control\\n0090;DCS;abbreviation\\n0091;PRIVATE USE ONE;control\\n0091;PRIVATE USE-1;control\\n0091;PU1;abbreviation\\n0092;PRIVATE USE TWO;control\\n0092;PRIVATE USE-2;control\\n0092;PU2;abbreviation\\n0093;SET TRANSMIT STATE;control\\n0093;STS;abbreviation\\n0094;CANCEL CHARACTER;control\\n0094;CCH;abbreviation\\n0095;MESSAGE WAITING;control\\n0095;MW;abbreviation\\n0096;START OF GUARDED AREA;control\\n0096;START OF PROTECTED AREA;control\\n0096;SPA;abbreviation\\n0097;END OF GUARDED AREA;control\\n0097;END OF PROTECTED AREA;control\\n0097;EPA;abbreviation\\n0098;START OF STRING;control\\n0098;SOS;abbreviation\\n\\n# SINGLE GRAPHIC CHARACTER INTRODUCER is another\\n# architectural concept from early drafts of ISO/IEC 10646-1\\n# which was never approved and standardized.\\n\\n0099;SINGLE GRAPHIC CHARACTER INTRODUCER;figment\\n0099;SGC;abbreviation\\n\\n009A;SINGLE CHARACTER INTRODUCER;control\\n009A;SCI;abbreviation\\n009B;CONTROL SEQUENCE INTRODUCER;control\\n009B;CSI;abbreviation\\n009C;STRING TERMINATOR;control\\n009C;ST;abbreviation\\n009D;OPERATING SYSTEM COMMAND;control\\n009D;OSC;abbreviation\\n009E;PRIVACY MESSAGE;control\\n009E;PM;abbreviation\\n009F;APPLICATION PROGRAM COMMAND;control\\n009F;APC;abbreviation\\n00A0;NBSP;abbreviation\\n00AD;SHY;abbreviation\\n01A2;LATIN CAPITAL LETTER GHA;correction\\n01A3;LATIN SMALL LETTER GHA;correction\\n034F;CGJ;abbreviation\\n061C;ALM;abbreviation\\n0709;SYRIAC SUBLINEAR COLON SKEWED LEFT;correction\\n0CDE;KANNADA LETTER LLLA;correction\\n0E9D;LAO LETTER FO FON;correction\\n0E9F;LAO LETTER FO FAY;correction\\n0EA3;LAO LETTER RO;correction\\n0EA5;LAO LETTER LO;correction\\n0FD0;TIBETAN MARK BKA- SHOG GI MGO RGYAN;correction\\n180B;FVS1;abbreviation\\n180C;FVS2;abbreviation\\n180D;FVS3;abbreviation\\n180E;MVS;abbreviation\\n200B;ZWSP;abbreviation\\n200C;ZWNJ;abbreviation\\n200D;ZWJ;abbreviation\\n200E;LRM;abbreviation\\n200F;RLM;abbreviation\\n202A;LRE;abbreviation\\n202B;RLE;abbreviation\\n202C;PDF;abbreviation\\n202D;LRO;abbreviation\\n202E;RLO;abbreviation\\n202F;NNBSP;abbreviation\\n205F;MMSP;abbreviation\\n2060;WJ;abbreviation\\n2066;LRI;abbreviation\\n2067;RLI;abbreviation\\n2068;FSI;abbreviation\\n2069;PDI;abbreviation\\n2118;WEIERSTRASS ELLIPTIC FUNCTION;correction\\n2448;MICR ON US SYMBOL;correction\\n2449;MICR DASH SYMBOL;correction\\n2B7A;LEFTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\n2B7C;RIGHTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\nA015;YI SYLLABLE ITERATION MARK;correction\\nFE18;PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET;correction\\nFE00;VS1;abbreviation\\nFE01;VS2;abbreviation\\nFE02;VS3;abbreviation\\nFE03;VS4;abbreviation\\nFE04;VS5;abbreviation\\nFE05;VS6;abbreviation\\nFE06;VS7;abbreviation\\nFE07;VS8;abbreviation\\nFE08;VS9;abbreviation\\nFE09;VS10;abbreviation\\nFE0A;VS11;abbreviation\\nFE0B;VS12;abbreviation\\nFE0C;VS13;abbreviation\\nFE0D;VS14;abbreviation\\nFE0E;VS15;abbreviation\\nFE0F;VS16;abbreviation\\nFEFF;BYTE ORDER MARK;alternate\\nFEFF;BOM;abbreviation\\nFEFF;ZWNBSP;abbreviation\\n122D4;CUNEIFORM SIGN NU11 TENU;correction\\n122D5;CUNEIFORM SIGN NU11 OVER NU11 BUR OVER BUR;correction\\n1D0C5;BYZANTINE MUSICAL SYMBOL FTHORA SKLIRON CHROMA VASIS;correction\\nE0100;VS17;abbreviation\\nE0101;VS18;abbreviation\\nE0102;VS19;abbreviation\\nE0103;VS20;abbreviation\\nE0104;VS21;abbreviation\\nE0105;VS22;abbreviation\\nE0106;VS23;abbreviation\\nE0107;VS24;abbreviation\\nE0108;VS25;abbreviation\\nE0109;VS26;abbreviation\\nE010A;VS27;abbreviation\\nE010B;VS28;abbreviation\\nE010C;VS29;abbreviation\\nE010D;VS30;abbreviation\\nE010E;VS31;abbreviation\\nE010F;VS32;abbreviation\\nE0110;VS33;abbreviation\\nE0111;VS34;abbreviation\\nE0112;VS35;abbreviation\\nE0113;VS36;abbreviation\\nE0114;VS37;abbreviation\\nE0115;VS38;abbreviation\\nE0116;VS39;abbreviation\\nE0117;VS40;abbreviation\\nE0118;VS41;abbreviation\\nE0119;VS42;abbreviation\\nE011A;VS43;abbreviation\\nE011B;VS44;abbreviation\\nE011C;VS45;abbreviation\\nE011D;VS46;abbreviation\\nE011E;VS47;abbreviation\\nE011F;VS48;abbreviation\\nE0120;VS49;abbreviation\\nE0121;VS50;abbreviation\\nE0122;VS51;abbreviation\\nE0123;VS52;abbreviation\\nE0124;VS53;abbreviation\\nE0125;VS54;abbreviation\\nE0126;VS55;abbreviation\\nE0127;VS56;abbreviation\\nE0128;VS57;abbreviation\\nE0129;VS58;abbreviation\\nE012A;VS59;abbreviation\\nE012B;VS60;abbreviation\\nE012C;VS61;abbreviation\\nE012D;VS62;abbreviation\\nE012E;VS63;abbreviation\\nE012F;VS64;abbreviation\\nE0130;VS65;abbreviation\\nE0131;VS66;abbreviation\\nE0132;VS67;abbreviation\\nE0133;VS68;abbreviation\\nE0134;VS69;abbreviation\\nE0135;VS70;abbreviation\\nE0136;VS71;abbreviation\\nE0137;VS72;abbreviation\\nE0138;VS73;abbreviation\\nE0139;VS74;abbreviation\\nE013A;VS75;abbreviation\\nE013B;VS76;abbreviation\\nE013C;VS77;abbreviation\\nE013D;VS78;abbreviation\\nE013E;VS79;abbreviation\\nE013F;VS80;abbreviation\\nE0140;VS81;abbreviation\\nE0141;VS82;abbreviation\\nE0142;VS83;abbreviation\\nE0143;VS84;abbreviation\\nE0144;VS85;abbreviation\\nE0145;VS86;abbreviation\\nE0146;VS87;abbreviation\\nE0147;VS88;abbreviation\\nE0148;VS89;abbreviation\\nE0149;VS90;abbreviation\\nE014A;VS91;abbreviation\\nE014B;VS92;abbreviation\\nE014C;VS93;abbreviation\\nE014D;VS94;abbreviation\\nE014E;VS95;abbreviation\\nE014F;VS96;abbreviation\\nE0150;VS97;abbreviation\\nE0151;VS98;abbreviation\\nE0152;VS99;abbreviation\\nE0153;VS100;abbreviation\\nE0154;VS101;abbreviation\\nE0155;VS102;abbreviation\\nE0156;VS103;abbreviation\\nE0157;VS104;abbreviation\\nE0158;VS105;abbreviation\\nE0159;VS106;abbreviation\\nE015A;VS107;abbreviation\\nE015B;VS108;abbreviation\\nE015C;VS109;abbreviation\\nE015D;VS110;abbreviation\\nE015E;VS111;abbreviation\\nE015F;VS112;abbreviation\\nE0160;VS113;abbreviation\\nE0161;VS114;abbreviation\\nE0162;VS115;abbreviation\\nE0163;VS116;abbreviation\\nE0164;VS117;abbreviation\\nE0165;VS118;abbreviation\\nE0166;VS119;abbreviation\\nE0167;VS120;abbreviation\\nE0168;VS121;abbreviation\\nE0169;VS122;abbreviation\\nE016A;VS123;abbreviation\\nE016B;VS124;abbreviation\\nE016C;VS125;abbreviation\\nE016D;VS126;abbreviation\\nE016E;VS127;abbreviation\\nE016F;VS128;abbreviation\\nE0170;VS129;abbreviation\\nE0171;VS130;abbreviation\\nE0172;VS131;abbreviation\\nE0173;VS132;abbreviation\\nE0174;VS133;abbreviation\\nE0175;VS134;abbreviation\\nE0176;VS135;abbreviation\\nE0177;VS136;abbreviation\\nE0178;VS137;abbreviation\\nE0179;VS138;abbreviation\\nE017A;VS139;abbreviation\\nE017B;VS140;abbreviation\\nE017C;VS141;abbreviation\\nE017D;VS142;abbreviation\\nE017E;VS143;abbreviation\\nE017F;VS144;abbreviation\\nE0180;VS145;abbreviation\\nE0181;VS146;abbreviation\\nE0182;VS147;abbreviation\\nE0183;VS148;abbreviation\\nE0184;VS149;abbreviation\\nE0185;VS150;abbreviation\\nE0186;VS151;abbreviation\\nE0187;VS152;abbreviation\\nE0188;VS153;abbreviation\\nE0189;VS154;abbreviation\\nE018A;VS155;abbreviation\\nE018B;VS156;abbreviation\\nE018C;VS157;abbreviation\\nE018D;VS158;abbreviation\\nE018E;VS159;abbreviation\\nE018F;VS160;abbreviation\\nE0190;VS161;abbreviation\\nE0191;VS162;abbreviation\\nE0192;VS163;abbreviation\\nE0193;VS164;abbreviation\\nE0194;VS165;abbreviation\\nE0195;VS166;abbreviation\\nE0196;VS167;abbreviation\\nE0197;VS168;abbreviation\\nE0198;VS169;abbreviation\\nE0199;VS170;abbreviation\\nE019A;VS171;abbreviation\\nE019B;VS172;abbreviation\\nE019C;VS173;abbreviation\\nE019D;VS174;abbreviation\\nE019E;VS175;abbreviation\\nE019F;VS176;abbreviation\\nE01A0;VS177;abbreviation\\nE01A1;VS178;abbreviation\\nE01A2;VS179;abbreviation\\nE01A3;VS180;abbreviation\\nE01A4;VS181;abbreviation\\nE01A5;VS182;abbreviation\\nE01A6;VS183;abbreviation\\nE01A7;VS184;abbreviation\\nE01A8;VS185;abbreviation\\nE01A9;VS186;abbreviation\\nE01AA;VS187;abbreviation\\nE01AB;VS188;abbreviation\\nE01AC;VS189;abbreviation\\nE01AD;VS190;abbreviation\\nE01AE;VS191;abbreviation\\nE01AF;VS192;abbreviation\\nE01B0;VS193;abbreviation\\nE01B1;VS194;abbreviation\\nE01B2;VS195;abbreviation\\nE01B3;VS196;abbreviation\\nE01B4;VS197;abbreviation\\nE01B5;VS198;abbreviation\\nE01B6;VS199;abbreviation\\nE01B7;VS200;abbreviation\\nE01B8;VS201;abbreviation\\nE01B9;VS202;abbreviation\\nE01BA;VS203;abbreviation\\nE01BB;VS204;abbreviation\\nE01BC;VS205;abbreviation\\nE01BD;VS206;abbreviation\\nE01BE;VS207;abbreviation\\nE01BF;VS208;abbreviation\\nE01C0;VS209;abbreviation\\nE01C1;VS210;abbreviation\\nE01C2;VS211;abbreviation\\nE01C3;VS212;abbreviation\\nE01C4;VS213;abbreviation\\nE01C5;VS214;abbreviation\\nE01C6;VS215;abbreviation\\nE01C7;VS216;abbreviation\\nE01C8;VS217;abbreviation\\nE01C9;VS218;abbreviation\\nE01CA;VS219;abbreviation\\nE01CB;VS220;abbreviation\\nE01CC;VS221;abbreviation\\nE01CD;VS222;abbreviation\\nE01CE;VS223;abbreviation\\nE01CF;VS224;abbreviation\\nE01D0;VS225;abbreviation\\nE01D1;VS226;abbreviation\\nE01D2;VS227;abbreviation\\nE01D3;VS228;abbreviation\\nE01D4;VS229;abbreviation\\nE01D5;VS230;abbreviation\\nE01D6;VS231;abbreviation\\nE01D7;VS232;abbreviation\\nE01D8;VS233;abbreviation\\nE01D9;VS234;abbreviation\\nE01DA;VS235;abbreviation\\nE01DB;VS236;abbreviation\\nE01DC;VS237;abbreviation\\nE01DD;VS238;abbreviation\\nE01DE;VS239;abbreviation\\nE01DF;VS240;abbreviation\\nE01E0;VS241;abbreviation\\nE01E1;VS242;abbreviation\\nE01E2;VS243;abbreviation\\nE01E3;VS244;abbreviation\\nE01E4;VS245;abbreviation\\nE01E5;VS246;abbreviation\\nE01E6;VS247;abbreviation\\nE01E7;VS248;abbreviation\\nE01E8;VS249;abbreviation\\nE01E9;VS250;abbreviation\\nE01EA;VS251;abbreviation\\nE01EB;VS252;abbreviation\\nE01EC;VS253;abbreviation\\nE01ED;VS254;abbreviation\\nE01EE;VS255;abbreviation\\nE01EF;VS256;abbreviation\\n\\n# EOF\\n";\n        ALIAS_MAP = function () {\n            var ans, line, parts, code_point;\n            ans = {};\n            var RS_Iter10 = RS_Iterable(DB.split("\\n"));\n            for (var RS_Index10 = 0; RS_Index10 < RS_Iter10.length; RS_Index10++) {\n                line = RS_Iter10[RS_Index10];\n                line = line.trim();\n                if (!line || line[0] === "#") {\n                    continue;\n                }\n                parts = line.split(";");\n                if (parts.length >= 2) {\n                    code_point = parseInt(parts[0], 16);\n                    if (code_point !== undefined && parts[1]) {\n                        ans[RS_bound_index(parts[1].toLowerCase(), ans)] = code_point;\n                    }\n                }\n            }\n            return ans;\n        }();\n        RS_modules.unicode_aliases.DB = DB;\n        RS_modules.unicode_aliases.ALIAS_MAP = ALIAS_MAP;\n    })();\n\n    (function(){\n        var __name__ = "ast";\n        var noop = RS_modules.utils.noop;\n\n        function is_node_type(node, typ) {\n            return node instanceof typ;\n        };\n        if (!is_node_type.__argnames__) Object.defineProperties(is_node_type, {\n            __argnames__ : {value: ["node", "typ"]}\n        });\n\n        function AST() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST.prototype.__init__.apply(this, arguments);\n        }\n        AST.prototype.__init__ = function __init__(initializer) {\n            var self = this;\n            var obj;\n            if (initializer) {\n                obj = self;\n                while (true) {\n                    obj = Object.getPrototypeOf(obj);\n                    if (obj === null) {\n                        break;\n                    }\n                    for (var i in obj.properties) {\n                        self[i] = initializer[i];\n                    }\n                }\n            }\n        };\n        if (!AST.prototype.__init__.__argnames__) Object.defineProperties(AST.prototype.__init__, {\n            __argnames__ : {value: ["initializer"]}\n        });\n        AST.__argnames__ = AST.prototype.__init__.__argnames__;\n        AST.__handles_kwarg_interpolation__ = AST.prototype.__init__.__handles_kwarg_interpolation__;\n        AST.prototype.clone = function clone() {\n            var self = this;\n            return new self.constructor(self);\n        };\n        AST.prototype.__repr__ = function __repr__ () {\n                        return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        Object.defineProperty(AST.prototype, "__bases__", {value: []});\n        AST.prototype.properties = Object.create(null);\n\n        function AST_Token() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Token.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Token, AST);\n        AST_Token.prototype.__init__ = function __init__ () {\n            AST.prototype.__init__ && AST.prototype.__init__.apply(this, arguments);\n        };\n        AST_Token.prototype.__repr__ = function __repr__ () {\n            if(AST.prototype.__repr__) return AST.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Token.prototype.__str__ = function __str__ () {\n            if(AST.prototype.__str__) return AST.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Token.prototype, "__bases__", {value: [AST]});\n        AST_Token.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["type"] = "The type of the token";\n            RS_d["value"] = "The value of the token";\n            RS_d["line"] = "The line number at which the token occurs";\n            RS_d["col"] = "The column number at which the token occurs";\n            RS_d["pos"] = "";\n            RS_d["endpos"] = "";\n            RS_d["nlb"] = "True iff there was a newline before this token";\n            RS_d["comments_before"] = "True iff there were comments before this token";\n            RS_d["file"] = "The filename in which this token occurs";\n            RS_d["leading_whitespace"] = "The leading whitespace for the line on which this token occurs";\n            return RS_d;\n        }).call(this);\n\n        function AST_Node() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Node.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Node, AST);\n        AST_Node.prototype.__init__ = function __init__ () {\n            AST.prototype.__init__ && AST.prototype.__init__.apply(this, arguments);\n        };\n        AST_Node.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self);\n        };\n        if (!AST_Node.prototype._walk.__argnames__) Object.defineProperties(AST_Node.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Node.prototype.walk = function walk(visitor) {\n            var self = this;\n            return self._walk(visitor);\n        };\n        if (!AST_Node.prototype.walk.__argnames__) Object.defineProperties(AST_Node.prototype.walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Node.prototype._dump = function _dump() {\n            var self = this;\n            var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? _dump.__defaults__.depth : arguments[0];\n            var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? _dump.__defaults__.omit : arguments[1];\n            var offset = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? _dump.__defaults__.offset : arguments[2];\n            var include_name = (arguments[3] === undefined || ( 3 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? _dump.__defaults__.include_name : arguments[3];\n            var RS_kwargs_obj = arguments[arguments.length-1];\n            if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n            if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "depth")){\n                depth = RS_kwargs_obj.depth;\n            }\n            if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "omit")){\n                omit = RS_kwargs_obj.omit;\n            }\n            if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "offset")){\n                offset = RS_kwargs_obj.offset;\n            }\n            if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "include_name")){\n                include_name = RS_kwargs_obj.include_name;\n            }\n            var p, reset, yellow, blue, green, red, magenta, pad, element, tname, property, key;\n            p = console.log;\n            reset = "\\u001b[0m";\n            yellow = "\\u001b[33m";\n            blue = "\\u001b[34m";\n            green = "\\u001b[32m";\n            red = "\\u001b[31m";\n            magenta = "\\u001b[35m";\n            pad = new Array(offset + 1).join("  ");\n            if (include_name) {\n                p(pad + yellow + self.constructor.name.slice(4) + reset);\n            }\n            var RS_Iter11 = RS_Iterable(self);\n            for (var RS_Index11 = 0; RS_Index11 < RS_Iter11.length; RS_Index11++) {\n                key = RS_Iter11[RS_Index11];\n                if (RS_in(key, omit)) {\n                    continue;\n                }\n                if (Array.isArray(self[(typeof key === "number" && key < 0) ? self.length + key : key])) {\n                    if (self[(typeof key === "number" && key < 0) ? self.length + key : key].length) {\n                        p(pad + " " + blue + key + ": " + reset + "[");\n                        if (depth > 1) {\n                            var RS_Iter12 = RS_Iterable(self[(typeof key === "number" && key < 0) ? self.length + key : key]);\n                            for (var RS_Index12 = 0; RS_Index12 < RS_Iter12.length; RS_Index12++) {\n                                element = RS_Iter12[RS_Index12];\n                                element._dump(depth - 1, omit, offset + 1, true);\n                            }\n                        } else {\n                            var RS_Iter13 = RS_Iterable(self[(typeof key === "number" && key < 0) ? self.length + key : key]);\n                            for (var RS_Index13 = 0; RS_Index13 < RS_Iter13.length; RS_Index13++) {\n                                element = RS_Iter13[RS_Index13];\n                                p(pad + "   " + yellow + element.constructor.name.slice(4) + reset);\n                            }\n                        }\n                        p(pad + " ]");\n                    } else {\n                        p(pad + " " + blue + key + ": " + reset + "[]");\n                    }\n                } else if (self[(typeof key === "number" && key < 0) ? self.length + key : key]) {\n                    if (is_node_type(self[(typeof key === "number" && key < 0) ? self.length + key : key], AST)) {\n                        tname = self[(typeof key === "number" && key < 0) ? self.length + key : key].constructor.name.slice(4);\n                        if (tname === "Token") {\n                            p(pad + " " + blue + key + ": " + magenta + tname + reset);\n                            var RS_Iter14 = RS_Iterable(self[(typeof key === "number" && key < 0) ? self.length + key : key]);\n                            for (var RS_Index14 = 0; RS_Index14 < RS_Iter14.length; RS_Index14++) {\n                                property = RS_Iter14[RS_Index14];\n                                p(pad + "   " + blue + property + ": " + reset + (RS_expr_temp = self[(typeof key === "number" && key < 0) ? self.length + key : key])[(typeof property === "number" && property < 0) ? RS_expr_temp.length + property : property]);\n                            }\n                        } else {\n                            p(pad + " " + blue + key + ": " + yellow + tname + reset);\n                            if (depth > 1) {\n                                self[(typeof key === "number" && key < 0) ? self.length + key : key]._dump(depth - 1, omit, offset + 1, false);\n                            }\n                        }\n                    } else if (typeof self[(typeof key === "number" && key < 0) ? self.length + key : key] === "string") {\n                        p(pad + " " + blue + key + ": " + green + "\\"" + self[(typeof key === "number" && key < 0) ? self.length + key : key] + "\\"" + reset);\n                    } else if (typeof self[(typeof key === "number" && key < 0) ? self.length + key : key] === "number") {\n                        p(pad + " " + blue + key + ": " + green + self[(typeof key === "number" && key < 0) ? self.length + key : key] + reset);\n                    } else {\n                        p(pad + " " + blue + key + ": " + red + self[(typeof key === "number" && key < 0) ? self.length + key : key] + reset);\n                    }\n                } else {\n                    p(pad + " " + blue + key + ": " + reset + self[(typeof key === "number" && key < 0) ? self.length + key : key]);\n                }\n            }\n        };\n        if (!AST_Node.prototype._dump.__defaults__) Object.defineProperties(AST_Node.prototype._dump, {\n            __defaults__ : {value: {depth:100, omit:(function(){\n                var s = RS_set();\n                s.jsset.add("start");\n                s.jsset.add("end");\n                return s;\n            })(), offset:0, include_name:true}},\n            __handles_kwarg_interpolation__ : {value: true},\n            __argnames__ : {value: ["depth", "omit", "offset", "include_name"]}\n        });\n        AST_Node.prototype.dump = function dump() {\n            var self = this;\n            var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? dump.__defaults__.depth : arguments[0];\n            var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? dump.__defaults__.omit : arguments[1];\n            var RS_kwargs_obj = arguments[arguments.length-1];\n            if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n            if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "depth")){\n                depth = RS_kwargs_obj.depth;\n            }\n            if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "omit")){\n                omit = RS_kwargs_obj.omit;\n            }\n            return self._dump(depth, omit, 0, true);\n        };\n        if (!AST_Node.prototype.dump.__defaults__) Object.defineProperties(AST_Node.prototype.dump, {\n            __defaults__ : {value: {depth:2, omit:Object.create(null)}},\n            __handles_kwarg_interpolation__ : {value: true},\n            __argnames__ : {value: ["depth", "omit"]}\n        });\n        AST_Node.prototype.__repr__ = function __repr__ () {\n            if(AST.prototype.__repr__) return AST.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Node.prototype.__str__ = function __str__ () {\n            if(AST.prototype.__str__) return AST.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Node.prototype, "__bases__", {value: [AST]});\n        AST_Node.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["start"] = "[AST_Token] The first token of this node";\n            RS_d["end"] = "[AST_Token] The last token of this node";\n            return RS_d;\n        }).call(this);\n\n        function AST_Statement() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Statement.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Statement, AST_Node);\n        AST_Statement.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Statement.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Statement.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Statement.prototype, "__bases__", {value: [AST_Node]});\n\n        function AST_Debugger() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Debugger.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Debugger, AST_Statement);\n        AST_Debugger.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Debugger.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Debugger.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Debugger.prototype, "__bases__", {value: [AST_Statement]});\n\n        function AST_Directive() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Directive.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Directive, AST_Statement);\n        AST_Directive.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Directive.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Directive.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Directive.prototype, "__bases__", {value: [AST_Statement]});\n        AST_Directive.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[string] The value of this directive as a plain string (it\'s not an AST_String!)";\n            RS_d["scope"] = "[AST_Scope/S] The scope that this directive affects";\n            return RS_d;\n        }).call(this);\n\n        function AST_SimpleStatement() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SimpleStatement.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SimpleStatement, AST_Statement);\n        AST_SimpleStatement.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_SimpleStatement.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_SimpleStatement.prototype._walk.__argnames__) Object.defineProperties(AST_SimpleStatement.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_SimpleStatement.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SimpleStatement.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SimpleStatement.prototype, "__bases__", {value: [AST_Statement]});\n        AST_SimpleStatement.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["body"] = "[AST_Node] an expression node (should not be instanceof AST_Statement)";\n            return RS_d;\n        }).call(this);\n\n        function AST_Assert() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Assert.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Assert, AST_Statement);\n        AST_Assert.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Assert.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                if (self.message) {\n                    self.message._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Assert.prototype._walk.__argnames__) Object.defineProperties(AST_Assert.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Assert.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Assert.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Assert.prototype, "__bases__", {value: [AST_Statement]});\n        AST_Assert.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["condition"] = "[AST_Node] the expression that should be tested";\n            RS_d["message"] = "[AST_Node*] the expression that is the error message or None";\n            return RS_d;\n        }).call(this);\n\n        function walk_body(node, visitor) {\n            var stat;\n            if (is_node_type(node.body, AST_Statement)) {\n                node.body._walk(visitor);\n            } else if (node.body) {\n                var RS_Iter15 = RS_Iterable(node.body);\n                for (var RS_Index15 = 0; RS_Index15 < RS_Iter15.length; RS_Index15++) {\n                    stat = RS_Iter15[RS_Index15];\n                    stat._walk(visitor);\n                }\n            }\n        };\n        if (!walk_body.__argnames__) Object.defineProperties(walk_body, {\n            __argnames__ : {value: ["node", "visitor"]}\n        });\n\n        function AST_Block() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Block.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Block, AST_Statement);\n        AST_Block.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Block.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                walk_body(self, visitor);\n            });\n        };\n        if (!AST_Block.prototype._walk.__argnames__) Object.defineProperties(AST_Block.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Block.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Block.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Block.prototype, "__bases__", {value: [AST_Statement]});\n        AST_Block.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["body"] = "[AST_Statement*] an array of statements";\n            return RS_d;\n        }).call(this);\n\n        function AST_BlockStatement() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_BlockStatement.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_BlockStatement, AST_Block);\n        AST_BlockStatement.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_BlockStatement.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_BlockStatement.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_BlockStatement.prototype, "__bases__", {value: [AST_Block]});\n\n        function AST_EmptyStatement() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_EmptyStatement.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_EmptyStatement, AST_Statement);\n        AST_EmptyStatement.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_EmptyStatement.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self);\n        };\n        if (!AST_EmptyStatement.prototype._walk.__argnames__) Object.defineProperties(AST_EmptyStatement.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_EmptyStatement.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_EmptyStatement.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_EmptyStatement.prototype, "__bases__", {value: [AST_Statement]});\n        AST_EmptyStatement.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["stype"] = "[string] the type of empty statement. Is ; for semicolons";\n            return RS_d;\n        }).call(this);\n\n        function AST_StatementWithBody() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_StatementWithBody, AST_Statement);\n        AST_StatementWithBody.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_StatementWithBody.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_StatementWithBody.prototype._walk.__argnames__) Object.defineProperties(AST_StatementWithBody.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_StatementWithBody.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_StatementWithBody.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_StatementWithBody.prototype, "__bases__", {value: [AST_Statement]});\n        AST_StatementWithBody.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["body"] = "[AST_Statement] the body; this should always be present, even if it\'s an AST_EmptyStatement";\n            return RS_d;\n        }).call(this);\n\n        function AST_DWLoop() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_DWLoop.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_DWLoop, AST_StatementWithBody);\n        AST_DWLoop.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_DWLoop.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_DWLoop.prototype._walk.__argnames__) Object.defineProperties(AST_DWLoop.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_DWLoop.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_DWLoop.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_DWLoop.prototype, "__bases__", {value: [AST_StatementWithBody]});\n        AST_DWLoop.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["condition"] = "[AST_Node] the loop condition.  Should not be instanceof AST_Statement";\n            return RS_d;\n        }).call(this);\n\n        function AST_Do() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Do.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Do, AST_DWLoop);\n        AST_Do.prototype.__init__ = function __init__ () {\n            AST_DWLoop.prototype.__init__ && AST_DWLoop.prototype.__init__.apply(this, arguments);\n        };\n        AST_Do.prototype.__repr__ = function __repr__ () {\n            if(AST_DWLoop.prototype.__repr__) return AST_DWLoop.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Do.prototype.__str__ = function __str__ () {\n            if(AST_DWLoop.prototype.__str__) return AST_DWLoop.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Do.prototype, "__bases__", {value: [AST_DWLoop]});\n\n        function AST_While() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_While.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_While, AST_DWLoop);\n        AST_While.prototype.__init__ = function __init__ () {\n            AST_DWLoop.prototype.__init__ && AST_DWLoop.prototype.__init__.apply(this, arguments);\n        };\n        AST_While.prototype.__repr__ = function __repr__ () {\n            if(AST_DWLoop.prototype.__repr__) return AST_DWLoop.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_While.prototype.__str__ = function __str__ () {\n            if(AST_DWLoop.prototype.__str__) return AST_DWLoop.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_While.prototype, "__bases__", {value: [AST_DWLoop]});\n\n        function AST_ForIn() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ForIn.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ForIn, AST_StatementWithBody);\n        AST_ForIn.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_ForIn.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.init._walk(visitor);\n                if (self.name) self.name._walk(visitor);\n                self.object._walk(visitor);\n                if (self.body) {\n                    self.body._walk(visitor);\n                }\n            });\n        };\n        if (!AST_ForIn.prototype._walk.__argnames__) Object.defineProperties(AST_ForIn.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_ForIn.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ForIn.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ForIn.prototype, "__bases__", {value: [AST_StatementWithBody]});\n        AST_ForIn.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["init"] = "[AST_Node] the `for/in` initialization code";\n            RS_d["name"] = "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var";\n            RS_d["object"] = "[AST_Node] the object that we\'re looping through";\n            return RS_d;\n        }).call(this);\n\n        function AST_ForJS() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ForJS.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ForJS, AST_StatementWithBody);\n        AST_ForJS.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_ForJS.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ForJS.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ForJS.prototype, "__bases__", {value: [AST_StatementWithBody]});\n        AST_ForJS.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["condition"] = "[AST_Verbatim] raw JavaScript conditional";\n            return RS_d;\n        }).call(this);\n\n        function AST_ListComprehension() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ListComprehension, AST_ForIn);\n        AST_ListComprehension.prototype.__init__ = function __init__ () {\n            AST_ForIn.prototype.__init__ && AST_ForIn.prototype.__init__.apply(this, arguments);\n        };\n        AST_ListComprehension.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.init._walk(visitor);\n                self.object._walk(visitor);\n                self.statement._walk(visitor);\n                if (self.condition) self.condition._walk(visitor);\n            });\n        };\n        if (!AST_ListComprehension.prototype._walk.__argnames__) Object.defineProperties(AST_ListComprehension.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_ListComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ForIn.prototype.__repr__) return AST_ForIn.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ListComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ForIn.prototype.__str__) return AST_ForIn.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ListComprehension.prototype, "__bases__", {value: [AST_ForIn]});\n        AST_ListComprehension.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["condition"] = "[AST_Node] the `if` condition";\n            RS_d["statement"] = "[AST_Node] statement to perform on each element before returning it";\n            return RS_d;\n        }).call(this);\n\n        function AST_SetComprehension() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SetComprehension.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SetComprehension, AST_ListComprehension);\n        AST_SetComprehension.prototype.__init__ = function __init__ () {\n            AST_ListComprehension.prototype.__init__ && AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        };\n        AST_SetComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ListComprehension.prototype.__repr__) return AST_ListComprehension.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SetComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ListComprehension.prototype.__str__) return AST_ListComprehension.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SetComprehension.prototype, "__bases__", {value: [AST_ListComprehension]});\n\n        function AST_DictComprehension() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_DictComprehension.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_DictComprehension, AST_ListComprehension);\n        AST_DictComprehension.prototype.__init__ = function __init__ () {\n            AST_ListComprehension.prototype.__init__ && AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        };\n        AST_DictComprehension.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.init._walk(visitor);\n                self.object._walk(visitor);\n                self.statement._walk(visitor);\n                self.value_statement._walk(visitor);\n                if (self.condition) self.condition._walk(visitor);\n            });\n        };\n        if (!AST_DictComprehension.prototype._walk.__argnames__) Object.defineProperties(AST_DictComprehension.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_DictComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ListComprehension.prototype.__repr__) return AST_ListComprehension.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_DictComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ListComprehension.prototype.__str__) return AST_ListComprehension.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_DictComprehension.prototype, "__bases__", {value: [AST_ListComprehension]});\n        AST_DictComprehension.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value_statement"] = "[AST_Node] statement to perform on each value before returning it";\n            RS_d["is_pydict"] = "[bool] True if this comprehension is for a python dict";\n            RS_d["is_jshash"] = "[bool] True if this comprehension is for a js hash";\n            return RS_d;\n        }).call(this);\n\n        function AST_GeneratorComprehension() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_GeneratorComprehension.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_GeneratorComprehension, AST_ListComprehension);\n        AST_GeneratorComprehension.prototype.__init__ = function __init__ () {\n            AST_ListComprehension.prototype.__init__ && AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        };\n        AST_GeneratorComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ListComprehension.prototype.__repr__) return AST_ListComprehension.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_GeneratorComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ListComprehension.prototype.__str__) return AST_ListComprehension.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_GeneratorComprehension.prototype, "__bases__", {value: [AST_ListComprehension]});\n\n        function AST_With() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_With.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_With, AST_StatementWithBody);\n        AST_With.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_With.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var exp;\n                var RS_Iter16 = RS_Iterable(self.clauses);\n                for (var RS_Index16 = 0; RS_Index16 < RS_Iter16.length; RS_Index16++) {\n                    exp = RS_Iter16[RS_Index16];\n                    exp._walk(visitor);\n                }\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_With.prototype._walk.__argnames__) Object.defineProperties(AST_With.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_With.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_With.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_With.prototype, "__bases__", {value: [AST_StatementWithBody]});\n        AST_With.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["clauses"] = "[AST_WithClause*] the `with` clauses (comma separated)";\n            return RS_d;\n        }).call(this);\n\n        function AST_WithClause() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_WithClause.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_WithClause, AST_Node);\n        AST_WithClause.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_WithClause.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                if (self.alias) {\n                    self.alias._walk(visitor);\n                }\n            });\n        };\n        if (!AST_WithClause.prototype._walk.__argnames__) Object.defineProperties(AST_WithClause.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_WithClause.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_WithClause.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_WithClause.prototype, "__bases__", {value: [AST_Node]});\n        AST_WithClause.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["expression"] = "[AST_Node] the expression";\n            RS_d["alias"] = "[AST_SymbolAlias?] optional alias for this expression";\n            return RS_d;\n        }).call(this);\n\n        function AST_Scope() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Scope.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Scope, AST_Block);\n        AST_Scope.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Scope.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Scope.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Scope.prototype, "__bases__", {value: [AST_Block]});\n        AST_Scope.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["localvars"] = "[SymbolDef*] list of variables local to this scope";\n            RS_d["docstrings"] = "[AST_String*] list of docstrings for this scope";\n            return RS_d;\n        }).call(this);\n\n        function AST_Toplevel() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Toplevel.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Toplevel, AST_Scope);\n        AST_Toplevel.prototype.__init__ = function __init__ () {\n            AST_Scope.prototype.__init__ && AST_Scope.prototype.__init__.apply(this, arguments);\n        };\n        AST_Toplevel.prototype.__repr__ = function __repr__ () {\n            if(AST_Scope.prototype.__repr__) return AST_Scope.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Toplevel.prototype.__str__ = function __str__ () {\n            if(AST_Scope.prototype.__str__) return AST_Scope.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Toplevel.prototype, "__bases__", {value: [AST_Scope]});\n        AST_Toplevel.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["globals"] = "[Object/S] a map of name -> SymbolDef for all undeclared names";\n            RS_d["baselib"] = "[Object/s] a collection of used parts of baselib";\n            RS_d["imports"] = "[Object/S] a map of module_id->AST_Toplevel for all imported modules (this represents all imported modules across all source files)";\n            RS_d["imported_module_ids"] = "[string*] a list of module ids that were imported by this module, specifically";\n            RS_d["nonlocalvars"] = "[String*] a list of all non-local variable names (names that come from the global scope)";\n            RS_d["shebang"] = "[string] If #! line is present, it will be stored here";\n            RS_d["import_order"] = "[number] The global order in which this scope was imported";\n            RS_d["module_id"] = "[string] The id of this module";\n            RS_d["exports"] = "[SymbolDef*] list of names exported from this module";\n            RS_d["classes"] = "[Object/S] a map of class names to AST_Class for classes defined in this module";\n            RS_d["filename"] = "[string] The absolute path to the file from which this module was read";\n            RS_d["srchash"] = "[string] SHA1 hash of source code, used for caching";\n            return RS_d;\n        }).call(this);\n\n        function AST_Import() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Import.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Import, AST_Statement);\n        AST_Import.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Import.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var arg;\n                if (self.alias) {\n                    self.alias._walk(visitor);\n                }\n                if (self.argnames) {\n                    var RS_Iter17 = RS_Iterable(self.argnames);\n                    for (var RS_Index17 = 0; RS_Index17 < RS_Iter17.length; RS_Index17++) {\n                        arg = RS_Iter17[RS_Index17];\n                        arg._walk(visitor);\n                    }\n                }\n            });\n        };\n        if (!AST_Import.prototype._walk.__argnames__) Object.defineProperties(AST_Import.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Import.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Import.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Import.prototype, "__bases__", {value: [AST_Statement]});\n        AST_Import.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["module"] = "[AST_SymbolVar] name of the module we\'re importing";\n            RS_d["key"] = "[string] The key by which this module is stored in the global modules mapping";\n            RS_d["alias"] = "[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.";\n            RS_d["argnames"] = "[AST_ImportedVar*] names of objects to be imported";\n            RS_d["body"] = "[AST_TopLevel] parsed contents of the imported file";\n            return RS_d;\n        }).call(this);\n\n        function AST_Imports() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Imports.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Imports, AST_Statement);\n        AST_Imports.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Imports.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var imp;\n                var RS_Iter18 = RS_Iterable(self.imports);\n                for (var RS_Index18 = 0; RS_Index18 < RS_Iter18.length; RS_Index18++) {\n                    imp = RS_Iter18[RS_Index18];\n                    imp._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Imports.prototype._walk.__argnames__) Object.defineProperties(AST_Imports.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Imports.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Imports.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Imports.prototype, "__bases__", {value: [AST_Statement]});\n        AST_Imports.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["imports"] = "[AST_Import+] array of imports";\n            return RS_d;\n        }).call(this);\n\n        function AST_Decorator() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Decorator.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Decorator, AST_Node);\n        AST_Decorator.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Decorator.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                if (self.expression) {\n                    self.expression.walk(visitor);\n                }\n            });\n        };\n        if (!AST_Decorator.prototype._walk.__argnames__) Object.defineProperties(AST_Decorator.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Decorator.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Decorator.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Decorator.prototype, "__bases__", {value: [AST_Node]});\n        AST_Decorator.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["expression"] = "[AST_Node] the decorator expression";\n            return RS_d;\n        }).call(this);\n\n        function AST_Lambda() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Lambda.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Lambda, AST_Scope);\n        AST_Lambda.prototype.__init__ = function __init__ () {\n            AST_Scope.prototype.__init__ && AST_Scope.prototype.__init__.apply(this, arguments);\n        };\n        AST_Lambda.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var d, arg;\n                if (self.decorators) {\n                    var RS_Iter19 = RS_Iterable(self.decorators);\n                    for (var RS_Index19 = 0; RS_Index19 < RS_Iter19.length; RS_Index19++) {\n                        d = RS_Iter19[RS_Index19];\n                        d.walk(visitor);\n                    }\n                }\n                if (self.name) {\n                    self.name._walk(visitor);\n                }\n                var RS_Iter20 = RS_Iterable(self.argnames);\n                for (var RS_Index20 = 0; RS_Index20 < RS_Iter20.length; RS_Index20++) {\n                    arg = RS_Iter20[RS_Index20];\n                    arg._walk(visitor);\n                }\n                if (self.argnames.starargs) {\n                    self.argnames.starargs._walk(visitor);\n                }\n                if (self.argnames.kwargs) {\n                    self.argnames.kwargs._walk(visitor);\n                }\n                walk_body(self, visitor);\n            });\n        };\n        if (!AST_Lambda.prototype._walk.__argnames__) Object.defineProperties(AST_Lambda.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Lambda.prototype.__repr__ = function __repr__ () {\n            if(AST_Scope.prototype.__repr__) return AST_Scope.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Lambda.prototype.__str__ = function __str__ () {\n            if(AST_Scope.prototype.__str__) return AST_Scope.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Lambda.prototype, "__bases__", {value: [AST_Scope]});\n        AST_Lambda.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["name"] = "[AST_SymbolDeclaration?] the name of this function";\n            RS_d["argnames"] = "[AST_SymbolFunarg*] array of function arguments";\n            RS_d["decorators"] = "[AST_Decorator*] function decorators, if any";\n            RS_d["is_generator"] = "[bool*] True iff this function is a generator";\n            RS_d["is_expression"] = "[bool*] True iff this function is a function expression";\n            RS_d["is_anonymous"] = "[bool*] True iff this function is an anonymous function";\n            RS_d["return_annotation"] = "[AST_Node?] The return type annotation provided (if any)";\n            return RS_d;\n        }).call(this);\n\n        function AST_Function() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Function.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Function, AST_Lambda);\n        AST_Function.prototype.__init__ = function __init__ () {\n            AST_Lambda.prototype.__init__ && AST_Lambda.prototype.__init__.apply(this, arguments);\n        };\n        AST_Function.prototype.__repr__ = function __repr__ () {\n            if(AST_Lambda.prototype.__repr__) return AST_Lambda.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Function.prototype.__str__ = function __str__ () {\n            if(AST_Lambda.prototype.__str__) return AST_Lambda.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Function.prototype, "__bases__", {value: [AST_Lambda]});\n\n        function AST_Class() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Class.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Class, AST_Scope);\n        AST_Class.prototype.__init__ = function __init__ () {\n            AST_Scope.prototype.__init__ && AST_Scope.prototype.__init__.apply(this, arguments);\n        };\n        AST_Class.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var d;\n                if (self.decorators) {\n                    var RS_Iter21 = RS_Iterable(self.decorators);\n                    for (var RS_Index21 = 0; RS_Index21 < RS_Iter21.length; RS_Index21++) {\n                        d = RS_Iter21[RS_Index21];\n                        d.walk(visitor);\n                    }\n                }\n                self.name._walk(visitor);\n                walk_body(self, visitor);\n                if (self.parent) self.parent._walk(visitor);\n            });\n        };\n        if (!AST_Class.prototype._walk.__argnames__) Object.defineProperties(AST_Class.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Class.prototype.__repr__ = function __repr__ () {\n            if(AST_Scope.prototype.__repr__) return AST_Scope.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Class.prototype.__str__ = function __str__ () {\n            if(AST_Scope.prototype.__str__) return AST_Scope.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Class.prototype, "__bases__", {value: [AST_Scope]});\n        AST_Class.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["name"] = "[AST_SymbolDeclaration?] the name of this class";\n            RS_d["init"] = "[AST_Function] constructor for the class";\n            RS_d["parent"] = "[AST_Symbol?] parent class this class inherits from";\n            RS_d["bases"] = "[AST_Symbol*] list of base classes this class inherits from";\n            RS_d["static"] = "[dict] A hash whose keys are names of static methods for this class";\n            RS_d["external"] = "[boolean] true if class is declared elsewhere, but will be within current scope at runtime";\n            RS_d["bound"] = "[string*] list of methods that need to be bound to self";\n            RS_d["decorators"] = "[AST_Decorator*] function decorators, if any";\n            RS_d["module_id"] = "[string] The id of the module this class is defined in";\n            RS_d["statements"] = "[AST_Node*] list of statements in the class scope (excluding method definitions)";\n            RS_d["dynamic_properties"] = "[dict] map of dynamic property names to property descriptors of the form {getter:AST_Method, setter:AST_Method";\n            RS_d["classvars"] = "[dict] map containing all class variables as keys, to be used to easily test for existence of a class variable";\n            return RS_d;\n        }).call(this);\n\n        function AST_Method() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Method.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Method, AST_Lambda);\n        AST_Method.prototype.__init__ = function __init__ () {\n            AST_Lambda.prototype.__init__ && AST_Lambda.prototype.__init__.apply(this, arguments);\n        };\n        AST_Method.prototype.__repr__ = function __repr__ () {\n            if(AST_Lambda.prototype.__repr__) return AST_Lambda.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Method.prototype.__str__ = function __str__ () {\n            if(AST_Lambda.prototype.__str__) return AST_Lambda.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Method.prototype, "__bases__", {value: [AST_Lambda]});\n        AST_Method.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["static"] = "[boolean] true if method is static";\n            RS_d["is_getter"] = "[boolean] true if method is a property getter";\n            RS_d["is_setter"] = "[boolean] true if method is a property setter";\n            return RS_d;\n        }).call(this);\n\n        function AST_Jump() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Jump.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Jump, AST_Statement);\n        AST_Jump.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Jump.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Jump.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Jump.prototype, "__bases__", {value: [AST_Statement]});\n\n        function AST_Exit() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Exit.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Exit, AST_Jump);\n        AST_Exit.prototype.__init__ = function __init__ () {\n            AST_Jump.prototype.__init__ && AST_Jump.prototype.__init__.apply(this, arguments);\n        };\n        AST_Exit.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                if (self.value) {\n                    self.value._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Exit.prototype._walk.__argnames__) Object.defineProperties(AST_Exit.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Exit.prototype.__repr__ = function __repr__ () {\n            if(AST_Jump.prototype.__repr__) return AST_Jump.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Exit.prototype.__str__ = function __str__ () {\n            if(AST_Jump.prototype.__str__) return AST_Jump.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Exit.prototype, "__bases__", {value: [AST_Jump]});\n        AST_Exit.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return";\n            return RS_d;\n        }).call(this);\n\n        function AST_Return() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Return.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Return, AST_Exit);\n        AST_Return.prototype.__init__ = function __init__ () {\n            AST_Exit.prototype.__init__ && AST_Exit.prototype.__init__.apply(this, arguments);\n        };\n        AST_Return.prototype.__repr__ = function __repr__ () {\n            if(AST_Exit.prototype.__repr__) return AST_Exit.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Return.prototype.__str__ = function __str__ () {\n            if(AST_Exit.prototype.__str__) return AST_Exit.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Return.prototype, "__bases__", {value: [AST_Exit]});\n\n        function AST_Yield() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Yield.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Yield, AST_Return);\n        AST_Yield.prototype.__init__ = function __init__ () {\n            AST_Return.prototype.__init__ && AST_Return.prototype.__init__.apply(this, arguments);\n        };\n        AST_Yield.prototype.__repr__ = function __repr__ () {\n            if(AST_Return.prototype.__repr__) return AST_Return.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Yield.prototype.__str__ = function __str__ () {\n            if(AST_Return.prototype.__str__) return AST_Return.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Yield.prototype, "__bases__", {value: [AST_Return]});\n        AST_Yield.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["is_yield_from"] = "[bool] True iff this is a yield from, False otherwise";\n            return RS_d;\n        }).call(this);\n\n        function AST_Throw() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Throw.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Throw, AST_Exit);\n        AST_Throw.prototype.__init__ = function __init__ () {\n            AST_Exit.prototype.__init__ && AST_Exit.prototype.__init__.apply(this, arguments);\n        };\n        AST_Throw.prototype.__repr__ = function __repr__ () {\n            if(AST_Exit.prototype.__repr__) return AST_Exit.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Throw.prototype.__str__ = function __str__ () {\n            if(AST_Exit.prototype.__str__) return AST_Exit.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Throw.prototype, "__bases__", {value: [AST_Exit]});\n\n        function AST_LoopControl() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_LoopControl.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_LoopControl, AST_Jump);\n        AST_LoopControl.prototype.__init__ = function __init__ () {\n            AST_Jump.prototype.__init__ && AST_Jump.prototype.__init__.apply(this, arguments);\n        };\n        AST_LoopControl.prototype.__repr__ = function __repr__ () {\n            if(AST_Jump.prototype.__repr__) return AST_Jump.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_LoopControl.prototype.__str__ = function __str__ () {\n            if(AST_Jump.prototype.__str__) return AST_Jump.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_LoopControl.prototype, "__bases__", {value: [AST_Jump]});\n\n        function AST_Break() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Break.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Break, AST_LoopControl);\n        AST_Break.prototype.__init__ = function __init__ () {\n            AST_LoopControl.prototype.__init__ && AST_LoopControl.prototype.__init__.apply(this, arguments);\n        };\n        AST_Break.prototype.__repr__ = function __repr__ () {\n            if(AST_LoopControl.prototype.__repr__) return AST_LoopControl.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Break.prototype.__str__ = function __str__ () {\n            if(AST_LoopControl.prototype.__str__) return AST_LoopControl.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Break.prototype, "__bases__", {value: [AST_LoopControl]});\n\n        function AST_Continue() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Continue.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Continue, AST_LoopControl);\n        AST_Continue.prototype.__init__ = function __init__ () {\n            AST_LoopControl.prototype.__init__ && AST_LoopControl.prototype.__init__.apply(this, arguments);\n        };\n        AST_Continue.prototype.__repr__ = function __repr__ () {\n            if(AST_LoopControl.prototype.__repr__) return AST_LoopControl.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Continue.prototype.__str__ = function __str__ () {\n            if(AST_LoopControl.prototype.__str__) return AST_LoopControl.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Continue.prototype, "__bases__", {value: [AST_LoopControl]});\n\n        function AST_If() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_If.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_If, AST_StatementWithBody);\n        AST_If.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_If.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                self.body._walk(visitor);\n                if (self.alternative) {\n                    self.alternative._walk(visitor);\n                }\n            });\n        };\n        if (!AST_If.prototype._walk.__argnames__) Object.defineProperties(AST_If.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_If.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_If.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_If.prototype, "__bases__", {value: [AST_StatementWithBody]});\n        AST_If.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["condition"] = "[AST_Node] the `if` condition";\n            RS_d["alternative"] = "[AST_Statement?] the `else` part, or null if not present";\n            return RS_d;\n        }).call(this);\n\n        function AST_Try() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Try.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Try, AST_Block);\n        AST_Try.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Try.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                walk_body(self, visitor);\n                if (self.bcatch) {\n                    self.bcatch._walk(visitor);\n                }\n                if (self.belse) {\n                    self.belse._walk(visitor);\n                }\n                if (self.bfinally) {\n                    self.bfinally._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Try.prototype._walk.__argnames__) Object.defineProperties(AST_Try.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Try.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Try.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Try.prototype, "__bases__", {value: [AST_Block]});\n        AST_Try.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["bcatch"] = "[AST_Catch?] the catch block, or null if not present";\n            RS_d["bfinally"] = "[AST_Finally?] the finally block, or null if not present";\n            RS_d["belse"] = "[AST_Else?] the else block for null if not present";\n            return RS_d;\n        }).call(this);\n\n        function AST_Catch() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Catch.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Catch, AST_Block);\n        AST_Catch.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Catch.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Catch.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Catch.prototype, "__bases__", {value: [AST_Block]});\n\n        function AST_Except() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Except.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Except, AST_Block);\n        AST_Except.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Except.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(this, function () {\n                var e;\n                if (self.argname) {\n                    self.argname.walk(visitor);\n                }\n                if (self.errors) {\n                    var RS_Iter22 = RS_Iterable(self.errors);\n                    for (var RS_Index22 = 0; RS_Index22 < RS_Iter22.length; RS_Index22++) {\n                        e = RS_Iter22[RS_Index22];\n                        e.walk(visitor);\n                    }\n                }\n                walk_body(self, visitor);\n            });\n        };\n        if (!AST_Except.prototype._walk.__argnames__) Object.defineProperties(AST_Except.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Except.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Except.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Except.prototype, "__bases__", {value: [AST_Block]});\n        AST_Except.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["argname"] = "[AST_SymbolCatch] symbol for the exception";\n            RS_d["errors"] = "[AST_SymbolVar*] error classes to catch in this block";\n            return RS_d;\n        }).call(this);\n\n        function AST_Finally() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Finally.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Finally, AST_Block);\n        AST_Finally.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Finally.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Finally.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Finally.prototype, "__bases__", {value: [AST_Block]});\n\n        function AST_Else() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Else.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Else, AST_Block);\n        AST_Else.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Else.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Else.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Else.prototype, "__bases__", {value: [AST_Block]});\n\n        function AST_Definitions() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Definitions.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Definitions, AST_Statement);\n        AST_Definitions.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Definitions.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var def_;\n                var RS_Iter23 = RS_Iterable(self.definitions);\n                for (var RS_Index23 = 0; RS_Index23 < RS_Iter23.length; RS_Index23++) {\n                    def_ = RS_Iter23[RS_Index23];\n                    def_._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Definitions.prototype._walk.__argnames__) Object.defineProperties(AST_Definitions.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Definitions.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Definitions.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Definitions.prototype, "__bases__", {value: [AST_Statement]});\n        AST_Definitions.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["definitions"] = "[AST_VarDef*] array of variable definitions";\n            return RS_d;\n        }).call(this);\n\n        function AST_Var() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Var.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Var, AST_Definitions);\n        AST_Var.prototype.__init__ = function __init__ () {\n            AST_Definitions.prototype.__init__ && AST_Definitions.prototype.__init__.apply(this, arguments);\n        };\n        AST_Var.prototype.__repr__ = function __repr__ () {\n            if(AST_Definitions.prototype.__repr__) return AST_Definitions.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Var.prototype.__str__ = function __str__ () {\n            if(AST_Definitions.prototype.__str__) return AST_Definitions.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Var.prototype, "__bases__", {value: [AST_Definitions]});\n\n        function AST_VarDef() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_VarDef.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_VarDef, AST_Node);\n        AST_VarDef.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_VarDef.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.name._walk(visitor);\n                if (self.value) {\n                    self.value._walk(visitor);\n                }\n            });\n        };\n        if (!AST_VarDef.prototype._walk.__argnames__) Object.defineProperties(AST_VarDef.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_VarDef.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_VarDef.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_VarDef.prototype, "__bases__", {value: [AST_Node]});\n        AST_VarDef.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["name"] = "[AST_SymbolVar|AST_SymbolNonlocal] name of the variable";\n            RS_d["value"] = "[AST_Node?] initializer, or null if there\'s no initializer";\n            return RS_d;\n        }).call(this);\n\n        function AST_BaseCall() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_BaseCall.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_BaseCall, AST_Node);\n        AST_BaseCall.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_BaseCall.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_BaseCall.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_BaseCall.prototype, "__bases__", {value: [AST_Node]});\n        AST_BaseCall.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["args"] = "[AST_Node*] array of arguments";\n            return RS_d;\n        }).call(this);\n\n        function AST_Call() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Call.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Call, AST_BaseCall);\n        AST_Call.prototype.__init__ = function __init__ () {\n            AST_BaseCall.prototype.__init__ && AST_BaseCall.prototype.__init__.apply(this, arguments);\n        };\n        AST_Call.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var arg;\n                self.expression._walk(visitor);\n                var RS_Iter24 = RS_Iterable(self.args);\n                for (var RS_Index24 = 0; RS_Index24 < RS_Iter24.length; RS_Index24++) {\n                    arg = RS_Iter24[RS_Index24];\n                    arg._walk(visitor);\n                }\n                if (self.args.kwargs) {\n                    var RS_Iter25 = RS_Iterable(self.args.kwargs);\n                    for (var RS_Index25 = 0; RS_Index25 < RS_Iter25.length; RS_Index25++) {\n                        arg = RS_Iter25[RS_Index25];\n                        arg[0]._walk(visitor);\n                        arg[1]._walk(visitor);\n                    }\n                }\n                if (self.args.kwarg_items) {\n                    var RS_Iter26 = RS_Iterable(self.args.kwarg_items);\n                    for (var RS_Index26 = 0; RS_Index26 < RS_Iter26.length; RS_Index26++) {\n                        arg = RS_Iter26[RS_Index26];\n                        arg._walk(visitor);\n                    }\n                }\n            });\n        };\n        if (!AST_Call.prototype._walk.__argnames__) Object.defineProperties(AST_Call.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Call.prototype.__repr__ = function __repr__ () {\n            if(AST_BaseCall.prototype.__repr__) return AST_BaseCall.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Call.prototype.__str__ = function __str__ () {\n            if(AST_BaseCall.prototype.__str__) return AST_BaseCall.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Call.prototype, "__bases__", {value: [AST_BaseCall]});\n        AST_Call.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["expression"] = "[AST_Node] expression to invoke as function";\n            return RS_d;\n        }).call(this);\n\n        function AST_ClassCall() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ClassCall.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ClassCall, AST_BaseCall);\n        AST_ClassCall.prototype.__init__ = function __init__ () {\n            AST_BaseCall.prototype.__init__ && AST_BaseCall.prototype.__init__.apply(this, arguments);\n        };\n        AST_ClassCall.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var arg;\n                if (self.expression) self.expression._walk(visitor);\n                var RS_Iter27 = RS_Iterable(self.args);\n                for (var RS_Index27 = 0; RS_Index27 < RS_Iter27.length; RS_Index27++) {\n                    arg = RS_Iter27[RS_Index27];\n                    arg._walk(visitor);\n                }\n                var RS_Iter28 = RS_Iterable(self.args.kwargs);\n                for (var RS_Index28 = 0; RS_Index28 < RS_Iter28.length; RS_Index28++) {\n                    arg = RS_Iter28[RS_Index28];\n                    arg[0]._walk(visitor);\n                    arg[1]._walk(visitor);\n                }\n                var RS_Iter29 = RS_Iterable(self.args.kwarg_items);\n                for (var RS_Index29 = 0; RS_Index29 < RS_Iter29.length; RS_Index29++) {\n                    arg = RS_Iter29[RS_Index29];\n                    arg._walk(visitor);\n                }\n            });\n        };\n        if (!AST_ClassCall.prototype._walk.__argnames__) Object.defineProperties(AST_ClassCall.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_ClassCall.prototype.__repr__ = function __repr__ () {\n            if(AST_BaseCall.prototype.__repr__) return AST_BaseCall.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ClassCall.prototype.__str__ = function __str__ () {\n            if(AST_BaseCall.prototype.__str__) return AST_BaseCall.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ClassCall.prototype, "__bases__", {value: [AST_BaseCall]});\n        AST_ClassCall.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["class"] = "[string] name of the class method belongs to";\n            RS_d["method"] = "[string] class method being called";\n            RS_d["static"] = "[boolean] defines whether the method is static";\n            return RS_d;\n        }).call(this);\n\n        function AST_New() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_New.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_New, AST_Call);\n        AST_New.prototype.__init__ = function __init__ () {\n            AST_Call.prototype.__init__ && AST_Call.prototype.__init__.apply(this, arguments);\n        };\n        AST_New.prototype.__repr__ = function __repr__ () {\n            if(AST_Call.prototype.__repr__) return AST_Call.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_New.prototype.__str__ = function __str__ () {\n            if(AST_Call.prototype.__str__) return AST_Call.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_New.prototype, "__bases__", {value: [AST_Call]});\n\n        function AST_Seq() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Seq.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Seq, AST_Node);\n        AST_Seq.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Seq.prototype.to_array = function to_array() {\n            var self = this;\n            var p, a;\n            p = self;\n            a = RS_list_decorate([]);\n            while (p) {\n                a.push(p.car);\n                if (p.cdr && !is_node_type(p.cdr, AST_Seq)) {\n                    a.push(p.cdr);\n                    break;\n                }\n                p = p.cdr;\n            }\n            return a;\n        };\n        AST_Seq.prototype.add = function add(node) {\n            var self = this;\n            var p, cell;\n            p = self;\n            while (p) {\n                if (!is_node_type(p.cdr, AST_Seq)) {\n                    cell = AST_Seq.prototype.cons.call(p.cdr, node);\n                    return p.cdr = cell;\n                }\n                p = p.cdr;\n            }\n        };\n        if (!AST_Seq.prototype.add.__argnames__) Object.defineProperties(AST_Seq.prototype.add, {\n            __argnames__ : {value: ["node"]}\n        });\n        AST_Seq.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.car._walk(visitor);\n                if (self.cdr) {\n                    self.cdr._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Seq.prototype._walk.__argnames__) Object.defineProperties(AST_Seq.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Seq.prototype.cons = function cons(x, y) {\n            var self = this;\n            var seq;\n            seq = new AST_Seq(x);\n            seq.car = x;\n            seq.cdr = y;\n            return seq;\n        };\n        if (!AST_Seq.prototype.cons.__argnames__) Object.defineProperties(AST_Seq.prototype.cons, {\n            __argnames__ : {value: ["x", "y"]}\n        });\n        AST_Seq.prototype.from_array = function from_array(array) {\n            var self = this;\n            var ans, i, p;\n            if (array.length === 0) {\n                return null;\n            }\n            if (array.length === 1) {\n                return array[0].clone();\n            }\n            ans = null;\n            for (var RS_Index30 = array.length - 1; RS_Index30 > -1; RS_Index30-=1) {\n                i = RS_Index30;\n                ans = AST_Seq.prototype.cons.call(array[(typeof i === "number" && i < 0) ? array.length + i : i], ans);\n            }\n            p = ans;\n            while (p) {\n                if (p.cdr && !p.cdr.cdr) {\n                    p.cdr = p.cdr.car;\n                    break;\n                }\n                p = p.cdr;\n            }\n            return ans;\n        };\n        if (!AST_Seq.prototype.from_array.__argnames__) Object.defineProperties(AST_Seq.prototype.from_array, {\n            __argnames__ : {value: ["array"]}\n        });\n        AST_Seq.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Seq.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Seq.prototype, "__bases__", {value: [AST_Node]});\n        AST_Seq.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["car"] = "[AST_Node] first element in sequence";\n            RS_d["cdr"] = "[AST_Node] second element in sequence";\n            return RS_d;\n        }).call(this);\n\n        function AST_PropAccess() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_PropAccess.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_PropAccess, AST_Node);\n        AST_PropAccess.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_PropAccess.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_PropAccess.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_PropAccess.prototype, "__bases__", {value: [AST_Node]});\n        AST_PropAccess.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["expression"] = "[AST_Node] the “container” expression";\n            RS_d["property"] = "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it\'s an arbitrary AST_Node";\n            return RS_d;\n        }).call(this);\n\n        function AST_Dot() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Dot.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Dot, AST_PropAccess);\n        AST_Dot.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_Dot.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n            });\n        };\n        if (!AST_Dot.prototype._walk.__argnames__) Object.defineProperties(AST_Dot.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Dot.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Dot.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Dot.prototype, "__bases__", {value: [AST_PropAccess]});\n\n        function AST_Sub() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Sub.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Sub, AST_PropAccess);\n        AST_Sub.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_Sub.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                self.property._walk(visitor);\n            });\n        };\n        if (!AST_Sub.prototype._walk.__argnames__) Object.defineProperties(AST_Sub.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Sub.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Sub.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Sub.prototype, "__bases__", {value: [AST_PropAccess]});\n\n        function AST_ItemAccess() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ItemAccess.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ItemAccess, AST_PropAccess);\n        AST_ItemAccess.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_ItemAccess.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                self.property._walk(visitor);\n                if (self.assignment) {\n                    self.assignment._walk(visitor);\n                }\n            });\n        };\n        if (!AST_ItemAccess.prototype._walk.__argnames__) Object.defineProperties(AST_ItemAccess.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_ItemAccess.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ItemAccess.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ItemAccess.prototype, "__bases__", {value: [AST_PropAccess]});\n        AST_ItemAccess.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["assignment"] = "[AST_Node or None] Not None if this is an assignment (a[x] = y) rather than a simple access";\n            return RS_d;\n        }).call(this);\n\n        function AST_Splice() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Splice.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Splice, AST_PropAccess);\n        AST_Splice.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_Splice.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                self.property._walk(visitor);\n                self.property2._walk(visitor);\n            });\n        };\n        if (!AST_Splice.prototype._walk.__argnames__) Object.defineProperties(AST_Splice.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Splice.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Splice.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Splice.prototype, "__bases__", {value: [AST_PropAccess]});\n        AST_Splice.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["property2"] = "[AST_Node] the 2nd property to access - typically ending index for the array.";\n            RS_d["assignment"] = "[AST_Node] The data being spliced in.";\n            return RS_d;\n        }).call(this);\n\n        function AST_Unary() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Unary.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Unary, AST_Node);\n        AST_Unary.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Unary.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n            });\n        };\n        if (!AST_Unary.prototype._walk.__argnames__) Object.defineProperties(AST_Unary.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Unary.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Unary.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Unary.prototype, "__bases__", {value: [AST_Node]});\n        AST_Unary.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["operator"] = "[string] the operator";\n            RS_d["expression"] = "[AST_Node] expression that this unary operator applies to";\n            RS_d["parenthesized"] = "[bool] Whether this unary expression was parenthesized";\n            return RS_d;\n        }).call(this);\n\n        function AST_UnaryPrefix() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_UnaryPrefix.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_UnaryPrefix, AST_Unary);\n        AST_UnaryPrefix.prototype.__init__ = function __init__ () {\n            AST_Unary.prototype.__init__ && AST_Unary.prototype.__init__.apply(this, arguments);\n        };\n        AST_UnaryPrefix.prototype.__repr__ = function __repr__ () {\n            if(AST_Unary.prototype.__repr__) return AST_Unary.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_UnaryPrefix.prototype.__str__ = function __str__ () {\n            if(AST_Unary.prototype.__str__) return AST_Unary.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_UnaryPrefix.prototype, "__bases__", {value: [AST_Unary]});\n\n        function AST_Binary() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Binary.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Binary, AST_Node);\n        AST_Binary.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Binary.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.left._walk(visitor);\n                self.right._walk(visitor);\n            });\n        };\n        if (!AST_Binary.prototype._walk.__argnames__) Object.defineProperties(AST_Binary.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Binary.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Binary.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Binary.prototype, "__bases__", {value: [AST_Node]});\n        AST_Binary.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["left"] = "[AST_Node] left-hand side expression";\n            RS_d["operator"] = "[string] the operator";\n            RS_d["right"] = "[AST_Node] right-hand side expression";\n            return RS_d;\n        }).call(this);\n\n        function AST_Existential() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Existential.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Existential, AST_Node);\n        AST_Existential.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Existential.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                if (self.after !== null && typeof self.after === "object") {\n                    self.after._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Existential.prototype._walk.__argnames__) Object.defineProperties(AST_Existential.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Existential.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Existential.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Existential.prototype, "__bases__", {value: [AST_Node]});\n        AST_Existential.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["expression"] = "[AST_Node] The expression whose existence we need to check";\n            RS_d["after"] = "[None|string|AST_Node] is None when there is nothing following this operator, is a string when there is as AST_PropAccess following this operator, is an AST_Node if it is used a a shorthand for the conditional ternary, i.e. a ? b == a if a? else b";\n            return RS_d;\n        }).call(this);\n\n        function AST_Conditional() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Conditional.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Conditional, AST_Node);\n        AST_Conditional.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Conditional.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                self.consequent._walk(visitor);\n                self.alternative._walk(visitor);\n            });\n        };\n        if (!AST_Conditional.prototype._walk.__argnames__) Object.defineProperties(AST_Conditional.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Conditional.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Conditional.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Conditional.prototype, "__bases__", {value: [AST_Node]});\n        AST_Conditional.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["condition"] = "[AST_Node]";\n            RS_d["consequent"] = "[AST_Node]";\n            RS_d["alternative"] = "[AST_Node]";\n            return RS_d;\n        }).call(this);\n\n        function AST_Assign() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Assign.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Assign, AST_Binary);\n        AST_Assign.prototype.__init__ = function __init__ () {\n            AST_Binary.prototype.__init__ && AST_Binary.prototype.__init__.apply(this, arguments);\n        };\n        AST_Assign.prototype.is_chained = function is_chained() {\n            var self = this;\n            return is_node_type(self.right, AST_Assign) || is_node_type(self.right, AST_Seq) && (is_node_type(self.right.car, AST_Assign) || is_node_type(self.right.cdr, AST_Assign));\n        };\n        AST_Assign.prototype.traverse_chain = function traverse_chain() {\n            var self = this;\n            var right, left_hand_sides, next, assign;\n            right = self.right;\n            while (true) {\n                if (is_node_type(right, AST_Assign)) {\n                    right = right.right;\n                    continue;\n                }\n                if (is_node_type(right, AST_Seq)) {\n                    if (is_node_type(right.car, AST_Assign)) {\n                        right = new AST_Seq((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["car"] = right.car.right;\n                            RS_d["cdr"] = right.cdr;\n                            return RS_d;\n                        }).call(this));\n                        continue;\n                    }\n                    if (is_node_type(right.cdr, AST_Assign)) {\n                        right = right.cdr.right;\n                        continue;\n                    }\n                }\n                break;\n            }\n            left_hand_sides = [self.left];\n            next = self.right;\n            while (true) {\n                if (is_node_type(next, AST_Assign)) {\n                    left_hand_sides.push(next.left);\n                    next = next.right;\n                    continue;\n                }\n                if (is_node_type(next, AST_Seq)) {\n                    if (is_node_type(next.cdr, AST_Assign)) {\n                        assign = next.cdr;\n                        left_hand_sides.push(new AST_Seq((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["car"] = next.car;\n                            RS_d["cdr"] = assign.left;\n                            return RS_d;\n                        }).call(this)));\n                        next = assign.right;\n                        continue;\n                    }\n                }\n                break;\n            }\n            return [left_hand_sides, right];\n        };\n        AST_Assign.prototype.__repr__ = function __repr__ () {\n            if(AST_Binary.prototype.__repr__) return AST_Binary.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Assign.prototype.__str__ = function __str__ () {\n            if(AST_Binary.prototype.__str__) return AST_Binary.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Assign.prototype, "__bases__", {value: [AST_Binary]});\n\n        function AST_Array() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Array.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Array, AST_Node);\n        AST_Array.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Array.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var el;\n                var RS_Iter31 = RS_Iterable(self.elements);\n                for (var RS_Index31 = 0; RS_Index31 < RS_Iter31.length; RS_Index31++) {\n                    el = RS_Iter31[RS_Index31];\n                    el._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Array.prototype._walk.__argnames__) Object.defineProperties(AST_Array.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Array.prototype.flatten = function flatten() {\n            var self = this;\n            function flatten(arr) {\n                var ans, value;\n                ans = RS_list_decorate([]);\n                var RS_Iter32 = RS_Iterable(arr);\n                for (var RS_Index32 = 0; RS_Index32 < RS_Iter32.length; RS_Index32++) {\n                    value = RS_Iter32[RS_Index32];\n                    if (is_node_type(value, AST_Seq)) {\n                        value = value.to_array();\n                    } else if (is_node_type(value, AST_Array)) {\n                        value = value.elements;\n                    }\n                    if (Array.isArray(value)) {\n                        ans = ans.concat(flatten(value));\n                    } else {\n                        ans.push(value);\n                    }\n                }\n                return ans;\n            };\n            if (!flatten.__argnames__) Object.defineProperties(flatten, {\n                __argnames__ : {value: ["arr"]}\n            });\n\n            return flatten(self.elements);\n        };\n        AST_Array.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Array.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Array.prototype, "__bases__", {value: [AST_Node]});\n        AST_Array.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["elements"] = "[AST_Node*] array of elements";\n            return RS_d;\n        }).call(this);\n\n        function AST_Object() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Object.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Object, AST_Node);\n        AST_Object.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Object.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var prop;\n                var RS_Iter33 = RS_Iterable(self.properties);\n                for (var RS_Index33 = 0; RS_Index33 < RS_Iter33.length; RS_Index33++) {\n                    prop = RS_Iter33[RS_Index33];\n                    prop._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Object.prototype._walk.__argnames__) Object.defineProperties(AST_Object.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Object.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Object.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Object.prototype, "__bases__", {value: [AST_Node]});\n        AST_Object.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["properties"] = "[AST_ObjectProperty*] array of properties";\n            RS_d["is_pydict"] = "[bool] True if this object is a python dict literal";\n            RS_d["is_jshash"] = "[bool] True if this object is a js hash literal";\n            return RS_d;\n        }).call(this);\n\n        function AST_ExpressiveObject() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ExpressiveObject.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ExpressiveObject, AST_Object);\n        AST_ExpressiveObject.prototype.__init__ = function __init__ () {\n            AST_Object.prototype.__init__ && AST_Object.prototype.__init__.apply(this, arguments);\n        };\n        AST_ExpressiveObject.prototype.__repr__ = function __repr__ () {\n            if(AST_Object.prototype.__repr__) return AST_Object.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ExpressiveObject.prototype.__str__ = function __str__ () {\n            if(AST_Object.prototype.__str__) return AST_Object.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ExpressiveObject.prototype, "__bases__", {value: [AST_Object]});\n\n        function AST_ObjectProperty() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ObjectProperty.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ObjectProperty, AST_Node);\n        AST_ObjectProperty.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_ObjectProperty.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.key._walk(visitor);\n                self.value._walk(visitor);\n            });\n        };\n        if (!AST_ObjectProperty.prototype._walk.__argnames__) Object.defineProperties(AST_ObjectProperty.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_ObjectProperty.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ObjectProperty.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ObjectProperty.prototype, "__bases__", {value: [AST_Node]});\n        AST_ObjectProperty.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["key"] = "[AST_Node] the property expression";\n            RS_d["value"] = "[AST_Node] property value.  For setters and getters this is an AST_Function.";\n            RS_d["quoted"] = "";\n            return RS_d;\n        }).call(this);\n\n        function AST_ObjectKeyVal() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ObjectKeyVal.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ObjectKeyVal, AST_ObjectProperty);\n        AST_ObjectKeyVal.prototype.__init__ = function __init__ () {\n            AST_ObjectProperty.prototype.__init__ && AST_ObjectProperty.prototype.__init__.apply(this, arguments);\n        };\n        AST_ObjectKeyVal.prototype.__repr__ = function __repr__ () {\n            if(AST_ObjectProperty.prototype.__repr__) return AST_ObjectProperty.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ObjectKeyVal.prototype.__str__ = function __str__ () {\n            if(AST_ObjectProperty.prototype.__str__) return AST_ObjectProperty.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ObjectKeyVal.prototype, "__bases__", {value: [AST_ObjectProperty]});\n\n        function AST_Set() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Set.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Set, AST_Node);\n        AST_Set.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Set.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var prop;\n                var RS_Iter34 = RS_Iterable(self.items);\n                for (var RS_Index34 = 0; RS_Index34 < RS_Iter34.length; RS_Index34++) {\n                    prop = RS_Iter34[RS_Index34];\n                    prop._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Set.prototype._walk.__argnames__) Object.defineProperties(AST_Set.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_Set.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Set.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Set.prototype, "__bases__", {value: [AST_Node]});\n        AST_Set.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["items"] = "[AST_SetItem*] array of items";\n            return RS_d;\n        }).call(this);\n\n        function AST_SetItem() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SetItem.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SetItem, AST_Node);\n        AST_SetItem.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_SetItem.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.value._walk(visitor);\n            });\n        };\n        if (!AST_SetItem.prototype._walk.__argnames__) Object.defineProperties(AST_SetItem.prototype._walk, {\n            __argnames__ : {value: ["visitor"]}\n        });\n        AST_SetItem.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SetItem.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SetItem.prototype, "__bases__", {value: [AST_Node]});\n        AST_SetItem.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[AST_Node] The value of this item";\n            return RS_d;\n        }).call(this);\n\n        function AST_Symbol() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Symbol.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Symbol, AST_Node);\n        AST_Symbol.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Symbol.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Symbol.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Symbol.prototype, "__bases__", {value: [AST_Node]});\n        AST_Symbol.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["name"] = "[string] name of this symbol";\n            RS_d["scope"] = "[AST_Scope/S] the current scope (not necessarily the definition scope)";\n            RS_d["thedef"] = "[SymbolDef/S] the definition of this symbol";\n            return RS_d;\n        }).call(this);\n\n        function AST_SymbolAlias() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolAlias.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolAlias, AST_Symbol);\n        AST_SymbolAlias.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolAlias.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolAlias.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolAlias.prototype, "__bases__", {value: [AST_Symbol]});\n\n        function AST_SymbolDeclaration() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolDeclaration, AST_Symbol);\n        AST_SymbolDeclaration.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolDeclaration.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolDeclaration.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolDeclaration.prototype, "__bases__", {value: [AST_Symbol]});\n        AST_SymbolDeclaration.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["init"] = "[AST_Node*/S] array of initializers for this declaration.";\n            return RS_d;\n        }).call(this);\n\n        function AST_SymbolVar() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolVar.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolVar, AST_SymbolDeclaration);\n        AST_SymbolVar.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolVar.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolVar.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolVar.prototype, "__bases__", {value: [AST_SymbolDeclaration]});\n\n        function AST_ImportedVar() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_ImportedVar.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_ImportedVar, AST_SymbolVar);\n        AST_ImportedVar.prototype.__init__ = function __init__ () {\n            AST_SymbolVar.prototype.__init__ && AST_SymbolVar.prototype.__init__.apply(this, arguments);\n        };\n        AST_ImportedVar.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolVar.prototype.__repr__) return AST_SymbolVar.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_ImportedVar.prototype.__str__ = function __str__ () {\n            if(AST_SymbolVar.prototype.__str__) return AST_SymbolVar.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ImportedVar.prototype, "__bases__", {value: [AST_SymbolVar]});\n        AST_ImportedVar.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["alias"] = "AST_SymbolAlias the alias for this imported symbol";\n            return RS_d;\n        }).call(this);\n\n        function AST_SymbolNonlocal() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolNonlocal.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolNonlocal, AST_SymbolDeclaration);\n        AST_SymbolNonlocal.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolNonlocal.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolNonlocal.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolNonlocal.prototype, "__bases__", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolFunarg() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolFunarg.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolFunarg, AST_SymbolVar);\n        AST_SymbolFunarg.prototype.__init__ = function __init__ () {\n            AST_SymbolVar.prototype.__init__ && AST_SymbolVar.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolFunarg.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolVar.prototype.__repr__) return AST_SymbolVar.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolFunarg.prototype.__str__ = function __str__ () {\n            if(AST_SymbolVar.prototype.__str__) return AST_SymbolVar.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolFunarg.prototype, "__bases__", {value: [AST_SymbolVar]});\n        AST_SymbolFunarg.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["annotation"] = "[AST_Node?] The annotation provided for this argument (if any)";\n            return RS_d;\n        }).call(this);\n\n        function AST_SymbolDefun() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolDefun.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolDefun, AST_SymbolDeclaration);\n        AST_SymbolDefun.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolDefun.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolDefun.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolDefun.prototype, "__bases__", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolLambda() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolLambda.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolLambda, AST_SymbolDeclaration);\n        AST_SymbolLambda.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolLambda.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolLambda.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolLambda.prototype, "__bases__", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolCatch() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolCatch.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolCatch, AST_SymbolDeclaration);\n        AST_SymbolCatch.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolCatch.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolCatch.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolCatch.prototype, "__bases__", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolRef() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_SymbolRef.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_SymbolRef, AST_Symbol);\n        AST_SymbolRef.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolRef.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_SymbolRef.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolRef.prototype, "__bases__", {value: [AST_Symbol]});\n        AST_SymbolRef.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["parens"] = "[boolean/S] if true, this variable is wrapped in parentheses";\n            return RS_d;\n        }).call(this);\n\n        function AST_This() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_This.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_This, AST_Symbol);\n        AST_This.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_This.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_This.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_This.prototype, "__bases__", {value: [AST_Symbol]});\n\n        function AST_Constant() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Constant.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Constant, AST_Node);\n        AST_Constant.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Constant.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Constant.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Constant.prototype, "__bases__", {value: [AST_Node]});\n\n        function AST_String() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_String.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_String, AST_Constant);\n        AST_String.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_String.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_String.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_String.prototype, "__bases__", {value: [AST_Constant]});\n        AST_String.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[string] the contents of this string";\n            return RS_d;\n        }).call(this);\n\n        function AST_Verbatim() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Verbatim.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Verbatim, AST_Constant);\n        AST_Verbatim.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_Verbatim.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Verbatim.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Verbatim.prototype, "__bases__", {value: [AST_Constant]});\n        AST_Verbatim.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[string] A string of raw JS code";\n            return RS_d;\n        }).call(this);\n\n        function AST_Number() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Number.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Number, AST_Constant);\n        AST_Number.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_Number.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Number.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Number.prototype, "__bases__", {value: [AST_Constant]});\n        AST_Number.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[number] the numeric value";\n            return RS_d;\n        }).call(this);\n\n        function AST_RegExp() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_RegExp.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_RegExp, AST_Constant);\n        AST_RegExp.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_RegExp.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_RegExp.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_RegExp.prototype, "__bases__", {value: [AST_Constant]});\n        AST_RegExp.prototype.properties = (function(){\n            var RS_d = Object.create(null);\n            RS_d["value"] = "[RegExp] the actual regexp";\n            return RS_d;\n        }).call(this);\n\n        function AST_Atom() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Atom.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Atom, AST_Constant);\n        AST_Atom.prototype.__init__ = function __init__(initializer) {\n            var self = this;\n            if (initializer) {\n                self.start = initializer.start;\n                self.end = initializer.end;\n            }\n        };\n        if (!AST_Atom.prototype.__init__.__argnames__) Object.defineProperties(AST_Atom.prototype.__init__, {\n            __argnames__ : {value: ["initializer"]}\n        });\n        AST_Atom.__argnames__ = AST_Atom.prototype.__init__.__argnames__;\n        AST_Atom.__handles_kwarg_interpolation__ = AST_Atom.prototype.__init__.__handles_kwarg_interpolation__;\n        AST_Atom.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Atom.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Atom.prototype, "__bases__", {value: [AST_Constant]});\n\n        function AST_Null() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Null.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Null, AST_Atom);\n        AST_Null.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Null.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Null.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Null.prototype, "__bases__", {value: [AST_Atom]});\n        AST_Null.prototype.value = null;\n\n        function AST_NaN() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_NaN.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_NaN, AST_Atom);\n        AST_NaN.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_NaN.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_NaN.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_NaN.prototype, "__bases__", {value: [AST_Atom]});\n        AST_NaN.prototype.value = NaN;\n\n        function AST_Undefined() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Undefined.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Undefined, AST_Atom);\n        AST_Undefined.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Undefined.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Undefined.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Undefined.prototype, "__bases__", {value: [AST_Atom]});\n        AST_Undefined.prototype.value = undefined;\n\n        function AST_Hole() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Hole.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Hole, AST_Atom);\n        AST_Hole.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Hole.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Hole.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Hole.prototype, "__bases__", {value: [AST_Atom]});\n        AST_Hole.prototype.value = undefined;\n\n        function AST_Infinity() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Infinity.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Infinity, AST_Atom);\n        AST_Infinity.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Infinity.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Infinity.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Infinity.prototype, "__bases__", {value: [AST_Atom]});\n        AST_Infinity.prototype.value = Infinity;\n\n        function AST_Boolean() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_Boolean.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_Boolean, AST_Atom);\n        AST_Boolean.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Boolean.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_Boolean.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Boolean.prototype, "__bases__", {value: [AST_Atom]});\n\n        function AST_False() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_False.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_False, AST_Boolean);\n        AST_False.prototype.__init__ = function __init__ () {\n            AST_Boolean.prototype.__init__ && AST_Boolean.prototype.__init__.apply(this, arguments);\n        };\n        AST_False.prototype.__repr__ = function __repr__ () {\n            if(AST_Boolean.prototype.__repr__) return AST_Boolean.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_False.prototype.__str__ = function __str__ () {\n            if(AST_Boolean.prototype.__str__) return AST_Boolean.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_False.prototype, "__bases__", {value: [AST_Boolean]});\n        AST_False.prototype.value = false;\n\n        function AST_True() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            AST_True.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(AST_True, AST_Boolean);\n        AST_True.prototype.__init__ = function __init__ () {\n            AST_Boolean.prototype.__init__ && AST_Boolean.prototype.__init__.apply(this, arguments);\n        };\n        AST_True.prototype.__repr__ = function __repr__ () {\n            if(AST_Boolean.prototype.__repr__) return AST_Boolean.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        AST_True.prototype.__str__ = function __str__ () {\n            if(AST_Boolean.prototype.__str__) return AST_Boolean.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_True.prototype, "__bases__", {value: [AST_Boolean]});\n        AST_True.prototype.value = true;\n\n        function TreeWalker() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            TreeWalker.prototype.__init__.apply(this, arguments);\n        }\n        TreeWalker.prototype.__init__ = function __init__(callback) {\n            var self = this;\n            self.visit = callback;\n            self.stack = RS_list_decorate([]);\n        };\n        if (!TreeWalker.prototype.__init__.__argnames__) Object.defineProperties(TreeWalker.prototype.__init__, {\n            __argnames__ : {value: ["callback"]}\n        });\n        TreeWalker.__argnames__ = TreeWalker.prototype.__init__.__argnames__;\n        TreeWalker.__handles_kwarg_interpolation__ = TreeWalker.prototype.__init__.__handles_kwarg_interpolation__;\n        TreeWalker.prototype._visit = function _visit(node, descend) {\n            var self = this;\n            var ret;\n            self.stack.push(node);\n            ret = self.visit(node, (descend) ? function () {\n                descend.call(node);\n            } : noop);\n            if (!ret && descend) {\n                descend.call(node);\n            }\n            self.stack.pop();\n            return ret;\n        };\n        if (!TreeWalker.prototype._visit.__argnames__) Object.defineProperties(TreeWalker.prototype._visit, {\n            __argnames__ : {value: ["node", "descend"]}\n        });\n        TreeWalker.prototype.parent = function parent(n) {\n            var self = this;\n            return (RS_expr_temp = self.stack)[RS_bound_index(self.stack.length - 2 - (n || 0), RS_expr_temp)];\n        };\n        if (!TreeWalker.prototype.parent.__argnames__) Object.defineProperties(TreeWalker.prototype.parent, {\n            __argnames__ : {value: ["n"]}\n        });\n        TreeWalker.prototype.push = function push(node) {\n            var self = this;\n            self.stack.push(node);\n        };\n        if (!TreeWalker.prototype.push.__argnames__) Object.defineProperties(TreeWalker.prototype.push, {\n            __argnames__ : {value: ["node"]}\n        });\n        TreeWalker.prototype.pop = function pop() {\n            var self = this;\n            return self.stack.pop();\n        };\n        TreeWalker.prototype.self = function self() {\n            var s = this;\n            return (RS_expr_temp = s.stack)[RS_bound_index(s.stack.length - 1, RS_expr_temp)];\n        };\n        TreeWalker.prototype.find_parent = function find_parent(type) {\n            var self = this;\n            var stack, x, i;\n            stack = self.stack;\n            for (var RS_Index35 = stack.length - 1; RS_Index35 > -1; RS_Index35-=1) {\n                i = RS_Index35;\n                x = stack[(typeof i === "number" && i < 0) ? stack.length + i : i];\n                if (is_node_type(x, type)) {\n                    return x;\n                }\n            }\n        };\n        if (!TreeWalker.prototype.find_parent.__argnames__) Object.defineProperties(TreeWalker.prototype.find_parent, {\n            __argnames__ : {value: ["type"]}\n        });\n        TreeWalker.prototype.in_boolean_context = function in_boolean_context() {\n            var self = this;\n            var stack, i, p;\n            stack = self.stack;\n            i = stack.length;\n            self = stack[RS_bound_index(i -= 1, stack)];\n            while (i > 0) {\n                p = stack[RS_bound_index(i -= 1, stack)];\n                if (is_node_type(p, AST_If) && p.condition === self || is_node_type(p, AST_Conditional) && p.condition === self || is_node_type(p, AST_DWLoop) && p.condition === self || is_node_type(p, AST_UnaryPrefix) && p.operator === "!" && p.expression === self) {\n                    return true;\n                }\n                if (!(is_node_type(p, AST_Binary) && (p.operator === "&&" || p.operator === "||"))) {\n                    return false;\n                }\n                self = p;\n            }\n        };\n        TreeWalker.prototype.__repr__ = function __repr__ () {\n                        return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        TreeWalker.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        Object.defineProperty(TreeWalker.prototype, "__bases__", {value: []});\n\n        function Found() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            Found.prototype.__init__.apply(this, arguments);\n        }\n        RS_extends(Found, Exception);\n        Found.prototype.__init__ = function __init__ () {\n            Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n        };\n        Found.prototype.__repr__ = function __repr__ () {\n            if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n            return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        Found.prototype.__str__ = function __str__ () {\n            if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(Found.prototype, "__bases__", {value: [Exception]});\n        \n\n        function has_calls(expression) {\n            if (!expression) {\n                return false;\n            }\n            try {\n                expression.walk(new TreeWalker((function() {\n                    var RS_anonfunc = function (node) {\n                        if (is_node_type(node, AST_BaseCall) || is_node_type(node, AST_ItemAccess)) {\n                            throw new Found;\n                        }\n                    };\n                    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                        __argnames__ : {value: ["node"]}\n                    });\n                    return RS_anonfunc;\n                })()));\n            } catch (RS_Exception) {\n                RS_last_exception = RS_Exception;\n                if (RS_Exception instanceof Found) {\n                    return true;\n                } else {\n                    throw RS_Exception;\n                }\n            }\n            return false;\n        };\n        if (!has_calls.__argnames__) Object.defineProperties(has_calls, {\n            __argnames__ : {value: ["expression"]}\n        });\n\n        RS_modules.ast.is_node_type = is_node_type;\n        RS_modules.ast.AST = AST;\n        RS_modules.ast.AST_Token = AST_Token;\n        RS_modules.ast.AST_Node = AST_Node;\n        RS_modules.ast.AST_Statement = AST_Statement;\n        RS_modules.ast.AST_Debugger = AST_Debugger;\n        RS_modules.ast.AST_Directive = AST_Directive;\n        RS_modules.ast.AST_SimpleStatement = AST_SimpleStatement;\n        RS_modules.ast.AST_Assert = AST_Assert;\n        RS_modules.ast.walk_body = walk_body;\n        RS_modules.ast.AST_Block = AST_Block;\n        RS_modules.ast.AST_BlockStatement = AST_BlockStatement;\n        RS_modules.ast.AST_EmptyStatement = AST_EmptyStatement;\n        RS_modules.ast.AST_StatementWithBody = AST_StatementWithBody;\n        RS_modules.ast.AST_DWLoop = AST_DWLoop;\n        RS_modules.ast.AST_Do = AST_Do;\n        RS_modules.ast.AST_While = AST_While;\n        RS_modules.ast.AST_ForIn = AST_ForIn;\n        RS_modules.ast.AST_ForJS = AST_ForJS;\n        RS_modules.ast.AST_ListComprehension = AST_ListComprehension;\n        RS_modules.ast.AST_SetComprehension = AST_SetComprehension;\n        RS_modules.ast.AST_DictComprehension = AST_DictComprehension;\n        RS_modules.ast.AST_GeneratorComprehension = AST_GeneratorComprehension;\n        RS_modules.ast.AST_With = AST_With;\n        RS_modules.ast.AST_WithClause = AST_WithClause;\n        RS_modules.ast.AST_Scope = AST_Scope;\n        RS_modules.ast.AST_Toplevel = AST_Toplevel;\n        RS_modules.ast.AST_Import = AST_Import;\n        RS_modules.ast.AST_Imports = AST_Imports;\n        RS_modules.ast.AST_Decorator = AST_Decorator;\n        RS_modules.ast.AST_Lambda = AST_Lambda;\n        RS_modules.ast.AST_Function = AST_Function;\n        RS_modules.ast.AST_Class = AST_Class;\n        RS_modules.ast.AST_Method = AST_Method;\n        RS_modules.ast.AST_Jump = AST_Jump;\n        RS_modules.ast.AST_Exit = AST_Exit;\n        RS_modules.ast.AST_Return = AST_Return;\n        RS_modules.ast.AST_Yield = AST_Yield;\n        RS_modules.ast.AST_Throw = AST_Throw;\n        RS_modules.ast.AST_LoopControl = AST_LoopControl;\n        RS_modules.ast.AST_Break = AST_Break;\n        RS_modules.ast.AST_Continue = AST_Continue;\n        RS_modules.ast.AST_If = AST_If;\n        RS_modules.ast.AST_Try = AST_Try;\n        RS_modules.ast.AST_Catch = AST_Catch;\n        RS_modules.ast.AST_Except = AST_Except;\n        RS_modules.ast.AST_Finally = AST_Finally;\n        RS_modules.ast.AST_Else = AST_Else;\n        RS_modules.ast.AST_Definitions = AST_Definitions;\n        RS_modules.ast.AST_Var = AST_Var;\n        RS_modules.ast.AST_VarDef = AST_VarDef;\n        RS_modules.ast.AST_BaseCall = AST_BaseCall;\n        RS_modules.ast.AST_Call = AST_Call;\n        RS_modules.ast.AST_ClassCall = AST_ClassCall;\n        RS_modules.ast.AST_New = AST_New;\n        RS_modules.ast.AST_Seq = AST_Seq;\n        RS_modules.ast.AST_PropAccess = AST_PropAccess;\n        RS_modules.ast.AST_Dot = AST_Dot;\n        RS_modules.ast.AST_Sub = AST_Sub;\n        RS_modules.ast.AST_ItemAccess = AST_ItemAccess;\n        RS_modules.ast.AST_Splice = AST_Splice;\n        RS_modules.ast.AST_Unary = AST_Unary;\n        RS_modules.ast.AST_UnaryPrefix = AST_UnaryPrefix;\n        RS_modules.ast.AST_Binary = AST_Binary;\n        RS_modules.ast.AST_Existential = AST_Existential;\n        RS_modules.ast.AST_Conditional = AST_Conditional;\n        RS_modules.ast.AST_Assign = AST_Assign;\n        RS_modules.ast.AST_Array = AST_Array;\n        RS_modules.ast.AST_Object = AST_Object;\n        RS_modules.ast.AST_ExpressiveObject = AST_ExpressiveObject;\n        RS_modules.ast.AST_ObjectProperty = AST_ObjectProperty;\n        RS_modules.ast.AST_ObjectKeyVal = AST_ObjectKeyVal;\n        RS_modules.ast.AST_Set = AST_Set;\n        RS_modules.ast.AST_SetItem = AST_SetItem;\n        RS_modules.ast.AST_Symbol = AST_Symbol;\n        RS_modules.ast.AST_SymbolAlias = AST_SymbolAlias;\n        RS_modules.ast.AST_SymbolDeclaration = AST_SymbolDeclaration;\n        RS_modules.ast.AST_SymbolVar = AST_SymbolVar;\n        RS_modules.ast.AST_ImportedVar = AST_ImportedVar;\n        RS_modules.ast.AST_SymbolNonlocal = AST_SymbolNonlocal;\n        RS_modules.ast.AST_SymbolFunarg = AST_SymbolFunarg;\n        RS_modules.ast.AST_SymbolDefun = AST_SymbolDefun;\n        RS_modules.ast.AST_SymbolLambda = AST_SymbolLambda;\n        RS_modules.ast.AST_SymbolCatch = AST_SymbolCatch;\n        RS_modules.ast.AST_SymbolRef = AST_SymbolRef;\n        RS_modules.ast.AST_This = AST_This;\n        RS_modules.ast.AST_Constant = AST_Constant;\n        RS_modules.ast.AST_String = AST_String;\n        RS_modules.ast.AST_Verbatim = AST_Verbatim;\n        RS_modules.ast.AST_Number = AST_Number;\n        RS_modules.ast.AST_RegExp = AST_RegExp;\n        RS_modules.ast.AST_Atom = AST_Atom;\n        RS_modules.ast.AST_Null = AST_Null;\n        RS_modules.ast.AST_NaN = AST_NaN;\n        RS_modules.ast.AST_Undefined = AST_Undefined;\n        RS_modules.ast.AST_Hole = AST_Hole;\n        RS_modules.ast.AST_Infinity = AST_Infinity;\n        RS_modules.ast.AST_Boolean = AST_Boolean;\n        RS_modules.ast.AST_False = AST_False;\n        RS_modules.ast.AST_True = AST_True;\n        RS_modules.ast.TreeWalker = TreeWalker;\n        RS_modules.ast.Found = Found;\n        RS_modules.ast.has_calls = has_calls;\n    })();\n\n    (function(){\n        var __name__ = "string_interpolation";\n        function quoted_string(x) {\n            return "\\"" + x.replace(/\\\\/g, "\\\\\\\\").replace(/"/g, "\\\\\\"").replace(/\\n/g, "\\\\n") + "\\"";\n        };\n        if (!quoted_string.__argnames__) Object.defineProperties(quoted_string, {\n            __argnames__ : {value: ["x"]}\n        });\n\n        function render_markup(markup) {\n            var RS_unpack, pos, key, ch, fmtspec;\n            RS_unpack = [0, ""];\n            pos = RS_unpack[0];\n            key = RS_unpack[1];\n            while (pos < markup.length) {\n                ch = markup[(typeof pos === "number" && pos < 0) ? markup.length + pos : pos];\n                if (ch === "!" || ch === ":") {\n                    break;\n                }\n                key += ch;\n                pos += 1;\n            }\n            fmtspec = markup.slice(pos);\n            return "RS_str.format(\\"{" + fmtspec + "}\\", " + key + ")";\n        };\n        if (!render_markup.__argnames__) Object.defineProperties(render_markup, {\n            __argnames__ : {value: ["markup"]}\n        });\n\n        function interpolate(template, raise_error) {\n            var pos, in_brace, markup, ans, ch;\n            pos = in_brace = 0;\n            markup = "";\n            ans = [""];\n            while (pos < template.length) {\n                ch = template[(typeof pos === "number" && pos < 0) ? template.length + pos : pos];\n                if (in_brace) {\n                    if (ch === "{") {\n                        in_brace += 1;\n                        markup += "{";\n                    } else if (ch === "}") {\n                        in_brace -= 1;\n                        if (in_brace > 0) {\n                            markup += "}";\n                        } else {\n                            ans.push([markup]);\n                            ans.push("");\n                        }\n                    } else {\n                        markup += ch;\n                    }\n                } else {\n                    if (ch === "{") {\n                        if (template[RS_bound_index(pos + 1, template)] === "{") {\n                            pos += 1;\n                            ans[ans.length-1] += "{";\n                        } else {\n                            in_brace = 1;\n                            markup = "";\n                        }\n                    } else if (ch === "}") {\n                        if (template[RS_bound_index(pos + 1, template)] === "}") {\n                            pos += 1;\n                            ans[ans.length-1] += "}";\n                        } else {\n                            raise_error("f-string: single \'}\' is not allowed");\n                        }\n                    } else {\n                        ans[ans.length-1] += ch;\n                    }\n                }\n                pos += 1;\n            }\n            if (in_brace) {\n                raise_error("expected \'}\' before end of string");\n            }\n            if (ans[ans.length-1] === "+") {\n                ans[ans.length-1] = "";\n            }\n            for (var i = 0; i < ans.length; i++) {\n                if (typeof ans[(typeof i === "number" && i < 0) ? ans.length + i : i] === "string") {\n                    ans[(typeof i === "number" && i < 0) ? ans.length + i : i] = quoted_string(ans[(typeof i === "number" && i < 0) ? ans.length + i : i]);\n                } else {\n                    ans[(typeof i === "number" && i < 0) ? ans.length + i : i] = "+" + render_markup.apply(this, ans[(typeof i === "number" && i < 0) ? ans.length + i : i]) + "+";\n                }\n            }\n            return ans.join("");\n        };\n        if (!interpolate.__argnames__) Object.defineProperties(interpolate, {\n            __argnames__ : {value: ["template", "raise_error"]}\n        });\n\n        RS_modules.string_interpolation.quoted_string = quoted_string;\n        RS_modules.string_interpolation.render_markup = render_markup;\n        RS_modules.string_interpolation.interpolate = interpolate;\n    })();\n\n    (function(){\n        var __name__ = "tokenizer";\n        var RE_HEX_NUMBER, RE_OCT_NUMBER, RE_DEC_NUMBER, OPERATOR_CHARS, ASCII_CONTROL_CHARS, HEX_PAT, NAME_PAT, OPERATORS, OP_MAP, WHITESPACE_CHARS, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS, KEYWORDS_BEFORE_EXPRESSION, ALL_KEYWORDS, IDENTIFIER_PAT, UNICODE, EX_EOF;\n        var ALIAS_MAP = RS_modules.unicode_aliases.ALIAS_MAP;\n\n        var make_predicate = RS_modules.utils.make_predicate;\n        var characters = RS_modules.utils.characters;\n\n        var AST_Token = RS_modules.ast.AST_Token;\n\n        var SyntaxError = RS_modules.errors.SyntaxError;\n\n        var interpolate = RS_modules.string_interpolation.interpolate;\n\n        RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\n        RE_OCT_NUMBER = /^0[0-7]+$/;\n        RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n        OPERATOR_CHARS = make_predicate(characters("+-*&%=<>!?|~^@"));\n        ASCII_CONTROL_CHARS = (function(){\n            var RS_d = Object.create(null);\n            RS_d["a"] = 7;\n            RS_d["b"] = 8;\n            RS_d["f"] = 12;\n            RS_d["n"] = 10;\n            RS_d["r"] = 13;\n            RS_d["t"] = 9;\n            RS_d["v"] = 11;\n            return RS_d;\n        }).call(this);\n        HEX_PAT = /[a-fA-F0-9]/;\n        NAME_PAT = /[a-zA-Z ]/;\n        OPERATORS = make_predicate(RS_list_decorate([ "in", "instanceof", "typeof", "new", "void", "del", "+", "-", "not", "~", "&", "|", "^", "**", "*", "//", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "is", "!=", "=", "+=", "-=", "//=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "and", "or", "@", "->" ]));\n        OP_MAP = (function(){\n            var RS_d = Object.create(null);\n            RS_d["or"] = "||";\n            RS_d["and"] = "&&";\n            RS_d["not"] = "!";\n            RS_d["del"] = "delete";\n            RS_d["None"] = "null";\n            RS_d["is"] = "===";\n            return RS_d;\n        }).call(this);\n        WHITESPACE_CHARS = make_predicate(characters("  \\n\\r\\t\\f\\u000b​᠎           \\u202f 　"));\n        PUNC_BEFORE_EXPRESSION = make_predicate(characters("[{(,.;:"));\n        PUNC_CHARS = make_predicate(characters("[]{}(),;:?"));\n        KEYWORDS = "as assert break class continue def del do elif else except finally for from global if import in is new nonlocal pass raise return yield try while with or and not";\n        KEYWORDS_ATOM = "False None True";\n        RESERVED_WORDS = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield enum implements static private package let public protected interface await null true false";\n        KEYWORDS_BEFORE_EXPRESSION = "return yield new del raise elif else if";\n        ALL_KEYWORDS = KEYWORDS + " " + KEYWORDS_ATOM;\n        KEYWORDS = make_predicate(KEYWORDS);\n        RESERVED_WORDS = make_predicate(RESERVED_WORDS);\n        KEYWORDS_BEFORE_EXPRESSION = make_predicate(KEYWORDS_BEFORE_EXPRESSION);\n        KEYWORDS_ATOM = make_predicate(KEYWORDS_ATOM);\n        IDENTIFIER_PAT = /^[a-z_$][_a-z0-9$]*$/i;\n        function is_string_modifier(val) {\n            var ch;\n            var RS_Iter36 = RS_Iterable(val);\n            for (var RS_Index36 = 0; RS_Index36 < RS_Iter36.length; RS_Index36++) {\n                ch = RS_Iter36[RS_Index36];\n                if ("vrufVRUF".indexOf(ch) === -1) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        if (!is_string_modifier.__argnames__) Object.defineProperties(is_string_modifier, {\n            __argnames__ : {value: ["val"]}\n        });\n\n        function is_letter(code) {\n            return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));\n        };\n        if (!is_letter.__argnames__) Object.defineProperties(is_letter, {\n            __argnames__ : {value: ["code"]}\n        });\n\n        function is_digit(code) {\n            return code >= 48 && code <= 57;\n        };\n        if (!is_digit.__argnames__) Object.defineProperties(is_digit, {\n            __argnames__ : {value: ["code"]}\n        });\n\n        function is_alphanumeric_char(code) {\n            return is_digit(code) || is_letter(code);\n        };\n        if (!is_alphanumeric_char.__argnames__) Object.defineProperties(is_alphanumeric_char, {\n            __argnames__ : {value: ["code"]}\n        });\n\n        function is_unicode_combining_mark(ch) {\n            return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\n        };\n        if (!is_unicode_combining_mark.__argnames__) Object.defineProperties(is_unicode_combining_mark, {\n            __argnames__ : {value: ["ch"]}\n        });\n\n        function is_unicode_connector_punctuation(ch) {\n            return UNICODE.connector_punctuation.test(ch);\n        };\n        if (!is_unicode_connector_punctuation.__argnames__) Object.defineProperties(is_unicode_connector_punctuation, {\n            __argnames__ : {value: ["ch"]}\n        });\n\n        function is_identifier(name) {\n            return !RESERVED_WORDS[(typeof name === "number" && name < 0) ? RESERVED_WORDS.length + name : name] && !KEYWORDS[(typeof name === "number" && name < 0) ? KEYWORDS.length + name : name] && !KEYWORDS_ATOM[(typeof name === "number" && name < 0) ? KEYWORDS_ATOM.length + name : name] && IDENTIFIER_PAT.test(name);\n        };\n        if (!is_identifier.__argnames__) Object.defineProperties(is_identifier, {\n            __argnames__ : {value: ["name"]}\n        });\n\n        function is_identifier_start(code) {\n            return code === 36 || code === 95 || is_letter(code);\n        };\n        if (!is_identifier_start.__argnames__) Object.defineProperties(is_identifier_start, {\n            __argnames__ : {value: ["code"]}\n        });\n\n        function is_identifier_char(ch) {\n            var code;\n            code = ch.charCodeAt(0);\n            return is_identifier_start(code) || is_digit(code) || code === 8204 || code === 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);\n        };\n        if (!is_identifier_char.__argnames__) Object.defineProperties(is_identifier_char, {\n            __argnames__ : {value: ["ch"]}\n        });\n\n        function parse_js_number(num) {\n            if (RE_HEX_NUMBER.test(num)) {\n                return parseInt(num.substr(2), 16);\n            } else if (RE_OCT_NUMBER.test(num)) {\n                return parseInt(num.substr(1), 8);\n            } else if (RE_DEC_NUMBER.test(num)) {\n                return parseFloat(num);\n            }\n        };\n        if (!parse_js_number.__argnames__) Object.defineProperties(parse_js_number, {\n            __argnames__ : {value: ["num"]}\n        });\n\n        UNICODE = (function(){\n            var RS_d = Object.create(null);\n            RS_d["letter"] = new RegExp("[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]");\n            RS_d["non_spacing_mark"] = new RegExp("[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]");\n            RS_d["space_combining_mark"] = new RegExp("[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]");\n            RS_d["connector_punctuation"] = new RegExp("[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]");\n            return RS_d;\n        }).call(this);\n        function is_token(token, type, val) {\n            return token.type === type && (val === null || val === undefined || token.value === val);\n        };\n        if (!is_token.__argnames__) Object.defineProperties(is_token, {\n            __argnames__ : {value: ["token", "type", "val"]}\n        });\n\n        EX_EOF = Object.create(null);\n        function tokenizer(raw_text, filename) {\n            var S, read_string, read_regexp;\n            S = (function(){\n                var RS_d = Object.create(null);\n                RS_d["text"] = raw_text.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, "\\n").replace(/\\uFEFF/g, "");\n                RS_d["filename"] = filename;\n                RS_d["pos"] = 0;\n                RS_d["tokpos"] = 0;\n                RS_d["line"] = 1;\n                RS_d["tokline"] = 0;\n                RS_d["col"] = 0;\n                RS_d["tokcol"] = 0;\n                RS_d["newline_before"] = false;\n                RS_d["regex_allowed"] = false;\n                RS_d["comments_before"] = [];\n                RS_d["whitespace_before"] = [];\n                RS_d["newblock"] = false;\n                RS_d["endblock"] = false;\n                RS_d["indentation_matters"] = [ true ];\n                RS_d["cached_whitespace"] = "";\n                RS_d["prev"] = undefined;\n                RS_d["index_or_slice"] = [ false ];\n                RS_d["expecting_object_literal_key"] = false;\n                return RS_d;\n            }).call(this);\n            function peek() {\n                return S.text.charAt(S.pos);\n            };\n\n            function prevChar() {\n                return S.text.charAt(S.tokpos - 1);\n            };\n\n            function next(signal_eof, in_string) {\n                var ch;\n                ch = S.text.charAt(S.pos);\n                S.pos += 1;\n                if (signal_eof && !ch) {\n                    throw EX_EOF;\n                }\n                if (ch === "\\n") {\n                    S.newline_before = S.newline_before || !in_string;\n                    S.line += 1;\n                    S.col = 0;\n                } else {\n                    S.col += 1;\n                }\n                return ch;\n            };\n            if (!next.__argnames__) Object.defineProperties(next, {\n                __argnames__ : {value: ["signal_eof", "in_string"]}\n            });\n\n            function find(what, signal_eof) {\n                var pos;\n                pos = S.text.indexOf(what, S.pos);\n                if (signal_eof && pos === -1) {\n                    throw EX_EOF;\n                }\n                return pos;\n            };\n            if (!find.__argnames__) Object.defineProperties(find, {\n                __argnames__ : {value: ["what", "signal_eof"]}\n            });\n\n            function start_token() {\n                S.tokline = S.line;\n                S.tokcol = S.col;\n                S.tokpos = S.pos;\n            };\n\n            function token(type, value, is_comment, keep_newline) {\n                var ret, i;\n                S.regex_allowed = type === "operator" || type === "keyword" && KEYWORDS_BEFORE_EXPRESSION[(typeof value === "number" && value < 0) ? KEYWORDS_BEFORE_EXPRESSION.length + value : value] || type === "punc" && PUNC_BEFORE_EXPRESSION[(typeof value === "number" && value < 0) ? PUNC_BEFORE_EXPRESSION.length + value : value];\n                if (type === "operator" && value === "is" && S.text.substr(S.pos).trimLeft().substr(0, 4).trimRight() === "not") {\n                    next_token();\n                    value = "!==";\n                }\n                if (type === "operator" && OP_MAP[(typeof value === "number" && value < 0) ? OP_MAP.length + value : value]) {\n                    value = OP_MAP[(typeof value === "number" && value < 0) ? OP_MAP.length + value : value];\n                }\n                ret = (function(){\n                    var RS_d = Object.create(null);\n                    RS_d["type"] = type;\n                    RS_d["value"] = value;\n                    RS_d["line"] = S.tokline;\n                    RS_d["col"] = S.tokcol;\n                    RS_d["pos"] = S.tokpos;\n                    RS_d["endpos"] = S.pos;\n                    RS_d["nlb"] = S.newline_before;\n                    RS_d["file"] = filename;\n                    RS_d["leading_whitespace"] = (RS_expr_temp = S.whitespace_before)[RS_expr_temp.length-1] || "";\n                    return RS_d;\n                }).call(this);\n                if (!is_comment) {\n                    ret.comments_before = S.comments_before;\n                    S.comments_before = [];\n                    for (var RS_Index37 = 0; RS_Index37 < ret.comments_before.length; RS_Index37++) {\n                        i = RS_Index37;\n                        ret.nlb = ret.nlb || (RS_expr_temp = ret.comments_before)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].nlb;\n                    }\n                }\n                if (!keep_newline) {\n                    S.newline_before = false;\n                }\n                if (type === "punc") {\n                    if (value === ":" && !(RS_expr_temp = S.index_or_slice)[RS_expr_temp.length-1] && !S.expecting_object_literal_key && (!S.text.substring(S.pos + 1, find("\\n")).trim() || !S.text.substring(S.pos + 1, find("#")).trim())) {\n                        S.newblock = true;\n                        S.indentation_matters.push(true);\n                    }\n                    if (value === "[") {\n                        if (S.prev && (S.prev.type === "name" || S.prev.type === "punc" && ")]".indexOf(S.prev.value) !== -1)) {\n                            S.index_or_slice.push(true);\n                        } else {\n                            S.index_or_slice.push(false);\n                        }\n                        S.indentation_matters.push(false);\n                    } else if (value === "{" || value === "(") {\n                        S.indentation_matters.push(false);\n                    } else if (value === "]") {\n                        S.index_or_slice.pop();\n                        S.indentation_matters.pop();\n                    } else if (value === "}" || value === ")") {\n                        S.indentation_matters.pop();\n                    }\n                }\n                S.prev = new AST_Token(ret);\n                return S.prev;\n            };\n            if (!token.__argnames__) Object.defineProperties(token, {\n                __argnames__ : {value: ["type", "value", "is_comment", "keep_newline"]}\n            });\n\n            function parse_whitespace() {\n                var leading_whitespace, whitespace_exists, ch;\n                leading_whitespace = "";\n                whitespace_exists = false;\n                while (WHITESPACE_CHARS[RS_bound_index(peek(), WHITESPACE_CHARS)]) {\n                    whitespace_exists = true;\n                    ch = next();\n                    if (ch === "\\n") {\n                        leading_whitespace = "";\n                    } else {\n                        leading_whitespace += ch;\n                    }\n                }\n                if (peek() !== "#") {\n                    if (!whitespace_exists) {\n                        leading_whitespace = S.cached_whitespace;\n                    } else {\n                        S.cached_whitespace = leading_whitespace;\n                    }\n                    if (S.newline_before || S.endblock) {\n                        return test_indent_token(leading_whitespace);\n                    }\n                }\n            };\n\n            function test_indent_token(leading_whitespace) {\n                var most_recent;\n                most_recent = (RS_expr_temp = S.whitespace_before)[RS_expr_temp.length-1] || "";\n                S.endblock = false;\n                if ((RS_expr_temp = S.indentation_matters)[RS_expr_temp.length-1] && leading_whitespace !== most_recent) {\n                    if (S.newblock && leading_whitespace && leading_whitespace.indexOf(most_recent) === 0) {\n                        S.newblock = false;\n                        S.whitespace_before.push(leading_whitespace);\n                        return 1;\n                    } else if (most_recent && most_recent.indexOf(leading_whitespace) === 0) {\n                        S.endblock = true;\n                        S.whitespace_before.pop();\n                        return -1;\n                    } else {\n                        parse_error("Inconsistent indentation");\n                    }\n                }\n                return 0;\n            };\n            if (!test_indent_token.__argnames__) Object.defineProperties(test_indent_token, {\n                __argnames__ : {value: ["leading_whitespace"]}\n            });\n\n            function read_while(pred) {\n                var ret, i, ch;\n                ret = "";\n                i = 0;\n                ch = "";\n                while ((ch = peek()) && pred(ch, i)) {\n                    i += 1;\n                    ret += next();\n                }\n                return ret;\n            };\n            if (!read_while.__argnames__) Object.defineProperties(read_while, {\n                __argnames__ : {value: ["pred"]}\n            });\n\n            function parse_error(err, is_eof) {\n                throw new SyntaxError(err, filename, S.tokline, S.tokcol, S.tokpos, is_eof);\n            };\n            if (!parse_error.__argnames__) Object.defineProperties(parse_error, {\n                __argnames__ : {value: ["err", "is_eof"]}\n            });\n\n            function read_num(prefix) {\n                var has_e, has_x, has_dot, num, valid, seen;\n                has_e = false;\n                has_x = false;\n                has_dot = prefix === ".";\n                if (!prefix && peek() === "0" && S.text.charAt(S.pos + 1) === "b") {\n                    [next(), next()];\n                    num = read_while((function() {\n                        var RS_anonfunc = function (ch) {\n                            return ch === "0" || ch === "1";\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["ch"]}\n                        });\n                        return RS_anonfunc;\n                    })());\n                    valid = parseInt(num, 2);\n                    if (isNaN(valid)) {\n                        parse_error("Invalid syntax for a binary number");\n                    }\n                    return token("num", valid);\n                }\n                seen = [];\n                num = read_while((function() {\n                    var RS_anonfunc = function (ch, i) {\n                        seen.push(ch);\n                        if (ch === "x" || ch === "X") {\n                            if (has_x || seen.length !== 2 || seen[0] !== "0") {\n                                return false;\n                            }\n                            has_x = true;\n                            return true;\n                        } else if (ch === "e" || ch === "E") {\n                            if (has_x) {\n                                return true;\n                            }\n                            if (has_e || (i === 0 || typeof i === "object" && RS_equals(i, 0))) {\n                                return false;\n                            }\n                            has_e = true;\n                            return true;\n                        } else if (ch === "-") {\n                            if (i === 0 && !prefix) {\n                                return true;\n                            }\n                            if (has_e && seen[RS_bound_index(i - 1, seen)].toLowerCase() === "e") {\n                                return true;\n                            }\n                            return false;\n                        } else if (ch === "+") {\n                            if (has_e && seen[RS_bound_index(i - 1, seen)].toLowerCase() === "e") {\n                                return true;\n                            }\n                            return false;\n                        } else if (ch === ".") {\n                            return (!has_dot && !has_x && !has_e) ? has_dot = true : false;\n                        }\n                        return is_alphanumeric_char(ch.charCodeAt(0));\n                    };\n                    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                        __argnames__ : {value: ["ch", "i"]}\n                    });\n                    return RS_anonfunc;\n                })());\n                if (prefix) {\n                    num = prefix + num;\n                }\n                valid = parse_js_number(num);\n                if (!isNaN(valid)) {\n                    return token("num", valid);\n                } else {\n                    parse_error("Invalid syntax: " + num);\n                }\n            };\n            if (!read_num.__argnames__) Object.defineProperties(read_num, {\n                __argnames__ : {value: ["prefix"]}\n            });\n\n            function read_hex_digits(count) {\n                var ans, nval;\n                ans = "";\n                while (count > 0) {\n                    count -= 1;\n                    if (!HEX_PAT.test(peek())) {\n                        return ans;\n                    }\n                    ans += next();\n                }\n                nval = parseInt(ans, 16);\n                if (nval > 1114111) {\n                    return ans;\n                }\n                return nval;\n            };\n            if (!read_hex_digits.__argnames__) Object.defineProperties(read_hex_digits, {\n                __argnames__ : {value: ["count"]}\n            });\n\n            function read_escape_sequence() {\n                var q, octal, code, name, key;\n                q = next(true);\n                if (q === "\\n") {\n                    return "";\n                }\n                if (q === "\\\\") {\n                    return q;\n                }\n                if ("\\"\'".indexOf(q) !== -1) {\n                    return q;\n                }\n                if (ASCII_CONTROL_CHARS[(typeof q === "number" && q < 0) ? ASCII_CONTROL_CHARS.length + q : q]) {\n                    return String.fromCharCode(ASCII_CONTROL_CHARS[(typeof q === "number" && q < 0) ? ASCII_CONTROL_CHARS.length + q : q]);\n                }\n                if ("0" <= q && q <= "7") {\n                    octal = q;\n                    if ("0" <= (RS_cond_temp = peek()) && RS_cond_temp <= "7") {\n                        octal += next();\n                    }\n                    if ("0" <= (RS_cond_temp = peek()) && RS_cond_temp <= "7") {\n                        octal += next();\n                    }\n                    code = parseInt(octal, 8);\n                    if (isNaN(code)) {\n                        return "\\\\" + octal;\n                    }\n                    return String.fromCharCode(code);\n                }\n                if (q === "x") {\n                    code = read_hex_digits(2);\n                    if (typeof code === "number") {\n                        return String.fromCharCode(code);\n                    }\n                    return "\\\\x" + code;\n                }\n                if (q === "u") {\n                    code = read_hex_digits(4);\n                    if (typeof code === "number") {\n                        return String.fromCharCode(code);\n                    }\n                    return "\\\\u" + code;\n                }\n                if (q === "U") {\n                    code = read_hex_digits(8);\n                    if (typeof code === "number") {\n                        if (code <= 65535) {\n                            return String.fromCharCode(code);\n                        }\n                        code -= 65536;\n                        return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    }\n                    return "\\\\U" + code;\n                }\n                if (q === "N" && peek() === "{") {\n                    next();\n                    name = read_while((function() {\n                        var RS_anonfunc = function (ch) {\n                            return NAME_PAT.test(ch);\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["ch"]}\n                        });\n                        return RS_anonfunc;\n                    })());\n                    if (peek() !== "}") {\n                        return "\\\\N{" + name;\n                    }\n                    next();\n                    key = (name || "").toLowerCase();\n                    if (!name || !Object.prototype.hasOwnProperty.call(ALIAS_MAP, key)) {\n                        return "\\\\N{" + name + "}";\n                    }\n                    code = ALIAS_MAP[(typeof key === "number" && key < 0) ? ALIAS_MAP.length + key : key];\n                    if (code <= 65535) {\n                        return String.fromCharCode(code);\n                    }\n                    code -= 65536;\n                    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                }\n                return "\\\\" + q;\n            };\n\n            function with_eof_error(eof_error, cont) {\n                return function () {\n                    try {\n                        return cont.apply(null, arguments);\n                    } catch (RS_Exception) {\n                        RS_last_exception = RS_Exception;\n                        {\n                            var ex = RS_Exception;\n                            if (ex === EX_EOF) {\n                                parse_error(eof_error, true);\n                            } else {\n                                throw RS_Exception;\n                            }\n                        } \n                    }\n                };\n            };\n            if (!with_eof_error.__argnames__) Object.defineProperties(with_eof_error, {\n                __argnames__ : {value: ["eof_error", "cont"]}\n            });\n\n            read_string = with_eof_error("Unterminated string constant", (function() {\n                var RS_anonfunc = function (is_raw_literal, is_js_literal) {\n                    var quote, tok_type, ret, is_multiline, ch;\n                    quote = next();\n                    tok_type = (is_js_literal) ? "js" : "string";\n                    ret = "";\n                    is_multiline = false;\n                    if (peek() === quote) {\n                        next(true);\n                        if (peek() === quote) {\n                            next(true);\n                            is_multiline = true;\n                        } else {\n                            return token(tok_type, "");\n                        }\n                    }\n                    while (true) {\n                        ch = next(true, true);\n                        if (!ch) {\n                            break;\n                        }\n                        if (ch === "\\n" && !is_multiline) {\n                            parse_error("End of line while scanning string literal");\n                        }\n                        if (ch === "\\\\") {\n                            ret += (is_raw_literal) ? "\\\\" + next(true) : read_escape_sequence();\n                            continue;\n                        }\n                        if (ch === quote) {\n                            if (!is_multiline) {\n                                break;\n                            }\n                            if (peek() === quote) {\n                                next();\n                                if (peek() === quote) {\n                                    next();\n                                    break;\n                                } else {\n                                    ch += quote;\n                                }\n                            }\n                        }\n                        ret += ch;\n                    }\n                    return token(tok_type, ret);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["is_raw_literal", "is_js_literal"]}\n                });\n                return RS_anonfunc;\n            })());\n            function handle_interpolated_string(string, start_tok) {\n                function raise_error(err) {\n                    throw new SyntaxError(err, filename, start_tok.line, start_tok.col, start_tok.pos, false);\n                };\n                if (!raise_error.__argnames__) Object.defineProperties(raise_error, {\n                    __argnames__ : {value: ["err"]}\n                });\n\n                S.text = S.text.slice(0, S.pos) + "(" + interpolate(string, raise_error) + ")" + S.text.slice(S.pos);\n                return token("punc", next());\n            };\n            if (!handle_interpolated_string.__argnames__) Object.defineProperties(handle_interpolated_string, {\n                __argnames__ : {value: ["string", "start_tok"]}\n            });\n\n            function read_line_comment(shebang) {\n                var i, ret;\n                if (!shebang) {\n                    next();\n                }\n                i = find("\\n");\n                if (i === -1) {\n                    ret = S.text.substr(S.pos);\n                    S.pos = S.text.length;\n                } else {\n                    ret = S.text.substring(S.pos, i);\n                    S.pos = i;\n                }\n                return token((shebang) ? "shebang" : "comment1", ret, true);\n            };\n            if (!read_line_comment.__argnames__) Object.defineProperties(read_line_comment, {\n                __argnames__ : {value: ["shebang"]}\n            });\n\n            function read_name() {\n                var name, ch;\n                name = ch = "";\n                while ((ch = peek()) !== null) {\n                    if (ch === "\\\\") {\n                        if (S.text.charAt(S.pos + 1) === "\\n") {\n                            S.pos += 2;\n                            continue;\n                        }\n                        break;\n                    } else if (is_identifier_char(ch)) {\n                        name += next();\n                    } else {\n                        break;\n                    }\n                }\n                return name;\n            };\n\n            read_regexp = with_eof_error("Unterminated regular expression", function () {\n                var prev_backslash, regexp, ch, in_class, verbose_regexp, in_comment, mods;\n                prev_backslash = false;\n                regexp = ch = "";\n                in_class = false;\n                verbose_regexp = false;\n                in_comment = false;\n                if (peek() === "/") {\n                    next(true);\n                    if (peek() === "/") {\n                        verbose_regexp = true;\n                        next(true);\n                    } else {\n                        mods = read_name();\n                        return token("regexp", new RegExp(regexp, mods));\n                    }\n                }\n                while (true) {\n                    ch = next(true);\n                    if (!ch) {\n                        break;\n                    }\n                    if (in_comment) {\n                        if (ch === "\\n") {\n                            in_comment = false;\n                        }\n                        continue;\n                    }\n                    if (prev_backslash) {\n                        regexp += "\\\\" + ch;\n                        prev_backslash = false;\n                    } else if (ch === "[") {\n                        in_class = true;\n                        regexp += ch;\n                    } else if (ch === "]" && in_class) {\n                        in_class = false;\n                        regexp += ch;\n                    } else if (ch === "/" && !in_class) {\n                        if (verbose_regexp) {\n                            if (peek() !== "/") {\n                                regexp += "\\\\/";\n                                continue;\n                            }\n                            next(true);\n                            if (peek() !== "/") {\n                                regexp += "\\\\/\\\\/";\n                                continue;\n                            }\n                            next(true);\n                        }\n                        break;\n                    } else if (ch === "\\\\") {\n                        prev_backslash = true;\n                    } else if (verbose_regexp && !in_class && " \\n\\r\\t".indexOf(ch) !== -1) {\n                    } else if (verbose_regexp && !in_class && ch === "#") {\n                        in_comment = true;\n                    } else {\n                        regexp += ch;\n                    }\n                }\n                mods = read_name();\n                return token("regexp", new RegExp(regexp, mods));\n            });\n            function read_operator(prefix) {\n                var op;\n                function grow(op) {\n                    var bigger;\n                    if (!peek()) {\n                        return op;\n                    }\n                    bigger = op + peek();\n                    if (OPERATORS[(typeof bigger === "number" && bigger < 0) ? OPERATORS.length + bigger : bigger]) {\n                        next();\n                        return grow(bigger);\n                    } else {\n                        return op;\n                    }\n                };\n                if (!grow.__argnames__) Object.defineProperties(grow, {\n                    __argnames__ : {value: ["op"]}\n                });\n\n                op = grow(prefix || next());\n                if (op === "->") {\n                    return token("punc", op);\n                }\n                return token("operator", op);\n            };\n            if (!read_operator.__argnames__) Object.defineProperties(read_operator, {\n                __argnames__ : {value: ["prefix"]}\n            });\n\n            function handle_slash() {\n                next();\n                return (S.regex_allowed) ? read_regexp("") : read_operator("/");\n            };\n\n            function handle_dot() {\n                next();\n                return (is_digit(peek().charCodeAt(0))) ? read_num(".") : token("punc", ".");\n            };\n\n            function read_word() {\n                var word;\n                word = read_name();\n                return (KEYWORDS_ATOM[(typeof word === "number" && word < 0) ? KEYWORDS_ATOM.length + word : word]) ? token("atom", word) : (!KEYWORDS[(typeof word === "number" && word < 0) ? KEYWORDS.length + word : word]) ? token("name", word) : (OPERATORS[(typeof word === "number" && word < 0) ? OPERATORS.length + word : word] && prevChar() !== ".") ? token("operator", word) : token("keyword", word);\n            };\n\n            function next_token() {\n                var indent, ch, code, tmp_, regex_allowed, tok, mods, start_pos_for_string, stok;\n                indent = parse_whitespace();\n                if (indent === -1) {\n                    return token("punc", "}", false, true);\n                }\n                start_token();\n                ch = peek();\n                if (!ch) {\n                    return token("eof");\n                }\n                code = ch.charCodeAt(0);\n                tmp_ = code;\n                if (tmp_ === 34 || tmp_ === 39) {\n                    return read_string(false);\n                } else if (tmp_ === 35) {\n                    if (S.pos === 0 && S.text.charAt(1) === "!") {\n                        return read_line_comment(true);\n                    }\n                    regex_allowed = S.regex_allowed;\n                    S.comments_before.push(read_line_comment());\n                    S.regex_allowed = regex_allowed;\n                    return next_token();\n                } else if (tmp_ === 46) {\n                    return handle_dot();\n                } else if (tmp_ === 47) {\n                    return handle_slash();\n                }\n                if (is_digit(code)) {\n                    return read_num();\n                }\n                if (PUNC_CHARS[(typeof ch === "number" && ch < 0) ? PUNC_CHARS.length + ch : ch]) {\n                    return token("punc", next());\n                }\n                if (OPERATOR_CHARS[(typeof ch === "number" && ch < 0) ? OPERATOR_CHARS.length + ch : ch]) {\n                    return read_operator();\n                }\n                if (code === 92 && S.text.charAt(S.pos + 1) === "\\n") {\n                    next();\n                    next();\n                    S.newline_before = false;\n                    return next_token();\n                }\n                if (is_identifier_start(code)) {\n                    tok = read_word();\n                    if ("\'\\"".indexOf(peek()) !== -1 && is_string_modifier(tok.value)) {\n                        mods = tok.value.toLowerCase();\n                        start_pos_for_string = S.tokpos;\n                        stok = read_string(mods.indexOf("r") !== -1, mods.indexOf("v") !== -1);\n                        tok.endpos = stok.endpos;\n                        if (stok.type !== "js" && mods.indexOf("f") !== -1) {\n                            tok.col += start_pos_for_string - tok.pos;\n                            return handle_interpolated_string(stok.value, tok);\n                        }\n                        tok.value = stok.value;\n                        tok.type = stok.type;\n                    }\n                    return tok;\n                }\n                parse_error("Unexpected character «" + ch + "»");\n            };\n\n            next_token.context = (function() {\n                var RS_anonfunc = function (nc) {\n                    if (nc) {\n                        S = nc;\n                    }\n                    return S;\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["nc"]}\n                });\n                return RS_anonfunc;\n            })();\n            return next_token;\n        };\n        if (!tokenizer.__argnames__) Object.defineProperties(tokenizer, {\n            __argnames__ : {value: ["raw_text", "filename"]}\n        });\n\n        RS_modules.tokenizer.RE_HEX_NUMBER = RE_HEX_NUMBER;\n        RS_modules.tokenizer.RE_OCT_NUMBER = RE_OCT_NUMBER;\n        RS_modules.tokenizer.RE_DEC_NUMBER = RE_DEC_NUMBER;\n        RS_modules.tokenizer.OPERATOR_CHARS = OPERATOR_CHARS;\n        RS_modules.tokenizer.ASCII_CONTROL_CHARS = ASCII_CONTROL_CHARS;\n        RS_modules.tokenizer.HEX_PAT = HEX_PAT;\n        RS_modules.tokenizer.NAME_PAT = NAME_PAT;\n        RS_modules.tokenizer.OPERATORS = OPERATORS;\n        RS_modules.tokenizer.OP_MAP = OP_MAP;\n        RS_modules.tokenizer.WHITESPACE_CHARS = WHITESPACE_CHARS;\n        RS_modules.tokenizer.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;\n        RS_modules.tokenizer.PUNC_CHARS = PUNC_CHARS;\n        RS_modules.tokenizer.KEYWORDS = KEYWORDS;\n        RS_modules.tokenizer.KEYWORDS_ATOM = KEYWORDS_ATOM;\n        RS_modules.tokenizer.RESERVED_WORDS = RESERVED_WORDS;\n        RS_modules.tokenizer.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;\n        RS_modules.tokenizer.ALL_KEYWORDS = ALL_KEYWORDS;\n        RS_modules.tokenizer.IDENTIFIER_PAT = IDENTIFIER_PAT;\n        RS_modules.tokenizer.UNICODE = UNICODE;\n        RS_modules.tokenizer.EX_EOF = EX_EOF;\n        RS_modules.tokenizer.is_string_modifier = is_string_modifier;\n        RS_modules.tokenizer.is_letter = is_letter;\n        RS_modules.tokenizer.is_digit = is_digit;\n        RS_modules.tokenizer.is_alphanumeric_char = is_alphanumeric_char;\n        RS_modules.tokenizer.is_unicode_combining_mark = is_unicode_combining_mark;\n        RS_modules.tokenizer.is_unicode_connector_punctuation = is_unicode_connector_punctuation;\n        RS_modules.tokenizer.is_identifier = is_identifier;\n        RS_modules.tokenizer.is_identifier_start = is_identifier_start;\n        RS_modules.tokenizer.is_identifier_char = is_identifier_char;\n        RS_modules.tokenizer.parse_js_number = parse_js_number;\n        RS_modules.tokenizer.is_token = is_token;\n        RS_modules.tokenizer.tokenizer = tokenizer;\n    })();\n\n    (function(){\n        var __name__ = "parse";\n        var COMPILER_VERSION, PYTHON_FLAGS, NATIVE_CLASSES, ERROR_CLASSES, COMMON_STATIC, FORBIDDEN_CLASS_VARS, UNARY_PREFIX, ASSIGNMENT, PRECEDENCE, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN, compile_time_decorators;\n        var make_predicate = RS_modules.utils.make_predicate;\n        var array_to_hash = RS_modules.utils.array_to_hash;\n        var defaults = RS_modules.utils.defaults;\n        var has_prop = RS_modules.utils.has_prop;\n        var cache_file_name = RS_modules.utils.cache_file_name;\n\n        var SyntaxError = RS_modules.errors.SyntaxError;\n        var ImportError = RS_modules.errors.ImportError;\n\n        var AST_Array = RS_modules.ast.AST_Array;\n        var AST_Assign = RS_modules.ast.AST_Assign;\n        var AST_Binary = RS_modules.ast.AST_Binary;\n        var AST_BlockStatement = RS_modules.ast.AST_BlockStatement;\n        var AST_Break = RS_modules.ast.AST_Break;\n        var AST_Call = RS_modules.ast.AST_Call;\n        var AST_Catch = RS_modules.ast.AST_Catch;\n        var AST_Class = RS_modules.ast.AST_Class;\n        var AST_ClassCall = RS_modules.ast.AST_ClassCall;\n        var AST_Conditional = RS_modules.ast.AST_Conditional;\n        var AST_Constant = RS_modules.ast.AST_Constant;\n        var AST_Continue = RS_modules.ast.AST_Continue;\n        var AST_DWLoop = RS_modules.ast.AST_DWLoop;\n        var AST_Debugger = RS_modules.ast.AST_Debugger;\n        var AST_Decorator = RS_modules.ast.AST_Decorator;\n        var AST_Definitions = RS_modules.ast.AST_Definitions;\n        var AST_DictComprehension = RS_modules.ast.AST_DictComprehension;\n        var AST_Directive = RS_modules.ast.AST_Directive;\n        var AST_Do = RS_modules.ast.AST_Do;\n        var AST_Dot = RS_modules.ast.AST_Dot;\n        var AST_Else = RS_modules.ast.AST_Else;\n        var AST_EmptyStatement = RS_modules.ast.AST_EmptyStatement;\n        var AST_Except = RS_modules.ast.AST_Except;\n        var AST_ExpressiveObject = RS_modules.ast.AST_ExpressiveObject;\n        var AST_False = RS_modules.ast.AST_False;\n        var AST_Finally = RS_modules.ast.AST_Finally;\n        var AST_ForIn = RS_modules.ast.AST_ForIn;\n        var AST_ForJS = RS_modules.ast.AST_ForJS;\n        var AST_Function = RS_modules.ast.AST_Function;\n        var AST_GeneratorComprehension = RS_modules.ast.AST_GeneratorComprehension;\n        var AST_Hole = RS_modules.ast.AST_Hole;\n        var AST_If = RS_modules.ast.AST_If;\n        var AST_Import = RS_modules.ast.AST_Import;\n        var AST_ImportedVar = RS_modules.ast.AST_ImportedVar;\n        var AST_Imports = RS_modules.ast.AST_Imports;\n        var AST_ListComprehension = RS_modules.ast.AST_ListComprehension;\n        var AST_Method = RS_modules.ast.AST_Method;\n        var AST_New = RS_modules.ast.AST_New;\n        var AST_Null = RS_modules.ast.AST_Null;\n        var AST_Number = RS_modules.ast.AST_Number;\n        var AST_Object = RS_modules.ast.AST_Object;\n        var AST_ObjectKeyVal = RS_modules.ast.AST_ObjectKeyVal;\n        var AST_PropAccess = RS_modules.ast.AST_PropAccess;\n        var AST_RegExp = RS_modules.ast.AST_RegExp;\n        var AST_Return = RS_modules.ast.AST_Return;\n        var AST_Scope = RS_modules.ast.AST_Scope;\n        var AST_Set = RS_modules.ast.AST_Set;\n        var AST_SetComprehension = RS_modules.ast.AST_SetComprehension;\n        var AST_SetItem = RS_modules.ast.AST_SetItem;\n        var AST_Seq = RS_modules.ast.AST_Seq;\n        var AST_SimpleStatement = RS_modules.ast.AST_SimpleStatement;\n        var AST_Splice = RS_modules.ast.AST_Splice;\n        var AST_String = RS_modules.ast.AST_String;\n        var AST_Sub = RS_modules.ast.AST_Sub;\n        var AST_ItemAccess = RS_modules.ast.AST_ItemAccess;\n        var AST_SymbolAlias = RS_modules.ast.AST_SymbolAlias;\n        var AST_SymbolCatch = RS_modules.ast.AST_SymbolCatch;\n        var AST_SymbolDefun = RS_modules.ast.AST_SymbolDefun;\n        var AST_SymbolFunarg = RS_modules.ast.AST_SymbolFunarg;\n        var AST_SymbolLambda = RS_modules.ast.AST_SymbolLambda;\n        var AST_SymbolNonlocal = RS_modules.ast.AST_SymbolNonlocal;\n        var AST_SymbolRef = RS_modules.ast.AST_SymbolRef;\n        var AST_SymbolVar = RS_modules.ast.AST_SymbolVar;\n        var AST_This = RS_modules.ast.AST_This;\n        var AST_Throw = RS_modules.ast.AST_Throw;\n        var AST_Toplevel = RS_modules.ast.AST_Toplevel;\n        var AST_True = RS_modules.ast.AST_True;\n        var AST_Try = RS_modules.ast.AST_Try;\n        var AST_UnaryPrefix = RS_modules.ast.AST_UnaryPrefix;\n        var AST_Undefined = RS_modules.ast.AST_Undefined;\n        var AST_Var = RS_modules.ast.AST_Var;\n        var AST_VarDef = RS_modules.ast.AST_VarDef;\n        var AST_Verbatim = RS_modules.ast.AST_Verbatim;\n        var AST_While = RS_modules.ast.AST_While;\n        var AST_With = RS_modules.ast.AST_With;\n        var AST_WithClause = RS_modules.ast.AST_WithClause;\n        var AST_Yield = RS_modules.ast.AST_Yield;\n        var AST_Assert = RS_modules.ast.AST_Assert;\n        var AST_Existential = RS_modules.ast.AST_Existential;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        var tokenizer = RS_modules.tokenizer.tokenizer;\n        var is_token = RS_modules.tokenizer.is_token;\n        var RESERVED_WORDS = RS_modules.tokenizer.RESERVED_WORDS;\n\n        COMPILER_VERSION = "0fa072fa6c39f9058968010925515065f91d2c8b";\n        PYTHON_FLAGS = (function(){\n            var RS_d = Object.create(null);\n            RS_d["dict_literals"] = true;\n            RS_d["overload_getitem"] = true;\n            RS_d["bound_methods"] = true;\n            RS_d["hash_literals"] = true;\n            return RS_d;\n        }).call(this);\n        function static_predicate(names) {\n            return (function() {\n                var RS_Iter = RS_Iterable(names.split(" ")), RS_Result = Object.create(null), k;\n                for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                    k = RS_Iter[RS_Index];\n                    RS_Result[k] = (true);\n                }\n                return RS_Result;\n            })();\n        };\n        if (!static_predicate.__argnames__) Object.defineProperties(static_predicate, {\n            __argnames__ : {value: ["names"]}\n        });\n\n        NATIVE_CLASSES = (function(){\n            var RS_d = Object.create(null);\n            RS_d["Image"] = Object.create(null);\n            RS_d["FileReader"] = Object.create(null);\n            RS_d["RegExp"] = Object.create(null);\n            RS_d["Error"] = Object.create(null);\n            RS_d["EvalError"] = Object.create(null);\n            RS_d["InternalError"] = Object.create(null);\n            RS_d["RangeError"] = Object.create(null);\n            RS_d["ReferenceError"] = Object.create(null);\n            RS_d["SyntaxError"] = Object.create(null);\n            RS_d["TypeError"] = Object.create(null);\n            RS_d["URIError"] = Object.create(null);\n            RS_d["Object"] = (function(){\n                var RS_d = Object.create(null);\n                RS_d["static"] = static_predicate("getOwnPropertyNames getOwnPropertyDescriptor getOwnPropertyDescriptors getOwnPropertySymbols keys entries values create defineProperty defineProperties getPrototypeOf setPrototypeOf assign seal isSealed is preventExtensions isExtensible freeze isFrozen");\n                return RS_d;\n            }).call(this);\n            RS_d["String"] = (function(){\n                var RS_d = Object.create(null);\n                RS_d["static"] = static_predicate("fromCharCode");\n                return RS_d;\n            }).call(this);\n            RS_d["Array"] = (function(){\n                var RS_d = Object.create(null);\n                RS_d["static"] = static_predicate("isArray from of");\n                return RS_d;\n            }).call(this);\n            RS_d["Function"] = Object.create(null);\n            RS_d["Date"] = (function(){\n                var RS_d = Object.create(null);\n                RS_d["static"] = static_predicate("UTC now parse");\n                return RS_d;\n            }).call(this);\n            RS_d["ArrayBuffer"] = (function(){\n                var RS_d = Object.create(null);\n                RS_d["static"] = static_predicate("isView transfer");\n                return RS_d;\n            }).call(this);\n            RS_d["DataView"] = Object.create(null);\n            RS_d["Float32Array"] = Object.create(null);\n            RS_d["Float64Array"] = Object.create(null);\n            RS_d["Int16Array"] = Object.create(null);\n            RS_d["Int32Array"] = Object.create(null);\n            RS_d["Int8Array"] = Object.create(null);\n            RS_d["Uint16Array"] = Object.create(null);\n            RS_d["Uint32Array"] = Object.create(null);\n            RS_d["Uint8Array"] = Object.create(null);\n            RS_d["Uint8ClampedArray"] = Object.create(null);\n            RS_d["Map"] = Object.create(null);\n            RS_d["WeakMap"] = Object.create(null);\n            RS_d["Proxy"] = Object.create(null);\n            RS_d["Set"] = Object.create(null);\n            RS_d["WeakSet"] = Object.create(null);\n            RS_d["Promise"] = (function(){\n                var RS_d = Object.create(null);\n                RS_d["static"] = static_predicate("all race reject resolve");\n                return RS_d;\n            }).call(this);\n            RS_d["WebSocket"] = Object.create(null);\n            RS_d["XMLHttpRequest"] = Object.create(null);\n            RS_d["TextEncoder"] = Object.create(null);\n            RS_d["TextDecoder"] = Object.create(null);\n            RS_d["MouseEvent"] = Object.create(null);\n            RS_d["Event"] = Object.create(null);\n            RS_d["CustomEvent"] = Object.create(null);\n            RS_d["Blob"] = Object.create(null);\n            return RS_d;\n        }).call(this);\n        ERROR_CLASSES = (function(){\n            var RS_d = Object.create(null);\n            RS_d["Exception"] = Object.create(null);\n            RS_d["AttributeError"] = Object.create(null);\n            RS_d["IndexError"] = Object.create(null);\n            RS_d["KeyError"] = Object.create(null);\n            RS_d["ValueError"] = Object.create(null);\n            RS_d["UnicodeDecodeError"] = Object.create(null);\n            RS_d["AssertionError"] = Object.create(null);\n            RS_d["ZeroDivisionError"] = Object.create(null);\n            return RS_d;\n        }).call(this);\n        COMMON_STATIC = static_predicate("call apply bind toString");\n        FORBIDDEN_CLASS_VARS = "prototype constructor".split(" ");\n        UNARY_PREFIX = make_predicate("typeof void delete ~ - + ! @");\n        ASSIGNMENT = make_predicate("= += -= /= //= *= %= >>= <<= >>>= |= ^= &=");\n        PRECEDENCE = (function() {\n            var RS_anonfunc = function (a, ret) {\n                var b, j, i;\n                for (var RS_Index38 = 0; RS_Index38 < a.length; RS_Index38++) {\n                    i = RS_Index38;\n                    b = a[(typeof i === "number" && i < 0) ? a.length + i : i];\n                    for (var RS_Index39 = 0; RS_Index39 < b.length; RS_Index39++) {\n                        j = RS_Index39;\n                        ret[RS_bound_index(b[(typeof j === "number" && j < 0) ? b.length + j : j], ret)] = i + 1;\n                    }\n                }\n                return ret;\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["a", "ret"]}\n            });\n            return RS_anonfunc;\n        })()(RS_list_decorate([ RS_list_decorate([ "||" ]), RS_list_decorate([ "&&" ]), RS_list_decorate([ "|" ]), RS_list_decorate([ "^" ]), RS_list_decorate([ "&" ]), RS_list_decorate([ "==", "===", "!=", "!==" ]), RS_list_decorate([ "<", ">", "<=", ">=", "in", "instanceof" ]), RS_list_decorate([ ">>", "<<", ">>>" ]), RS_list_decorate([ "+", "-" ]), RS_list_decorate([ "*", "/", "//", "%" ]), RS_list_decorate([ "**" ]) ]), Object.create(null));\n        STATEMENTS_WITH_LABELS = array_to_hash(RS_list_decorate([ "for", "do", "while", "switch" ]));\n        ATOMIC_START_TOKEN = array_to_hash(RS_list_decorate([ "atom", "num", "string", "regexp", "name", "js" ]));\n        compile_time_decorators = RS_list_decorate([ "staticmethod", "external", "property" ]);\n        function has_simple_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[(typeof i === "number" && i < 0) ? decorators.length + i : i];\n                if (is_node_type(s, AST_SymbolRef) && !s.parens && s.name === name) {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[(typeof i === "number" && i < 0) ? remove.length + i : i], 1);\n                }\n                return true;\n            }\n            return false;\n        };\n        if (!has_simple_decorator.__argnames__) Object.defineProperties(has_simple_decorator, {\n            __argnames__ : {value: ["decorators", "name"]}\n        });\n\n        function has_setter_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[(typeof i === "number" && i < 0) ? decorators.length + i : i];\n                if (is_node_type(s, AST_Dot) && is_node_type(s.expression, AST_SymbolRef) && s.expression.name === name && s.property === "setter") {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[(typeof i === "number" && i < 0) ? remove.length + i : i], 1);\n                }\n                return true;\n            }\n            return false;\n        };\n        if (!has_setter_decorator.__argnames__) Object.defineProperties(has_setter_decorator, {\n            __argnames__ : {value: ["decorators", "name"]}\n        });\n\n        function create_parser_ctx(S, import_dirs, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, options) {\n            function next() {\n                S.prev = S.token;\n                if (S.peeked.length) {\n                    S.token = S.peeked.shift();\n                } else {\n                    S.token = S.input();\n                }\n                return S.token;\n            };\n\n            function is_(type, value) {\n                return is_token(S.token, type, value);\n            };\n            if (!is_.__argnames__) Object.defineProperties(is_, {\n                __argnames__ : {value: ["type", "value"]}\n            });\n\n            function peek() {\n                if (!S.peeked.length) {\n                    S.peeked.push(S.input());\n                }\n                return S.peeked[0];\n            };\n\n            function prev() {\n                return S.prev;\n            };\n\n            function croak(msg, line, col, pos, is_eof) {\n                var ctx;\n                ctx = S.input.context();\n                throw new SyntaxError(msg, ctx.filename, (line !== undefined) ? line : ctx.tokline, (col !== undefined) ? col : ctx.tokcol, (pos !== undefined) ? pos : ctx.tokpos, is_eof);\n            };\n            if (!croak.__argnames__) Object.defineProperties(croak, {\n                __argnames__ : {value: ["msg", "line", "col", "pos", "is_eof"]}\n            });\n\n            function token_error(token, msg) {\n                var is_eof;\n                is_eof = token.type === "eof";\n                croak(msg, token.line, token.col, undefined, is_eof);\n            };\n            if (!token_error.__argnames__) Object.defineProperties(token_error, {\n                __argnames__ : {value: ["token", "msg"]}\n            });\n\n            function unexpected(token) {\n                if (token === undefined) {\n                    token = S.token;\n                }\n                token_error(token, "Unexpected token: " + token.type + " «" + token.value + "»");\n            };\n            if (!unexpected.__argnames__) Object.defineProperties(unexpected, {\n                __argnames__ : {value: ["token"]}\n            });\n\n            function expect_token(type, val) {\n                if (is_(type, val)) {\n                    return next();\n                }\n                token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");\n            };\n            if (!expect_token.__argnames__) Object.defineProperties(expect_token, {\n                __argnames__ : {value: ["type", "val"]}\n            });\n\n            function expect(punc) {\n                return expect_token("punc", punc);\n            };\n            if (!expect.__argnames__) Object.defineProperties(expect, {\n                __argnames__ : {value: ["punc"]}\n            });\n\n            function semicolon() {\n                if (is_("punc", ";")) {\n                    next();\n                    S.token.nlb = true;\n                }\n            };\n\n            function embed_tokens(parser) {\n                function with_embedded_tokens() {\n                    var start, expr, end;\n                    start = S.token;\n                    expr = parser();\n                    if (expr === undefined) {\n                        unexpected();\n                    }\n                    end = prev();\n                    expr.start = start;\n                    expr.end = end;\n                    return expr;\n                };\n\n                return with_embedded_tokens;\n            };\n            if (!embed_tokens.__argnames__) Object.defineProperties(embed_tokens, {\n                __argnames__ : {value: ["parser"]}\n            });\n\n            function scan_for_top_level_callables(body) {\n                var ans, opt, x, obj;\n                ans = [];\n                if (Array.isArray(body)) {\n                    var RS_Iter40 = RS_Iterable(body);\n                    for (var RS_Index40 = 0; RS_Index40 < RS_Iter40.length; RS_Index40++) {\n                        obj = RS_Iter40[RS_Index40];\n                        if (is_node_type(obj, AST_Function) || is_node_type(obj, AST_Class)) {\n                            if (obj.name) {\n                                ans.push(obj.name.name);\n                            } else {\n                                token_error(obj.start, "Top-level functions must have names");\n                            }\n                        } else {\n                            if (is_node_type(obj, AST_Scope)) {\n                                continue;\n                            }\n                            var RS_Iter41 = RS_Iterable(RS_list_decorate([ "body", "alternative" ]));\n                            for (var RS_Index41 = 0; RS_Index41 < RS_Iter41.length; RS_Index41++) {\n                                x = RS_Iter41[RS_Index41];\n                                opt = obj[(typeof x === "number" && x < 0) ? obj.length + x : x];\n                                if (opt) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt));\n                                }\n                                if (is_node_type(opt, AST_Assign) && !is_node_type(opt.right, AST_Scope)) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt.right));\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    ans = ans.concat(scan_for_top_level_callables(body.body));\n                    if (body.alternative) {\n                        ans = ans.concat(scan_for_top_level_callables(body.alternative));\n                    }\n                }\n                return ans;\n            };\n            if (!scan_for_top_level_callables.__argnames__) Object.defineProperties(scan_for_top_level_callables, {\n                __argnames__ : {value: ["body"]}\n            });\n\n            function scan_for_classes(body) {\n                var ans, obj;\n                ans = Object.create(null);\n                var RS_Iter42 = RS_Iterable(body);\n                for (var RS_Index42 = 0; RS_Index42 < RS_Iter42.length; RS_Index42++) {\n                    obj = RS_Iter42[RS_Index42];\n                    if (is_node_type(obj, AST_Class)) {\n                        ans[RS_bound_index(obj.name.name, ans)] = obj;\n                    }\n                }\n                return ans;\n            };\n            if (!scan_for_classes.__argnames__) Object.defineProperties(scan_for_classes, {\n                __argnames__ : {value: ["body"]}\n            });\n\n            function scan_for_local_vars(body) {\n                var localvars, seen, opt, option, clause, stmt, is_compound_assign, lhs;\n                localvars = [];\n                seen = Object.create(null);\n                function push(x) {\n                    if (has_prop(seen, x)) {\n                        return;\n                    }\n                    seen[(typeof x === "number" && x < 0) ? seen.length + x : x] = true;\n                    localvars.push(x);\n                };\n                if (!push.__argnames__) Object.defineProperties(push, {\n                    __argnames__ : {value: ["x"]}\n                });\n\n                function extend(arr) {\n                    var x;\n                    var RS_Iter43 = RS_Iterable(arr);\n                    for (var RS_Index43 = 0; RS_Index43 < RS_Iter43.length; RS_Index43++) {\n                        x = RS_Iter43[RS_Index43];\n                        push(x);\n                    }\n                };\n                if (!extend.__argnames__) Object.defineProperties(extend, {\n                    __argnames__ : {value: ["arr"]}\n                });\n\n                function scan_in_array(arr) {\n                    var x;\n                    var RS_Iter44 = RS_Iterable(arr);\n                    for (var RS_Index44 = 0; RS_Index44 < RS_Iter44.length; RS_Index44++) {\n                        x = RS_Iter44[RS_Index44];\n                        if (is_node_type(x, AST_Seq)) {\n                            x = x.to_array();\n                        } else if (is_node_type(x, AST_Array)) {\n                            x = x.elements;\n                        }\n                        if (Array.isArray(x)) {\n                            scan_in_array(x);\n                        } else {\n                            if (!is_node_type(x, AST_PropAccess)) {\n                                push(x.name);\n                            }\n                        }\n                    }\n                };\n                if (!scan_in_array.__argnames__) Object.defineProperties(scan_in_array, {\n                    __argnames__ : {value: ["arr"]}\n                });\n\n                function add_assign_lhs(lhs) {\n                    if (is_node_type(lhs, AST_Seq)) {\n                        lhs = new AST_Array((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["elements"] = lhs.to_array();\n                            return RS_d;\n                        }).call(this));\n                    }\n                    if (is_node_type(lhs, AST_Array)) {\n                        push("RS_unpack");\n                        scan_in_array(lhs.elements);\n                    } else if (lhs.name) {\n                        push(lhs.name);\n                    }\n                };\n                if (!add_assign_lhs.__argnames__) Object.defineProperties(add_assign_lhs, {\n                    __argnames__ : {value: ["lhs"]}\n                });\n\n                function add_for_in(stmt) {\n                    if (is_node_type(stmt.init, AST_Array)) {\n                        push("RS_unpack");\n                        scan_in_array(stmt.init.elements);\n                    } else {\n                        push(stmt.init.name);\n                    }\n                };\n                if (!add_for_in.__argnames__) Object.defineProperties(add_for_in, {\n                    __argnames__ : {value: ["stmt"]}\n                });\n\n                if (Array.isArray(body)) {\n                    var RS_Iter45 = RS_Iterable(body);\n                    for (var RS_Index45 = 0; RS_Index45 < RS_Iter45.length; RS_Index45++) {\n                        stmt = RS_Iter45[RS_Index45];\n                        if (is_node_type(stmt, AST_Scope)) {\n                            continue;\n                        }\n                        var RS_Iter46 = RS_Iterable(RS_list_decorate([ "body", "alternative", "bcatch", "condition" ]));\n                        for (var RS_Index46 = 0; RS_Index46 < RS_Iter46.length; RS_Index46++) {\n                            option = RS_Iter46[RS_Index46];\n                            opt = stmt[(typeof option === "number" && option < 0) ? stmt.length + option : option];\n                            if (opt) {\n                                extend(scan_for_local_vars(opt));\n                            }\n                            if (is_node_type(opt, AST_Assign) && !is_node_type(opt.right, AST_Scope)) {\n                                extend(scan_for_local_vars(opt.right));\n                            }\n                        }\n                        if (is_node_type(stmt, AST_ForIn)) {\n                            add_for_in(stmt);\n                        } else if (is_node_type(stmt, AST_DWLoop)) {\n                            extend(scan_for_local_vars(stmt));\n                        } else if (is_node_type(stmt, AST_With)) {\n                            [push("RS_with_exception"), push("RS_with_suppress")];\n                            var RS_Iter47 = RS_Iterable(stmt.clauses);\n                            for (var RS_Index47 = 0; RS_Index47 < RS_Iter47.length; RS_Index47++) {\n                                clause = RS_Iter47[RS_Index47];\n                                if (clause.alias) {\n                                    push(clause.alias.name);\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    extend(scan_for_local_vars(body.body));\n                    if (body.alternative) {\n                        extend(scan_for_local_vars(body.alternative));\n                    }\n                } else if (is_node_type(body, AST_Assign)) {\n                    if (body.is_chained()) {\n                        is_compound_assign = false;\n                        var RS_Iter48 = RS_Iterable(body.traverse_chain()[0]);\n                        for (var RS_Index48 = 0; RS_Index48 < RS_Iter48.length; RS_Index48++) {\n                            lhs = RS_Iter48[RS_Index48];\n                            add_assign_lhs(lhs);\n                            if (is_node_type(lhs, AST_Seq) || is_node_type(lhs, AST_Array)) {\n                                is_compound_assign = true;\n                                break;\n                            }\n                        }\n                        if (is_compound_assign) {\n                            push("RS_chain_assign_temp");\n                        }\n                    } else {\n                        add_assign_lhs(body.left);\n                    }\n                    if (!is_node_type(body.right, AST_Scope)) {\n                        extend(scan_for_local_vars(body.right));\n                    }\n                } else if (is_node_type(body, AST_ForIn)) {\n                    add_for_in(body);\n                }\n                return localvars;\n            };\n            if (!scan_for_local_vars.__argnames__) Object.defineProperties(scan_for_local_vars, {\n                __argnames__ : {value: ["body"]}\n            });\n\n            function scan_for_nonlocal_defs(body) {\n                var vardef, opt, option, stmt;\n                vars = [];\n                if (Array.isArray(body)) {\n                    var RS_Iter49 = RS_Iterable(body);\n                    for (var RS_Index49 = 0; RS_Index49 < RS_Iter49.length; RS_Index49++) {\n                        stmt = RS_Iter49[RS_Index49];\n                        if (is_node_type(stmt, AST_Scope)) {\n                            continue;\n                        }\n                        if (is_node_type(stmt, AST_Definitions)) {\n                            var RS_Iter50 = RS_Iterable(stmt.definitions);\n                            for (var RS_Index50 = 0; RS_Index50 < RS_Iter50.length; RS_Index50++) {\n                                vardef = RS_Iter50[RS_Index50];\n                                vars.push(vardef.name.name);\n                            }\n                        }\n                        var RS_Iter51 = RS_Iterable(RS_list_decorate([ "body", "alternative" ]));\n                        for (var RS_Index51 = 0; RS_Index51 < RS_Iter51.length; RS_Index51++) {\n                            option = RS_Iter51[RS_Index51];\n                            var vars;\n                            opt = stmt[(typeof option === "number" && option < 0) ? stmt.length + option : option];\n                            if (opt) {\n                                vars = vars.concat(scan_for_nonlocal_defs(opt));\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    vars = vars.concat(scan_for_nonlocal_defs(body.body));\n                    if (body.alternative) {\n                        vars = vars.concat(scan_for_nonlocal_defs(body.alternative));\n                    }\n                }\n                return vars;\n            };\n            if (!scan_for_nonlocal_defs.__argnames__) Object.defineProperties(scan_for_nonlocal_defs, {\n                __argnames__ : {value: ["body"]}\n            });\n\n            function return_() {\n                var value, is_end_of_statement;\n                if (is_("punc", ";")) {\n                    semicolon();\n                    value = null;\n                } else {\n                    is_end_of_statement = S.token.nlb || is_("eof") || is_("punc", "}");\n                    if (is_end_of_statement) {\n                        value = null;\n                    } else {\n                        value = expression(true);\n                        semicolon();\n                    }\n                }\n                return value;\n            };\n\n            \n            var statement = embed_tokens(function statement() {\n                var tmp_, p, while_cond, start, func, chain, cond, msg, tmp;\n                if (S.token.type === "operator" && S.token.value.substr(0, 1) === "/") {\n                    token_error(S.token, "RapydScript does not support statements starting with regexp literals");\n                }\n                S.statement_starting_token = S.token;\n                tmp_ = S.token.type;\n                p = prev();\n                if (p && !S.token.nlb && ATOMIC_START_TOKEN[RS_bound_index(p.type, ATOMIC_START_TOKEN)] && !is_("punc", ":")) {\n                    unexpected();\n                }\n                if (tmp_ === "string") {\n                    return simple_statement();\n                } else if (tmp_ === "shebang") {\n                    tmp_ = S.token.value;\n                    next();\n                    return new AST_Directive((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["value"] = tmp_;\n                        return RS_d;\n                    }).call(this));\n                } else if (tmp_ === "num" || tmp_ === "regexp" || tmp_ === "operator" || tmp_ === "atom" || tmp_ === "js") {\n                    return simple_statement();\n                } else if (tmp_ === "punc") {\n                    tmp_ = S.token.value;\n                    if (tmp_ === ":") {\n                        return new AST_BlockStatement((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = S.token;\n                            RS_d["body"] = block_();\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "{" || tmp_ === "[" || tmp_ === "(") {\n                        return simple_statement();\n                    } else if (tmp_ === ";") {\n                        next();\n                        return new AST_EmptyStatement((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["stype"] = ";";\n                            RS_d["start"] = prev();\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this));\n                    } else {\n                        unexpected();\n                    }\n                } else if (tmp_ === "name") {\n                    if (is_token(peek(), "punc", ":")) token_error(peek(), "invalid syntax, colon not allowed here");\n                    return simple_statement();\n                } else if (tmp_ === "keyword") {\n                    tmp_ = S.token.value;\n                    next();\n                    if (tmp_ === "break") {\n                        return break_cont(AST_Break);\n                    } else if (tmp_ === "continue") {\n                        return break_cont(AST_Continue);\n                    } else if (tmp_ === "debugger") {\n                        semicolon();\n                        return new AST_Debugger;\n                    } else if (tmp_ === "do") {\n                        return new AST_Do((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["body"] = in_loop(statement);\n                            RS_d["condition"] = function () {\n                                var tmp;\n                                expect(".");\n                                expect_token("keyword", "while");\n                                tmp = expression(true);\n                                if (is_node_type(tmp, AST_Assign)) {\n                                    croak("Assignments in do loop conditions are not allowed");\n                                }\n                                semicolon();\n                                return tmp;\n                            }();\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "while") {\n                        while_cond = expression(true);\n                        if (is_node_type(while_cond, AST_Assign)) {\n                            croak("Assignments in while loop conditions are not allowed");\n                        }\n                        return new AST_While((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["condition"] = while_cond;\n                            RS_d["body"] = in_loop(statement);\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "for") {\n                        if (is_("js")) {\n                            return for_js();\n                        }\n                        return for_();\n                    } else if (tmp_ === "from") {\n                        return import_(true);\n                    } else if (tmp_ === "import") {\n                        return import_(false);\n                    } else if (tmp_ === "class") {\n                        return class_();\n                    } else if (tmp_ === "def") {\n                        start = prev();\n                        func = function_((RS_expr_temp = S.in_class)[RS_expr_temp.length-1], false);\n                        func.start = start;\n                        func.end = prev();\n                        chain = subscripts(func, true);\n                        if (chain === func) {\n                            return func;\n                        } else {\n                            return new AST_SimpleStatement((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["start"] = start;\n                                RS_d["body"] = chain;\n                                RS_d["end"] = prev();\n                                return RS_d;\n                            }).call(this));\n                        }\n                    } else if (tmp_ === "assert") {\n                        start = prev();\n                        cond = expression(false);\n                        msg = null;\n                        if (is_("punc", ",")) {\n                            next();\n                            msg = expression(false);\n                        }\n                        return new AST_Assert((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["condition"] = cond;\n                            RS_d["message"] = msg;\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "if") {\n                        return if_();\n                    } else if (tmp_ === "pass") {\n                        semicolon();\n                        return new AST_EmptyStatement((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["stype"] = "pass";\n                            RS_d["start"] = prev();\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "return") {\n                        if (S.in_function === 0) {\n                            croak("\'return\' outside of function");\n                        }\n                        if ((RS_expr_temp = S.functions)[RS_expr_temp.length-1].is_generator) {\n                            croak("\'return\' not allowed in a function with yield");\n                        }\n                        (RS_expr_temp = S.functions)[RS_expr_temp.length-1].is_generator = false;\n                        return new AST_Return((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["value"] = return_();\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "yield") {\n                        return yield_();\n                    } else if (tmp_ === "raise") {\n                        if (S.token.nlb) {\n                            return new AST_Throw((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["value"] = new AST_SymbolCatch((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["name"] = "RS_Exception";\n                                    return RS_d;\n                                }).call(this));\n                                return RS_d;\n                            }).call(this));\n                        }\n                        tmp = expression(true);\n                        semicolon();\n                        return new AST_Throw((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["value"] = tmp;\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp_ === "try") {\n                        return try_();\n                    } else if (tmp_ === "nonlocal") {\n                        tmp = nonlocal_();\n                        semicolon();\n                        return tmp;\n                    } else if (tmp_ === "global") {\n                        tmp = nonlocal_(true);\n                        semicolon();\n                        return tmp;\n                    } else if (tmp_ === "with") {\n                        return with_();\n                    } else {\n                        unexpected();\n                    }\n                }\n            });\n\n            function with_() {\n                var clauses, start, expr, alias, body;\n                clauses = [];\n                start = S.token;\n                while (true) {\n                    if (is_("eof")) {\n                        unexpected();\n                    }\n                    expr = expression();\n                    alias = null;\n                    if (is_("keyword", "as")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    clauses.push(new AST_WithClause((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["expression"] = expr;\n                        RS_d["alias"] = alias;\n                        return RS_d;\n                    }).call(this)));\n                    if (is_("punc", ",")) {\n                        next();\n                        continue;\n                    }\n                    if (!is_("punc", ":")) {\n                        unexpected();\n                    }\n                    break;\n                }\n                if (!clauses.length) {\n                    token_error(start, "with statement must have at least one clause");\n                }\n                body = statement();\n                return new AST_With((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["clauses"] = clauses;\n                    RS_d["body"] = body;\n                    return RS_d;\n                }).call(this));\n            };\n\n            function simple_statement(tmp) {\n                tmp = expression(true);\n                semicolon();\n                return new AST_SimpleStatement((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["body"] = tmp;\n                    return RS_d;\n                }).call(this));\n            };\n            if (!simple_statement.__argnames__) Object.defineProperties(simple_statement, {\n                __argnames__ : {value: ["tmp"]}\n            });\n\n            function break_cont(t) {\n                if (S.in_loop === 0) {\n                    croak(t.name.slice(4) + " not inside a loop or switch");\n                }\n                semicolon();\n                return new t;\n            };\n            if (!break_cont.__argnames__) Object.defineProperties(break_cont, {\n                __argnames__ : {value: ["t"]}\n            });\n\n            function yield_() {\n                var is_yield_from;\n                if (S.in_function === 0) {\n                    croak("\'yield\' outside of function");\n                }\n                if ((RS_expr_temp = S.functions)[RS_expr_temp.length-1].is_generator === false) {\n                    croak("\'yield\' not allowed in a function with return");\n                }\n                (RS_expr_temp = S.functions)[RS_expr_temp.length-1].is_generator = true;\n                is_yield_from = is_("keyword", "from");\n                if (is_yield_from) {\n                    next();\n                }\n                return new AST_Yield((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["is_yield_from"] = is_yield_from;\n                    RS_d["value"] = return_();\n                    return RS_d;\n                }).call(this));\n            };\n\n            function for_(list_comp) {\n                var init, tmp;\n                init = null;\n                if (!is_("punc", ";")) {\n                    init = expression(true, true);\n                    if (is_node_type(init, AST_Seq)) {\n                        if (is_node_type(init.car, AST_SymbolRef) && is_node_type(init.cdr, AST_SymbolRef)) {\n                            tmp = init.to_array();\n                        } else {\n                            tmp = RS_list_decorate([ init ]);\n                        }\n                        init = new AST_Array((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = init.start;\n                            RS_d["elements"] = tmp;\n                            RS_d["end"] = init.end;\n                            return RS_d;\n                        }).call(this));\n                    }\n                    if (is_("operator", "in")) {\n                        if (is_node_type(init, AST_Var) && init.definitions.length > 1) {\n                            croak("Only one variable declaration allowed in for..in loop");\n                        }\n                        next();\n                        return for_in(init, list_comp);\n                    }\n                }\n                unexpected();\n            };\n            if (!for_.__argnames__) Object.defineProperties(for_, {\n                __argnames__ : {value: ["list_comp"]}\n            });\n\n            function for_in(init, list_comp) {\n                var lhs, obj;\n                lhs = (is_node_type(init, AST_Var)) ? init.definitions[0].name : null;\n                obj = expression(true);\n                if (list_comp) {\n                    return (function(){\n                        var RS_d = Object.create(null);\n                        RS_d["init"] = init;\n                        RS_d["name"] = lhs;\n                        RS_d["object"] = obj;\n                        return RS_d;\n                    }).call(this);\n                }\n                return new AST_ForIn((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["init"] = init;\n                    RS_d["name"] = lhs;\n                    RS_d["object"] = obj;\n                    RS_d["body"] = in_loop(statement);\n                    return RS_d;\n                }).call(this));\n            };\n            if (!for_in.__argnames__) Object.defineProperties(for_in, {\n                __argnames__ : {value: ["init", "list_comp"]}\n            });\n\n            function for_js() {\n                var condition;\n                condition = as_atom_node();\n                return new AST_ForJS((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["condition"] = condition;\n                    RS_d["body"] = in_loop(statement);\n                    return RS_d;\n                }).call(this));\n            };\n\n            function get_class_in_scope(expr) {\n                var s, referenced_path, class_name;\n                if (is_node_type(expr, AST_SymbolRef)) {\n                    if (has_prop(NATIVE_CLASSES, expr.name)) {\n                        return NATIVE_CLASSES[RS_bound_index(expr.name, NATIVE_CLASSES)];\n                    }\n                    if (has_prop(ERROR_CLASSES, expr.name)) {\n                        return ERROR_CLASSES[RS_bound_index(expr.name, ERROR_CLASSES)];\n                    }\n                    for (var RS_Index52 = S.classes.length - 1; RS_Index52 > -1; RS_Index52-=1) {\n                        s = RS_Index52;\n                        if (has_prop((RS_expr_temp = S.classes)[(typeof s === "number" && s < 0) ? RS_expr_temp.length + s : s], expr.name)) {\n                            return (RS_expr_temp = (RS_expr_temp = S.classes)[(typeof s === "number" && s < 0) ? RS_expr_temp.length + s : s])[RS_bound_index(expr.name, RS_expr_temp)];\n                        }\n                    }\n                } else if (is_node_type(expr, AST_Dot)) {\n                    referenced_path = RS_list_decorate([]);\n                    while (is_node_type(expr, AST_Dot)) {\n                        referenced_path.unshift(expr.property);\n                        expr = expr.expression;\n                    }\n                    if (is_node_type(expr, AST_SymbolRef)) {\n                        referenced_path.unshift(expr.name);\n                        if (len(referenced_path) > 1) {\n                            class_name = referenced_path.join(".");\n                            for (var RS_Index53 = S.classes.length - 1; RS_Index53 > -1; RS_Index53-=1) {\n                                s = RS_Index53;\n                                if (has_prop((RS_expr_temp = S.classes)[(typeof s === "number" && s < 0) ? RS_expr_temp.length + s : s], class_name)) {\n                                    return (RS_expr_temp = (RS_expr_temp = S.classes)[(typeof s === "number" && s < 0) ? RS_expr_temp.length + s : s])[(typeof class_name === "number" && class_name < 0) ? RS_expr_temp.length + class_name : class_name];\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            };\n            if (!get_class_in_scope.__argnames__) Object.defineProperties(get_class_in_scope, {\n                __argnames__ : {value: ["expr"]}\n            });\n\n            function import_error(message) {\n                var ctx;\n                ctx = S.input.context();\n                throw new ImportError(message, ctx.filename, ctx.tokline, ctx.tokcol, ctx.tokpos);\n            };\n            if (!import_error.__argnames__) Object.defineProperties(import_error, {\n                __argnames__ : {value: ["message"]}\n            });\n\n            function do_import(key) {\n                var package_module_id, src_code, filename, modpath, RS_unpack, data, location, cached, srchash, ikey, bitem;\n                if (has_prop(imported_modules, key)) {\n                    return;\n                }\n                if (has_prop(importing_modules, key) && importing_modules[(typeof key === "number" && key < 0) ? importing_modules.length + key : key]) {\n                    import_error("Detected a recursive import of: " + key + " while importing: " + module_id);\n                }\n                package_module_id = key.split(".").slice(0, -1).join(".");\n                if (len(package_module_id) > 0) {\n                    do_import(package_module_id);\n                }\n                if (options.for_linting) {\n                    imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key] = (function(){\n                        var RS_d = Object.create(null);\n                        RS_d["is_cached"] = true;\n                        RS_d["classes"] = Object.create(null);\n                        RS_d["module_id"] = key;\n                        RS_d["exports"] = RS_list_decorate([]);\n                        RS_d["nonlocalvars"] = RS_list_decorate([]);\n                        RS_d["baselib"] = Object.create(null);\n                        RS_d["outputs"] = Object.create(null);\n                        RS_d["discard_asserts"] = options.discard_asserts;\n                        return RS_d;\n                    }).call(this);\n                    return;\n                }\n                function safe_read(base_path) {\n                    var RS_unpack, i, path;\n                    var RS_Iter54 = RS_Iterable(enumerate(RS_list_decorate([ base_path + ".pyj", base_path + "/__init__.pyj" ])));\n                    for (var RS_Index54 = 0; RS_Index54 < RS_Iter54.length; RS_Index54++) {\n                        RS_unpack = RS_Iter54[RS_Index54];\n                        i = RS_unpack[0];\n                        path = RS_unpack[1];\n                        try {\n                            return RS_list_decorate([ readfile(path, "utf-8"), path ]);\n                        } catch (RS_Exception) {\n                            RS_last_exception = RS_Exception;\n                            {\n                                var e = RS_Exception;\n                                if (e.code === "ENOENT" || e.code === "EPERM" || e.code === "EACCESS") {\n                                    if (i === 1) {\n                                        return [null, null];\n                                    }\n                                }\n                                if (i === 1) {\n                                    throw RS_Exception;\n                                }\n                            } \n                        }\n                    }\n                };\n                if (!safe_read.__argnames__) Object.defineProperties(safe_read, {\n                    __argnames__ : {value: ["base_path"]}\n                });\n\n                src_code = filename = null;\n                modpath = key.replace(/\\./g, "/");\n                var RS_Iter55 = RS_Iterable(import_dirs);\n                for (var RS_Index55 = 0; RS_Index55 < RS_Iter55.length; RS_Index55++) {\n                    location = RS_Iter55[RS_Index55];\n                    if (location) {\n                        RS_unpack = safe_read(location + "/" + modpath);\nRS_unpack = RS_unpack_asarray(2, RS_unpack);\n                        data = RS_unpack[0];\n                        filename = RS_unpack[1];\n                        if (data !== null) {\n                            src_code = data;\n                            break;\n                        }\n                    }\n                }\n                if (src_code === null) {\n                    import_error("Failed Import: \'" + key + "\' module doesn\'t exist in any of the import directories: " + import_dirs.join(":"));\n                }\n                try {\n                    cached = JSON.parse(readfile(cache_file_name(filename, options.module_cache_dir), "utf-8"));\n                } catch (RS_Exception) {\n                    RS_last_exception = RS_Exception;\n                    {\n                        cached = null;\n                    } \n                }\n                srchash = sha1sum(src_code);\n                if (cached && cached.version === COMPILER_VERSION && cached.signature === srchash && cached.discard_asserts === options.discard_asserts) {\n                    var RS_Iter56 = RS_Iterable(cached.imported_module_ids);\n                    for (var RS_Index56 = 0; RS_Index56 < RS_Iter56.length; RS_Index56++) {\n                        ikey = RS_Iter56[RS_Index56];\n                        do_import(ikey);\n                    }\n                    imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key] = (function(){\n                        var RS_d = Object.create(null);\n                        RS_d["is_cached"] = true;\n                        RS_d["classes"] = cached.classes;\n                        RS_d["outputs"] = cached.outputs;\n                        RS_d["module_id"] = key;\n                        RS_d["import_order"] = Object.keys(imported_modules).length;\n                        RS_d["nonlocalvars"] = cached.nonlocalvars;\n                        RS_d["baselib"] = cached.baselib;\n                        RS_d["exports"] = cached.exports;\n                        RS_d["discard_asserts"] = options.discard_asserts;\n                        RS_d["imported_module_ids"] = cached.imported_module_ids;\n                        return RS_d;\n                    }).call(this);\n                } else {\n                    parse(src_code, (function(){\n                        var RS_d = Object.create(null);\n                        RS_d["filename"] = filename;\n                        RS_d["toplevel"] = null;\n                        RS_d["basedir"] = options.basedir;\n                        RS_d["libdir"] = options.libdir;\n                        RS_d["import_dirs"] = options.import_dirs;\n                        RS_d["module_id"] = key;\n                        RS_d["imported_modules"] = imported_modules;\n                        RS_d["importing_modules"] = importing_modules;\n                        RS_d["discard_asserts"] = options.discard_asserts;\n                        RS_d["module_cache_dir"] = options.module_cache_dir;\n                        return RS_d;\n                    }).call(this));\n                }\n                imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key].srchash = srchash;\n                var RS_Iter57 = RS_Iterable(Object.keys(imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key].baselib));\n                for (var RS_Index57 = 0; RS_Index57 < RS_Iter57.length; RS_Index57++) {\n                    bitem = RS_Iter57[RS_Index57];\n                    baselib_items[(typeof bitem === "number" && bitem < 0) ? baselib_items.length + bitem : bitem] = true;\n                }\n            };\n            if (!do_import.__argnames__) Object.defineProperties(do_import, {\n                __argnames__ : {value: ["key"]}\n            });\n\n            function read_python_flags() {\n                var bracketed, name, val;\n                expect_token("keyword", "import");\n                bracketed = is_("punc", "(");\n                if (bracketed) {\n                    next();\n                }\n                while (true) {\n                    if (!is_("name")) {\n                        croak("Name expected");\n                    }\n                    name = S.token.value;\n                    val = (name.startsWith("no_")) ? false : true;\n                    if (!val) {\n                        name = name.slice(3);\n                    }\n                    if (!PYTHON_FLAGS) {\n                        croak("Unknown __python__ flag: " + name);\n                    }\n                    S.scoped_flags.set(name, val);\n                    next();\n                    if (is_("punc", ",")) {\n                        next();\n                    } else {\n                        if (bracketed) {\n                            if (is_("punc", ")")) {\n                                next();\n                            } else {\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                }\n                return new AST_EmptyStatement((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["stype"] = "scoped_flags";\n                    RS_d["start"] = prev();\n                    RS_d["end"] = prev();\n                    return RS_d;\n                }).call(this));\n            };\n\n            function import_(from_import) {\n                var ans, tok, tmp, name, last_tok, key, alias, aimp, RS_unpack, classes, argnames, bracketed, exports, symdef, aname, obj, argvar, cname, imp;\n                ans = new AST_Imports((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["imports"] = RS_list_decorate([]);\n                    return RS_d;\n                }).call(this));\n                while (true) {\n                    tok = tmp = name = last_tok = expression(false);\n                    key = "";\n                    while (is_node_type(tmp, AST_Dot)) {\n                        key = "." + tmp.property + key;\n                        tmp = last_tok = tmp.expression;\n                    }\n                    key = tmp.name + key;\n                    if (from_import && key === "__python__") {\n                        return read_python_flags();\n                    }\n                    alias = null;\n                    if (!from_import && is_("keyword", "as")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    aimp = new AST_Import((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["module"] = name;\n                        RS_d["key"] = key;\n                        RS_d["alias"] = alias;\n                        RS_d["argnames"] = null;\n                        RS_d["body"] = function () {\n                            return imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key];\n                        };\n                        return RS_d;\n                    }).call(this));\n                    RS_unpack = [tok.start, last_tok.end];\n                    aimp.start = RS_unpack[0];\n                    aimp.end = RS_unpack[1];\n                    ans.imports.push(aimp);\n                    if (from_import) {\n                        break;\n                    }\n                    if (is_("punc", ",")) {\n                        next();\n                    } else {\n                        break;\n                    }\n                }\n                var RS_Iter58 = RS_Iterable(ans["imports"]);\n                for (var RS_Index58 = 0; RS_Index58 < RS_Iter58.length; RS_Index58++) {\n                    imp = RS_Iter58[RS_Index58];\n                    do_import(imp.key);\n                    if (imported_module_ids.indexOf(imp.key) === -1) {\n                        imported_module_ids.push(imp.key);\n                    }\n                    classes = imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key].classes;\n                    if (from_import) {\n                        expect_token("keyword", "import");\n                        imp.argnames = argnames = RS_list_decorate([]);\n                        bracketed = is_("punc", "(");\n                        if (bracketed) {\n                            next();\n                        }\n                        exports = Object.create(null);\n                        var RS_Iter59 = RS_Iterable(imported_modules[(typeof key === "number" && key < 0) ? imported_modules.length + key : key].exports);\n                        for (var RS_Index59 = 0; RS_Index59 < RS_Iter59.length; RS_Index59++) {\n                            symdef = RS_Iter59[RS_Index59];\n                            exports[RS_bound_index(symdef.name, exports)] = true;\n                        }\n                        while (true) {\n                            aname = as_symbol(AST_ImportedVar);\n                            if (!options.for_linting && !has_prop(exports, aname.name)) {\n                                import_error("The symbol \\"" + aname.name + "\\" is not exported from the module: " + key);\n                            }\n                            if (is_("keyword", "as")) {\n                                next();\n                                aname.alias = as_symbol(AST_SymbolAlias);\n                            }\n                            argnames.push(aname);\n                            if (is_("punc", ",")) {\n                                next();\n                            } else {\n                                if (bracketed) {\n                                    if (is_("punc", ")")) {\n                                        next();\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                        var RS_Iter60 = RS_Iterable(argnames);\n                        for (var RS_Index60 = 0; RS_Index60 < RS_Iter60.length; RS_Index60++) {\n                            argvar = RS_Iter60[RS_Index60];\n                            obj = classes[RS_bound_index(argvar.name, classes)];\n                            if (obj) {\n                                key = (argvar.alias) ? argvar.alias.name : argvar.name;\n                                (RS_expr_temp = (RS_expr_temp = S.classes)[RS_expr_temp.length-1])[(typeof key === "number" && key < 0) ? RS_expr_temp.length + key : key] = (function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["static"] = obj.static;\n                                    RS_d["bound"] = obj.bound;\n                                    RS_d["classvars"] = obj.classvars;\n                                    return RS_d;\n                                }).call(this);\n                            }\n                        }\n                    } else {\n                        var RS_Iter61 = RS_Iterable(Object.keys(classes));\n                        for (var RS_Index61 = 0; RS_Index61 < RS_Iter61.length; RS_Index61++) {\n                            cname = RS_Iter61[RS_Index61];\n                            obj = classes[(typeof cname === "number" && cname < 0) ? classes.length + cname : cname];\n                            key = (imp.alias) ? imp.alias.name : imp.key;\n                            (RS_expr_temp = (RS_expr_temp = S.classes)[RS_expr_temp.length-1])[RS_bound_index(key + "." + obj.name.name, RS_expr_temp)] = (function(){\n                                var RS_d = Object.create(null);\n                                RS_d["static"] = obj.static;\n                                RS_d["bound"] = obj.bound;\n                                RS_d["classvars"] = obj.classvars;\n                                return RS_d;\n                            }).call(this);\n                        }\n                    }\n                }\n                return ans;\n            };\n            if (!import_.__argnames__) Object.defineProperties(import_, {\n                __argnames__ : {value: ["from_import"]}\n            });\n\n            function class_() {\n                var name, externaldecorator, class_details, bases, class_parent, a, docstrings, definition, descriptor, stmt, class_var_names, visitor;\n                name = as_symbol(AST_SymbolDefun);\n                if (!name) {\n                    unexpected();\n                }\n                externaldecorator = has_simple_decorator(S.decorators, "external");\n                class_details = (function(){\n                    var RS_d = Object.create(null);\n                    RS_d["static"] = Object.create(null);\n                    RS_d["bound"] = [];\n                    RS_d["classvars"] = Object.create(null);\n                    RS_d["processing"] = name.name;\n                    RS_d["provisional_classvars"] = Object.create(null);\n                    return RS_d;\n                }).call(this);\n                bases = [];\n                class_parent = null;\n                if (is_("punc", "(")) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    while (true) {\n                        if (is_("punc", ")")) {\n                            S.in_parenthesized_expr = false;\n                            next();\n                            break;\n                        }\n                        a = expr_atom(false);\n                        if (class_parent === null) {\n                            class_parent = a;\n                        }\n                        bases.push(a);\n                        if (is_("punc", ",")) {\n                            next();\n                            continue;\n                        }\n                    }\n                }\n                docstrings = [];\n                definition = new AST_Class((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["name"] = name;\n                    RS_d["docstrings"] = docstrings;\n                    RS_d["module_id"] = module_id;\n                    RS_d["dynamic_properties"] = Object.create(null);\n                    RS_d["parent"] = class_parent;\n                    RS_d["bases"] = bases;\n                    RS_d["localvars"] = RS_list_decorate([]);\n                    RS_d["classvars"] = class_details.classvars;\n                    RS_d["static"] = class_details.static;\n                    RS_d["external"] = externaldecorator;\n                    RS_d["bound"] = class_details.bound;\n                    RS_d["statements"] = RS_list_decorate([]);\n                    RS_d["decorators"] = function () {\n                        var d, decorator;\n                        d = RS_list_decorate([]);\n                        var RS_Iter62 = RS_Iterable(S.decorators);\n                        for (var RS_Index62 = 0; RS_Index62 < RS_Iter62.length; RS_Index62++) {\n                            decorator = RS_Iter62[RS_Index62];\n                            d.push(new AST_Decorator((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["expression"] = decorator;\n                                return RS_d;\n                            }).call(this)));\n                        }\n                        S.decorators = [];\n                        return d;\n                    }();\n                    RS_d["body"] = (function() {\n                        var RS_anonfunc = function (loop, labels) {\n                            var a;\n                            S.in_class.push(name.name);\n                            (RS_expr_temp = (RS_expr_temp = S.classes)[RS_bound_index(S.classes.length - 1, RS_expr_temp)])[RS_bound_index(name.name, RS_expr_temp)] = class_details;\n                            S.classes.push(Object.create(null));\n                            S.scoped_flags.push();\n                            S.in_function += 1;\n                            S.in_loop = 0;\n                            S.labels = RS_list_decorate([]);\n                            a = block_(docstrings);\n                            S.in_function -= 1;\n                            S.scoped_flags.pop();\n                            S.classes.pop();\n                            S.in_class.pop();\n                            S.in_loop = loop;\n                            S.labels = labels;\n                            return a;\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["loop", "labels"]}\n                        });\n                        return RS_anonfunc;\n                    })()(S.in_loop, S.labels);\n                    return RS_d;\n                }).call(this));\n                class_details.processing = false;\n                var RS_Iter63 = RS_Iterable(definition.body);\n                for (var RS_Index63 = 0; RS_Index63 < RS_Iter63.length; RS_Index63++) {\n                    stmt = RS_Iter63[RS_Index63];\n                    if (is_node_type(stmt, AST_Method)) {\n                        if (stmt.is_getter || stmt.is_setter) {\n                            descriptor = (RS_expr_temp = definition.dynamic_properties)[RS_bound_index(stmt.name.name, RS_expr_temp)];\n                            if (!descriptor) {\n                                descriptor = (RS_expr_temp = definition.dynamic_properties)[RS_bound_index(stmt.name.name, RS_expr_temp)] = Object.create(null);\n                            }\n                            descriptor[RS_bound_index((stmt.is_getter) ? "getter" : "setter", descriptor)] = stmt;\n                        } else if (stmt.name.name === "__init__") {\n                            definition.init = stmt;\n                        }\n                    }\n                }\n                class_var_names = Object.create(null);\n                function walker() {\n                    function visit_node(node, descend) {\n                        var varname;\n                        if (is_node_type(node, AST_Method)) {\n                            class_var_names[RS_bound_index(node.name.name, class_var_names)] = true;\n                            return;\n                        } else if (is_node_type(node, AST_Assign) && is_node_type(node.left, AST_SymbolRef)) {\n                            varname = node.left.name;\n                            if (FORBIDDEN_CLASS_VARS.indexOf(varname) !== -1) {\n                                token_error(node.left.start, varname + " is not allowed as a class variable name");\n                            }\n                            class_var_names[(typeof varname === "number" && varname < 0) ? class_var_names.length + varname : varname] = true;\n                            (RS_expr_temp = definition.classvars)[(typeof varname === "number" && varname < 0) ? RS_expr_temp.length + varname : varname] = true;\n                        } else if (is_node_type(node, AST_SymbolRef) && has_prop(class_var_names, node.name)) {\n                            node.thedef = new AST_SymbolDefun((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["name"] = name.name + ".prototype." + node.name;\n                                return RS_d;\n                            }).call(this));\n                        }\n                        if (descend) {\n                            descend.call(node);\n                        }\n                    };\n                    if (!visit_node.__argnames__) Object.defineProperties(visit_node, {\n                        __argnames__ : {value: ["node", "descend"]}\n                    });\n\n                    this._visit = visit_node;\n                };\n\n                visitor = new walker;\n                var RS_Iter64 = RS_Iterable(definition.body);\n                for (var RS_Index64 = 0; RS_Index64 < RS_Iter64.length; RS_Index64++) {\n                    stmt = RS_Iter64[RS_Index64];\n                    if (!is_node_type(stmt, AST_Class)) {\n                        stmt.walk(visitor);\n                        definition.statements.push(stmt);\n                    }\n                }\n                return definition;\n            };\n\n            function function_(in_class, is_expression) {\n                var name, is_anonymous, staticmethod, property_getter, property_setter, staticloc, ctor, return_annotation, is_generator, docstrings, definition, assignments, j, i, nonlocals;\n                name = (is_("name")) ? as_symbol((in_class) ? AST_SymbolDefun : AST_SymbolLambda) : null;\n                if (in_class && !name) {\n                    croak("Cannot use anonymous function as class methods");\n                }\n                is_anonymous = !name;\n                staticmethod = property_getter = property_setter = false;\n                if (in_class) {\n                    staticloc = has_simple_decorator(S.decorators, "staticmethod");\n                    property_getter = has_simple_decorator(S.decorators, "property");\n                    property_setter = has_setter_decorator(S.decorators, name.name);\n                    if (staticloc) {\n                        if (property_getter || property_setter) {\n                            croak("A method cannot be both static and a property getter/setter");\n                        }\n                        (RS_expr_temp = (RS_expr_temp = (RS_expr_temp = S.classes)[RS_bound_index(S.classes.length - 2, RS_expr_temp)])[(typeof in_class === "number" && in_class < 0) ? RS_expr_temp.length + in_class : in_class].static)[RS_bound_index(name.name, RS_expr_temp)] = true;\n                        staticmethod = true;\n                    } else if (name.name !== "__init__" && S.scoped_flags.get("bound_methods")) {\n                        (RS_expr_temp = (RS_expr_temp = S.classes)[RS_bound_index(S.classes.length - 2, RS_expr_temp)])[(typeof in_class === "number" && in_class < 0) ? RS_expr_temp.length + in_class : in_class].bound.push(name.name);\n                    }\n                }\n                expect("(");\n                S.in_parenthesized_expr = true;\n                ctor = (in_class) ? AST_Method : AST_Function;\n                return_annotation = null;\n                is_generator = [];\n                docstrings = [];\n                definition = new ctor((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["name"] = name;\n                    RS_d["is_expression"] = is_expression;\n                    RS_d["is_anonymous"] = is_anonymous;\n                    RS_d["argnames"] = (function() {\n                        var RS_anonfunc = function (a) {\n                            var defaults, first, seen_names, def_line, current_arg_name, name_token;\n                            defaults = Object.create(null);\n                            first = true;\n                            seen_names = Object.create(null);\n                            def_line = S.input.context().tokline;\n                            current_arg_name = null;\n                            name_token = null;\n                            function get_arg() {\n                                var name_ctx, ntok, annotation, sym;\n                                current_arg_name = S.token.value;\n                                if (has_prop(seen_names, current_arg_name)) {\n                                    token_error(prev(), "Can\'t repeat parameter names");\n                                }\n                                if (current_arg_name === "arguments") {\n                                    token_error(prev(), "Can\'t use the name arguments as a parameter name, it is reserved by JavaScript");\n                                }\n                                seen_names[(typeof current_arg_name === "number" && current_arg_name < 0) ? seen_names.length + current_arg_name : current_arg_name] = true;\n                                name_token = S.token;\n                                name_ctx = S.input.context();\n                                ntok = peek();\n                                if (ntok.type === "punc" && ntok.value === ":") {\n                                    next();\n                                    expect(":");\n                                    annotation = maybe_conditional();\n                                    if (!is_token(name_token, "name")) {\n                                        croak("Name expected", name_ctx.tokline);\n                                        return null;\n                                    }\n                                    sym = new AST_SymbolFunarg((function(){\n                                        var RS_d = Object.create(null);\n                                        RS_d["name"] = name_token.value;\n                                        RS_d["start"] = S.token;\n                                        RS_d["end"] = S.token;\n                                        RS_d["annotation"] = annotation;\n                                        return RS_d;\n                                    }).call(this));\n                                    return sym;\n                                } else {\n                                    if (!is_("name")) {\n                                        if (S.input.context().tokline !== def_line) {\n                                            croak("Name expected", def_line);\n                                        } else {\n                                            croak("Name expected");\n                                        }\n                                        return null;\n                                    }\n                                    sym = new AST_SymbolFunarg((function(){\n                                        var RS_d = Object.create(null);\n                                        RS_d["name"] = current_arg_name;\n                                        RS_d["start"] = S.token;\n                                        RS_d["end"] = S.token;\n                                        RS_d["annotation"] = null;\n                                        return RS_d;\n                                    }).call(this));\n                                    next();\n                                    return sym;\n                                }\n                            };\n\n                            while (!is_("punc", ")")) {\n                                if (first) {\n                                    first = false;\n                                } else {\n                                    expect(",");\n                                    if (is_("punc", ")")) {\n                                        break;\n                                    }\n                                }\n                                if (is_("operator", "**")) {\n                                    next();\n                                    if (a.kwargs) {\n                                        token_error(name_token, "Can\'t define multiple **kwargs in function definition");\n                                    }\n                                    a.kwargs = get_arg();\n                                } else if (is_("operator", "*")) {\n                                    next();\n                                    if (a.starargs) {\n                                        token_error(name_token, "Can\'t define multiple *args in function definition");\n                                    }\n                                    if (a.kwargs) {\n                                        token_error(name_token, "Can\'t define *args after **kwargs in function definition");\n                                    }\n                                    a.starargs = get_arg();\n                                } else {\n                                    if (a.starargs || a.kwargs) {\n                                        token_error(name_token, "Can\'t define a formal parameter after *args or **kwargs");\n                                    }\n                                    a.push(get_arg());\n                                    if (is_("operator", "=")) {\n                                        if (a.kwargs) {\n                                            token_error(name_token, "Can\'t define an optional formal parameter after **kwargs");\n                                        }\n                                        next();\n                                        defaults[(typeof current_arg_name === "number" && current_arg_name < 0) ? defaults.length + current_arg_name : current_arg_name] = expression(false);\n                                        a.has_defaults = true;\n                                    } else {\n                                        if (a.has_defaults) {\n                                            token_error(name_token, "Can\'t define required formal parameters after optional formal parameters");\n                                        }\n                                    }\n                                }\n                            }\n                            next();\n                            if (is_("punc", "->")) {\n                                next();\n                                return_annotation = maybe_conditional();\n                            }\n                            S.in_parenthesized_expr = false;\n                            a.defaults = defaults;\n                            a.is_simple_func = !a.starargs && !a.kwargs && !a.has_defaults;\n                            return a;\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["a"]}\n                        });\n                        return RS_anonfunc;\n                    })()([]);\n                    RS_d["localvars"] = RS_list_decorate([]);\n                    RS_d["decorators"] = function () {\n                        var d, decorator;\n                        d = [];\n                        var RS_Iter65 = RS_Iterable(S.decorators);\n                        for (var RS_Index65 = 0; RS_Index65 < RS_Iter65.length; RS_Index65++) {\n                            decorator = RS_Iter65[RS_Index65];\n                            d.push(new AST_Decorator((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["expression"] = decorator;\n                                return RS_d;\n                            }).call(this)));\n                        }\n                        S.decorators = [];\n                        return d;\n                    }();\n                    RS_d["docstrings"] = docstrings;\n                    RS_d["body"] = (function() {\n                        var RS_anonfunc = function (loop, labels) {\n                            var a;\n                            S.in_class.push(false);\n                            S.classes.push(Object.create(null));\n                            S.scoped_flags.push();\n                            S.in_function += 1;\n                            S.functions.push(Object.create(null));\n                            S.in_loop = 0;\n                            S.labels = RS_list_decorate([]);\n                            a = block_(docstrings);\n                            S.in_function -= 1;\n                            S.scoped_flags.pop();\n                            is_generator.push(bool(S.functions.pop().is_generator));\n                            S.classes.pop();\n                            S.in_class.pop();\n                            S.in_loop = loop;\n                            S.labels = labels;\n                            return a;\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["loop", "labels"]}\n                        });\n                        return RS_anonfunc;\n                    })()(S.in_loop, S.labels);\n                    return RS_d;\n                }).call(this));\n                definition.return_annotation = return_annotation;\n                definition.is_generator = is_generator[0];\n                if (is_node_type(definition, AST_Method)) {\n                    definition.static = staticmethod;\n                    definition.is_getter = property_getter;\n                    definition.is_setter = property_setter;\n                    if (definition.argnames.length < 1 && !definition.static) {\n                        croak("Methods of a class must have at least one argument, traditionally named self");\n                    }\n                    if (definition.name && definition.name.name === "__init__") {\n                        if (definition.is_generator) {\n                            croak("The __init__ method of a class cannot be a generator (yield not allowed)");\n                        }\n                        if (property_getter || property_setter) {\n                            croak("The __init__ method of a class cannot be a property getter/setter");\n                        }\n                    }\n                }\n                if (definition.is_generator) {\n                    baselib_items["yield"] = true;\n                }\n                assignments = scan_for_local_vars(definition.body);\n                for (var RS_Index66 = 0; RS_Index66 < assignments.length; RS_Index66++) {\n                    i = RS_Index66;\n                    for (var RS_Index67 = 0; RS_Index67 < definition.argnames.length + 1; RS_Index67++) {\n                        j = RS_Index67;\n                        if (j === definition.argnames.length) {\n                            definition.localvars.push(new_symbol(AST_SymbolVar, assignments[(typeof i === "number" && i < 0) ? assignments.length + i : i]));\n                        } else if (j < definition.argnames.length && assignments[(typeof i === "number" && i < 0) ? assignments.length + i : i] === (RS_expr_temp = definition.argnames)[(typeof j === "number" && j < 0) ? RS_expr_temp.length + j : j].name) {\n                            break;\n                        }\n                    }\n                }\n                nonlocals = scan_for_nonlocal_defs(definition.body);\n                nonlocals = (function() {\n                    var RS_Iter = RS_Iterable(nonlocals), RS_Result = RS_set(), name;\n                    for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                        name = RS_Iter[RS_Index];\n                        RS_Result.add(name);\n                    }\n                    return RS_Result;\n                })();\n                definition.localvars = definition.localvars.filter((function() {\n                    var RS_anonfunc = function (v) {\n                        return !nonlocals.has(v.name);\n                    };\n                    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                        __argnames__ : {value: ["v"]}\n                    });\n                    return RS_anonfunc;\n                })());\n                return definition;\n            };\n            if (!function_.__argnames__) Object.defineProperties(function_, {\n                __argnames__ : {value: ["in_class", "is_expression"]}\n            });\n\n            function if_() {\n                var cond, body, belse;\n                cond = expression(true);\n                body = statement();\n                belse = null;\n                if (is_("keyword", "elif") || is_("keyword", "else")) {\n                    if (is_("keyword", "else")) {\n                        next();\n                    } else {\n                        S.token.value = "if";\n                    }\n                    belse = statement();\n                }\n                return new AST_If((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["condition"] = cond;\n                    RS_d["body"] = body;\n                    RS_d["alternative"] = belse;\n                    return RS_d;\n                }).call(this));\n            };\n\n            function is_docstring(stmt) {\n                if (is_node_type(stmt, AST_SimpleStatement)) {\n                    if (is_node_type(stmt.body, AST_String)) {\n                        return stmt.body;\n                    }\n                }\n                return false;\n            };\n            if (!is_docstring.__argnames__) Object.defineProperties(is_docstring, {\n                __argnames__ : {value: ["stmt"]}\n            });\n\n            function block_(docstrings) {\n                var prev_whitespace, a, stmt, ds, current_whitespace;\n                prev_whitespace = S.token.leading_whitespace;\n                expect(":");\n                a = [];\n                if (!S.token.nlb) {\n                    while (!S.token.nlb) {\n                        if (is_("eof")) {\n                            unexpected();\n                        }\n                        stmt = statement();\n                        if (docstrings) {\n                            ds = is_docstring(stmt);\n                            if (ds) {\n                                docstrings.push(ds);\n                                continue;\n                            }\n                        }\n                        a.push(stmt);\n                    }\n                } else {\n                    current_whitespace = S.token.leading_whitespace;\n                    if (current_whitespace.length === 0 || prev_whitespace === current_whitespace) {\n                        croak("Expected an indented block");\n                    }\n                    while (!is_("punc", "}")) {\n                        if (is_("eof")) {\n                            return a;\n                        }\n                        stmt = statement();\n                        if (docstrings) {\n                            ds = is_docstring(stmt);\n                            if (ds) {\n                                docstrings.push(ds);\n                                continue;\n                            }\n                        }\n                        a.push(stmt);\n                    }\n                    next();\n                }\n                return a;\n            };\n            if (!block_.__argnames__) Object.defineProperties(block_, {\n                __argnames__ : {value: ["docstrings"]}\n            });\n\n            function try_() {\n                var body, bcatch, bfinally, belse, start, exceptions, name;\n                body = block_();\n                bcatch = [];\n                bfinally = null;\n                belse = null;\n                while (is_("keyword", "except")) {\n                    start = S.token;\n                    next();\n                    exceptions = RS_list_decorate([]);\n                    if (!is_("punc", ":") && !is_("keyword", "as")) {\n                        exceptions.push(as_symbol(AST_SymbolVar));\n                        while (is_("punc", ",")) {\n                            next();\n                            exceptions.push(as_symbol(AST_SymbolVar));\n                        }\n                    }\n                    name = null;\n                    if (is_("keyword", "as")) {\n                        next();\n                        name = as_symbol(AST_SymbolCatch);\n                    }\n                    bcatch.push(new AST_Except((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["argname"] = name;\n                        RS_d["errors"] = exceptions;\n                        RS_d["body"] = block_();\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)));\n                }\n                if (is_("keyword", "else")) {\n                    start = S.token;\n                    next();\n                    belse = new AST_Else((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["body"] = block_();\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this));\n                }\n                if (is_("keyword", "finally")) {\n                    start = S.token;\n                    next();\n                    bfinally = new AST_Finally((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["body"] = block_();\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this));\n                }\n                if (!bcatch.length && !bfinally) {\n                    croak("Missing except/finally blocks");\n                }\n                return new AST_Try((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["body"] = body;\n                    RS_d["bcatch"] = (bcatch.length) ? new AST_Catch((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["body"] = bcatch;\n                        return RS_d;\n                    }).call(this)) : null;\n                    RS_d["bfinally"] = bfinally;\n                    RS_d["belse"] = belse;\n                    return RS_d;\n                }).call(this));\n            };\n\n            function vardefs(symbol_class) {\n                var a;\n                a = RS_list_decorate([]);\n                while (true) {\n                    a.push(new AST_VarDef((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = S.token;\n                        RS_d["name"] = as_symbol(symbol_class);\n                        RS_d["value"] = (is_("operator", "=")) ? (next(), expression(false)) : null;\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)));\n                    if (!is_("punc", ",")) {\n                        break;\n                    }\n                    next();\n                }\n                return a;\n            };\n            if (!vardefs.__argnames__) Object.defineProperties(vardefs, {\n                __argnames__ : {value: ["symbol_class"]}\n            });\n\n            function nonlocal_(is_global) {\n                var defs, vardef;\n                defs = vardefs(AST_SymbolNonlocal);\n                if (is_global) {\n                    var RS_Iter68 = RS_Iterable(defs);\n                    for (var RS_Index68 = 0; RS_Index68 < RS_Iter68.length; RS_Index68++) {\n                        vardef = RS_Iter68[RS_Index68];\n                        S.globals.push(vardef.name.name);\n                    }\n                }\n                return new AST_Var((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["start"] = prev();\n                    RS_d["definitions"] = defs;\n                    RS_d["end"] = prev();\n                    return RS_d;\n                }).call(this));\n            };\n            if (!nonlocal_.__argnames__) Object.defineProperties(nonlocal_, {\n                __argnames__ : {value: ["is_global"]}\n            });\n\n            function new_() {\n                var start, newexp, args;\n                start = S.token;\n                expect_token("operator", "new");\n                newexp = expr_atom(false);\n                if (is_("punc", "(")) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    args = func_call_list();\n                    S.in_parenthesized_expr = false;\n                } else {\n                    args = func_call_list(true);\n                }\n                return subscripts(new AST_New((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["start"] = start;\n                    RS_d["expression"] = newexp;\n                    RS_d["args"] = args;\n                    RS_d["end"] = prev();\n                    return RS_d;\n                }).call(this)), true);\n            };\n\n            function string_() {\n                var strings, start;\n                strings = [];\n                start = S.token;\n                while (true) {\n                    strings.push(S.token.value);\n                    if (peek().type !== "string") {\n                        break;\n                    }\n                    next();\n                }\n                return new AST_String((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["start"] = start;\n                    RS_d["end"] = S.token;\n                    RS_d["value"] = strings.join("");\n                    return RS_d;\n                }).call(this));\n            };\n\n            function token_as_atom_node() {\n                var tok, tmp_, tmp__;\n                tok = S.token;\n                tmp_ = tok.type;\n                if (tmp_ === "name") {\n                    return token_as_symbol(tok, AST_SymbolRef);\n                } else if (tmp_ === "num") {\n                    return new AST_Number((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = tok;\n                        RS_d["end"] = tok;\n                        RS_d["value"] = tok.value;\n                        return RS_d;\n                    }).call(this));\n                } else if (tmp_ === "string") {\n                    return string_();\n                } else if (tmp_ === "regexp") {\n                    return new AST_RegExp((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = tok;\n                        RS_d["end"] = tok;\n                        RS_d["value"] = tok.value;\n                        return RS_d;\n                    }).call(this));\n                } else if (tmp_ === "atom") {\n                    tmp__ = tok.value;\n                    if (tmp__ === "False") {\n                        return new AST_False((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = tok;\n                            RS_d["end"] = tok;\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp__ === "True") {\n                        return new AST_True((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = tok;\n                            RS_d["end"] = tok;\n                            return RS_d;\n                        }).call(this));\n                    } else if (tmp__ === "None") {\n                        return new AST_Null((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = tok;\n                            RS_d["end"] = tok;\n                            return RS_d;\n                        }).call(this));\n                    }\n                } else if (tmp_ === "js") {\n                    return new AST_Verbatim((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = tok;\n                        RS_d["end"] = tok;\n                        RS_d["value"] = tok.value;\n                        return RS_d;\n                    }).call(this));\n                }\n                token_error(tok, "Expecting an atomic token (number/string/bool/regexp/js/None)");\n            };\n\n            function as_atom_node() {\n                var ret;\n                ret = token_as_atom_node();\n                next();\n                return ret;\n            };\n\n            function expr_atom(allow_calls) {\n                var start, tmp_, ex, ret, cls, func;\n                if (is_("operator", "new")) {\n                    return new_();\n                }\n                start = S.token;\n                if (is_("punc")) {\n                    tmp_ = start.value;\n                    if (tmp_ === "(") {\n                        S.in_parenthesized_expr = true;\n                        next();\n                        if (is_("punc", ")")) {\n                            next();\n                            return new AST_Array((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["elements"] = RS_list_decorate([]);\n                                return RS_d;\n                            }).call(this));\n                        }\n                        ex = expression(true);\n                        if (is_("keyword", "for")) {\n                            ret = read_comprehension(new AST_GeneratorComprehension((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["statement"] = ex;\n                                return RS_d;\n                            }).call(this)), ")");\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        }\n                        ex.start = start;\n                        ex.end = S.token;\n                        if (is_node_type(ex, AST_SymbolRef)) {\n                            ex.parens = true;\n                        }\n                        if (!is_node_type(ex, AST_GeneratorComprehension)) {\n                            expect(")");\n                        }\n                        if (is_node_type(ex, AST_UnaryPrefix)) {\n                            ex.parenthesized = true;\n                        }\n                        S.in_parenthesized_expr = false;\n                        return subscripts(ex, allow_calls);\n                    } else if (tmp_ === "[") {\n                        return subscripts(array_(), allow_calls);\n                    } else if (tmp_ === "{") {\n                        return subscripts(object_(), allow_calls);\n                    }\n                    unexpected();\n                }\n                if (is_("keyword", "class")) {\n                    next();\n                    cls = class_();\n                    cls.start = start;\n                    cls.end = prev();\n                    return subscripts(cls, allow_calls);\n                }\n                if (is_("keyword", "def")) {\n                    next();\n                    func = function_(false, true);\n                    func.start = start;\n                    func.end = prev();\n                    return subscripts(func, allow_calls);\n                }\n                if (is_("keyword", "yield")) {\n                    next();\n                    return yield_();\n                }\n                if (ATOMIC_START_TOKEN[RS_bound_index(S.token.type, ATOMIC_START_TOKEN)]) {\n                    return subscripts(as_atom_node(), allow_calls);\n                }\n                unexpected();\n            };\n            if (!expr_atom.__argnames__) Object.defineProperties(expr_atom, {\n                __argnames__ : {value: ["allow_calls"]}\n            });\n\n            function expr_list(closing, allow_trailing_comma, allow_empty, func_call) {\n                var first, a, saw_starargs, tmp, arg;\n                first = true;\n                a = RS_list_decorate([]);\n                saw_starargs = false;\n                while (!is_("punc", closing)) {\n                    if (saw_starargs) {\n                        token_error(prev(), "*args must be the last argument in a function call");\n                    }\n                    if (first) {\n                        first = false;\n                    } else {\n                        expect(",");\n                    }\n                    if (allow_trailing_comma && is_("punc", closing)) {\n                        break;\n                    }\n                    if (is_("operator", "*") && func_call) {\n                        saw_starargs = true;\n                        next();\n                    }\n                    if (is_("punc", ",") && allow_empty) {\n                        a.push(new AST_Hole((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = S.token;\n                            RS_d["end"] = S.token;\n                            return RS_d;\n                        }).call(this)));\n                    } else {\n                        a.push(expression(false));\n                    }\n                }\n                if (func_call) {\n                    tmp = RS_list_decorate([]);\n                    tmp.kwargs = RS_list_decorate([]);\n                    var RS_Iter69 = RS_Iterable(a);\n                    for (var RS_Index69 = 0; RS_Index69 < RS_Iter69.length; RS_Index69++) {\n                        arg = RS_Iter69[RS_Index69];\n                        if (is_node_type(arg, AST_Assign)) {\n                            tmp.kwargs.push(RS_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            tmp.push(arg);\n                        }\n                    }\n                    a = tmp;\n                }\n                next();\n                if (saw_starargs) {\n                    a.starargs = true;\n                }\n                return a;\n            };\n            if (!expr_list.__argnames__) Object.defineProperties(expr_list, {\n                __argnames__ : {value: ["closing", "allow_trailing_comma", "allow_empty", "func_call"]}\n            });\n\n            function func_call_list(empty) {\n                var a, first, single_comprehension, arg;\n                a = [];\n                first = true;\n                a.kwargs = [];\n                a.kwarg_items = [];\n                a.starargs = false;\n                if (empty) {\n                    return a;\n                }\n                single_comprehension = false;\n                while (!is_("punc", ")") && !is_("eof")) {\n                    if (!first) {\n                        expect(",");\n                        if (is_("punc", ")")) {\n                            break;\n                        }\n                    }\n                    if (is_("operator", "*")) {\n                        next();\n                        arg = expression(false);\n                        arg.is_array = true;\n                        a.push(arg);\n                        a.starargs = true;\n                    } else if (is_("operator", "**")) {\n                        next();\n                        a.kwarg_items.push(as_symbol(AST_SymbolRef, false));\n                        a.starargs = true;\n                    } else {\n                        arg = expression(false);\n                        if (is_node_type(arg, AST_Assign)) {\n                            a.kwargs.push(RS_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            if (is_("keyword", "for")) {\n                                if (!first) {\n                                    croak("Generator expression must be parenthesized if not sole argument");\n                                }\n                                a.push(read_comprehension(new AST_GeneratorComprehension((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["statement"] = arg;\n                                    return RS_d;\n                                }).call(this)), ")"));\n                                single_comprehension = true;\n                                break;\n                            }\n                            a.push(arg);\n                        }\n                    }\n                    first = false;\n                }\n                if (!single_comprehension) {\n                    next();\n                }\n                return a;\n            };\n            if (!func_call_list.__argnames__) Object.defineProperties(func_call_list, {\n                __argnames__ : {value: ["empty"]}\n            });\n\n            \n            var array_ = embed_tokens(function array_() {\n                var expr;\n                expect("[");\n                expr = RS_list_decorate([]);\n                if (!is_("punc", "]")) {\n                    expr.push(expression(false));\n                    if (is_("keyword", "for")) {\n                        return read_comprehension(new AST_ListComprehension((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["statement"] = expr[0];\n                            return RS_d;\n                        }).call(this)), "]");\n                    }\n                    if (!is_("punc", "]")) {\n                        expect(",");\n                    }\n                }\n                return new AST_Array((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["elements"] = expr.concat(expr_list("]", true, true));\n                    return RS_d;\n                }).call(this));\n            });\n\n            \n            var object_ = embed_tokens(function object_() {\n                var first, has_non_const_keys, is_pydict, is_jshash, a, start, ctx, orig, left, end;\n                expect("{");\n                first = true;\n                has_non_const_keys = false;\n                is_pydict = S.scoped_flags.get("dict_literals", false);\n                is_jshash = S.scoped_flags.get("hash_literals", false);\n                a = RS_list_decorate([]);\n                while (!is_("punc", "}")) {\n                    if (!first) {\n                        expect(",");\n                    }\n                    if (is_("punc", "}")) {\n                        break;\n                    }\n                    first = false;\n                    start = S.token;\n                    ctx = S.input.context();\n                    orig = ctx.expecting_object_literal_key;\n                    ctx.expecting_object_literal_key = true;\n                    try {\n                        left = expression(false);\n                    } finally {\n                        ctx.expecting_object_literal_key = orig;\n                    }\n                    if (is_("keyword", "for")) {\n                        return read_comprehension(new AST_SetComprehension((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["statement"] = left;\n                            return RS_d;\n                        }).call(this)), "}");\n                    }\n                    if (a.length === 0 && (is_("punc", ",") || is_("punc", "}"))) {\n                        end = prev();\n                        return set_(start, end, left);\n                    }\n                    if (!is_node_type(left, AST_Constant)) {\n                        has_non_const_keys = true;\n                    }\n                    expect(":");\n                    a.push(new AST_ObjectKeyVal((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["key"] = left;\n                        RS_d["value"] = expression(false);\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)));\n                    if (a.length === 1 && is_("keyword", "for")) {\n                        return dict_comprehension(a, is_pydict, is_jshash);\n                    }\n                }\n                next();\n                return new ((has_non_const_keys) ? AST_ExpressiveObject : AST_Object)((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["properties"] = a;\n                    RS_d["is_pydict"] = is_pydict;\n                    RS_d["is_jshash"] = is_jshash;\n                    return RS_d;\n                }).call(this));\n            });\n\n            function set_(start, end, expr) {\n                var ostart, a;\n                ostart = start;\n                a = RS_list_decorate([ new AST_SetItem((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["start"] = start;\n                    RS_d["end"] = end;\n                    RS_d["value"] = expr;\n                    return RS_d;\n                }).call(this)) ]);\n                while (!is_("punc", "}")) {\n                    expect(",");\n                    start = S.token;\n                    if (is_("punc", "}")) {\n                        break;\n                    }\n                    a.push(new AST_SetItem((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["value"] = expression(false);\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)));\n                }\n                next();\n                return new AST_Set((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["items"] = a;\n                    RS_d["start"] = ostart;\n                    RS_d["end"] = prev();\n                    return RS_d;\n                }).call(this));\n            };\n            if (!set_.__argnames__) Object.defineProperties(set_, {\n                __argnames__ : {value: ["start", "end", "expr"]}\n            });\n\n            function read_comprehension(obj, terminator) {\n                var forloop;\n                if (is_node_type(obj, AST_GeneratorComprehension)) {\n                    baselib_items["yield"] = true;\n                }\n                S.in_comprehension = true;\n                S.in_parenthesized_expr = false;\n                expect_token("keyword", "for");\n                forloop = for_(true);\n                obj.init = forloop.init;\n                obj.name = forloop.name;\n                obj.object = forloop.object;\n                obj.condition = (is_("punc", terminator)) ? null : (expect_token("keyword", "if"), \n                expression(true));\n                expect(terminator);\n                S.in_comprehension = false;\n                return obj;\n            };\n            if (!read_comprehension.__argnames__) Object.defineProperties(read_comprehension, {\n                __argnames__ : {value: ["obj", "terminator"]}\n            });\n\n            function dict_comprehension(a, is_pydict, is_jshash) {\n                var RS_unpack, left, right;\n                if (a.length) {\n                    RS_unpack = [a[0].key, a[0].value];\n                    left = RS_unpack[0];\n                    right = RS_unpack[1];\n                } else {\n                    left = expression(false);\n                    if (!is_("punc", ":")) {\n                        return read_comprehension(new AST_SetComprehension((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["statement"] = left;\n                            return RS_d;\n                        }).call(this)), "}");\n                    }\n                    expect(":");\n                    right = expression(false);\n                }\n                return read_comprehension(new AST_DictComprehension((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["statement"] = left;\n                    RS_d["value_statement"] = right;\n                    RS_d["is_pydict"] = is_pydict;\n                    RS_d["is_jshash"] = is_jshash;\n                    return RS_d;\n                }).call(this)), "}");\n            };\n            if (!dict_comprehension.__argnames__) Object.defineProperties(dict_comprehension, {\n                __argnames__ : {value: ["a", "is_pydict", "is_jshash"]}\n            });\n\n            function as_name() {\n                var tmp, tmp_;\n                tmp = S.token;\n                next();\n                tmp_ = tmp.type;\n                if (tmp_ === "name" || tmp_ === "operator" || tmp_ === "keyword" || tmp_ === "atom") {\n                    return tmp.value;\n                } else {\n                    unexpected();\n                }\n            };\n\n            function token_as_symbol(tok, ttype) {\n                var name;\n                name = tok.value;\n                if (RESERVED_WORDS[(typeof name === "number" && name < 0) ? RESERVED_WORDS.length + name : name] && name !== "this") {\n                    croak(name + " is a reserved word");\n                }\n                return new ((name === "this") ? AST_This : ttype)((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["name"] = String(tok.value);\n                    RS_d["start"] = tok;\n                    RS_d["end"] = tok;\n                    return RS_d;\n                }).call(this));\n            };\n            if (!token_as_symbol.__argnames__) Object.defineProperties(token_as_symbol, {\n                __argnames__ : {value: ["tok", "ttype"]}\n            });\n\n            function as_symbol(ttype, noerror) {\n                var sym;\n                if (!is_("name")) {\n                    if (!noerror) {\n                        croak("Name expected");\n                    }\n                    return null;\n                }\n                sym = token_as_symbol(S.token, ttype);\n                next();\n                return sym;\n            };\n            if (!as_symbol.__argnames__) Object.defineProperties(as_symbol, {\n                __argnames__ : {value: ["ttype", "noerror"]}\n            });\n\n            function new_symbol(type, name) {\n                var sym;\n                sym = new ((name === "this") ? AST_This : type)((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["name"] = String(name);\n                    RS_d["start"] = null;\n                    RS_d["end"] = null;\n                    return RS_d;\n                }).call(this));\n                return sym;\n            };\n            if (!new_symbol.__argnames__) Object.defineProperties(new_symbol, {\n                __argnames__ : {value: ["type", "name"]}\n            });\n\n            function is_static_method(cls, method) {\n                if (has_prop(COMMON_STATIC, method) || cls.static && has_prop(cls.static, method)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            };\n            if (!is_static_method.__argnames__) Object.defineProperties(is_static_method, {\n                __argnames__ : {value: ["cls", "method"]}\n            });\n\n            function getitem(expr, allow_calls) {\n                var start, is_py_sub, slice_bounds, is_slice, i, assignment;\n                start = expr.start;\n                next();\n                is_py_sub = S.scoped_flags.get("overload_getitem", false);\n                slice_bounds = [];\n                is_slice = false;\n                if (is_("punc", ":")) {\n                    slice_bounds.push(null);\n                } else {\n                    slice_bounds.push(expression(false));\n                }\n                if (is_("punc", ":")) {\n                    is_slice = true;\n                    next();\n                    if (is_("punc", ":")) {\n                        slice_bounds.push(null);\n                    } else if (!is_("punc", "]")) {\n                        slice_bounds.push(expression(false));\n                    }\n                }\n                if (is_("punc", ":")) {\n                    next();\n                    if (is_("punc", "]")) {\n                        unexpected();\n                    } else {\n                        slice_bounds.push(expression(false));\n                    }\n                }\n                expect("]");\n                if (is_slice) {\n                    if (is_("operator", "=")) {\n                        next();\n                        return subscripts(new AST_Splice((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["expression"] = expr;\n                            RS_d["property"] = slice_bounds[0] || new AST_Number((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["value"] = 0;\n                                return RS_d;\n                            }).call(this));\n                            RS_d["property2"] = slice_bounds[1];\n                            RS_d["assignment"] = expression(true);\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this)), allow_calls);\n                    } else if (slice_bounds.length === 3) {\n                        slice_bounds.unshift(slice_bounds.pop());\n                        if (!slice_bounds[slice_bounds.length-1]) {\n                            slice_bounds.pop();\n                            if (!slice_bounds[slice_bounds.length-1]) {\n                                slice_bounds.pop();\n                            }\n                        } else if (!slice_bounds[slice_bounds.length-2]) {\n                            slice_bounds[slice_bounds.length-2] = new AST_Undefined;\n                        }\n                        return subscripts(new AST_Call((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["expression"] = new AST_SymbolRef((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["name"] = (S.in_delete) ? "RS_delslice" : "RS_eslice";\n                                return RS_d;\n                            }).call(this));\n                            RS_d["args"] = RS_list_decorate([ expr ]).concat(slice_bounds);\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this)), allow_calls);\n                    } else {\n                        slice_bounds = (function() {\n                            var RS_Iter = RS_Iterable(slice_bounds), RS_Result = [], i;\n                            for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                                i = RS_Iter[RS_Index];\n                                RS_Result.push((i === null) ? new AST_Number((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["value"] = 0;\n                                    return RS_d;\n                                }).call(this)) : i);\n                            }\n                            RS_Result = RS_list_constructor(RS_Result);\n                            return RS_Result;\n                        })();\n                        if (S.in_delete) {\n                            return subscripts(new AST_Call((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["start"] = start;\n                                RS_d["expression"] = new AST_SymbolRef((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["name"] = "RS_delslice";\n                                    return RS_d;\n                                }).call(this));\n                                RS_d["args"] = RS_list_decorate([ expr, new AST_Number((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["value"] = 1;\n                                    return RS_d;\n                                }).call(this)) ]).concat(slice_bounds);\n                                RS_d["end"] = prev();\n                                return RS_d;\n                            }).call(this)), allow_calls);\n                        }\n                        return subscripts(new AST_Call((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["expression"] = new AST_Dot((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["start"] = start;\n                                RS_d["expression"] = expr;\n                                RS_d["property"] = "slice";\n                                RS_d["end"] = prev();\n                                return RS_d;\n                            }).call(this));\n                            RS_d["args"] = slice_bounds;\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this)), allow_calls);\n                    }\n                } else {\n                    if (is_py_sub) {\n                        assignment = null;\n                        if (is_("operator") && S.token.value === "=") {\n                            next();\n                            assignment = expression(true);\n                        }\n                        return subscripts(new AST_ItemAccess((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["expression"] = expr;\n                            RS_d["property"] = slice_bounds[0] || new AST_Number((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["value"] = 0;\n                                return RS_d;\n                            }).call(this));\n                            RS_d["assignment"] = assignment;\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this)), allow_calls);\n                    }\n                    return subscripts(new AST_Sub((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["expression"] = expr;\n                        RS_d["property"] = slice_bounds[0] || new AST_Number((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["value"] = 0;\n                            return RS_d;\n                        }).call(this));\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)), allow_calls);\n                }\n            };\n            if (!getitem.__argnames__) Object.defineProperties(getitem, {\n                __argnames__ : {value: ["expr", "allow_calls"]}\n            });\n\n            function call_(expr) {\n                var start, ret, c, funcname, tmp_, args;\n                start = expr.start;\n                S.in_parenthesized_expr = true;\n                next();\n                if (!expr.parens && get_class_in_scope(expr)) {\n                    ret = subscripts(new AST_New((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["expression"] = expr;\n                        RS_d["args"] = func_call_list();\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)), true);\n                    S.in_parenthesized_expr = false;\n                    return ret;\n                } else {\n                    if (is_node_type(expr, AST_Dot)) {\n                        c = get_class_in_scope(expr.expression);\n                    }\n                    if (c) {\n                        funcname = expr;\n                        ret = subscripts(new AST_ClassCall((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["class"] = expr.expression;\n                            RS_d["method"] = funcname.property;\n                            RS_d["static"] = is_static_method(c, funcname.property);\n                            RS_d["args"] = func_call_list();\n                            RS_d["end"] = prev();\n                            return RS_d;\n                        }).call(this)), true);\n                        S.in_parenthesized_expr = false;\n                        return ret;\n                    } else if (is_node_type(expr, AST_SymbolRef)) {\n                        tmp_ = expr.name;\n                        if (tmp_ === "jstype") {\n                            ret = new AST_UnaryPrefix((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["start"] = start;\n                                RS_d["operator"] = "typeof";\n                                RS_d["expression"] = func_call_list()[0];\n                                RS_d["end"] = prev();\n                                return RS_d;\n                            }).call(this));\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        } else if (tmp_ === "isinstance") {\n                            args = func_call_list();\n                            if (args.length !== 2) {\n                                croak("isinstance() must be called with exactly two arguments");\n                            }\n                            ret = new AST_Binary((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["start"] = start;\n                                RS_d["left"] = args[0];\n                                RS_d["operator"] = "instanceof";\n                                RS_d["right"] = args[1];\n                                RS_d["end"] = prev();\n                                return RS_d;\n                            }).call(this));\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        }\n                    }\n                    ret = subscripts(new AST_Call((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["expression"] = expr;\n                        RS_d["args"] = func_call_list();\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this)), true);\n                    S.in_parenthesized_expr = false;\n                    return ret;\n                }\n            };\n            if (!call_.__argnames__) Object.defineProperties(call_, {\n                __argnames__ : {value: ["expr"]}\n            });\n\n            function get_attr(expr, allow_calls) {\n                var prop, c, classvars;\n                next();\n                prop = as_name();\n                c = get_class_in_scope(expr);\n                if (c) {\n                    classvars = (c.processing) ? c.provisional_classvars : c.classvars;\n                    if (classvars && classvars[prop]) {\n                        prop = "prototype." + prop;\n                    }\n                }\n                return subscripts(new AST_Dot((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["start"] = expr.start;\n                    RS_d["expression"] = expr;\n                    RS_d["property"] = prop;\n                    RS_d["end"] = prev();\n                    return RS_d;\n                }).call(this)), allow_calls);\n            };\n            if (!get_attr.__argnames__) Object.defineProperties(get_attr, {\n                __argnames__ : {value: ["expr", "allow_calls"]}\n            });\n\n            function existential(expr, allow_calls) {\n                var ans, ttype, val, is_py_sub;\n                ans = new AST_Existential((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["start"] = expr.start;\n                    RS_d["end"] = S.token;\n                    RS_d["expression"] = expr;\n                    return RS_d;\n                }).call(this));\n                next();\n                ttype = S.token.type;\n                val = S.token.value;\n                if (S.token.nlb || ttype === "keyword" || ttype === "operator" || ttype === "eof") {\n                    ans.after = null;\n                    return ans;\n                }\n                if (ttype === "punc") {\n                    if (val === ".") {\n                        ans.after = ".";\n                    } else if (val === "[") {\n                        is_py_sub = S.scoped_flags.get("overload_getitem", false);\n                        ans.after = (is_py_sub) ? "g" : "[";\n                    } else if (val === "(") {\n                        if (!allow_calls) {\n                            unexpected();\n                        }\n                        ans.after = "(";\n                    } else {\n                        ans.after = null;\n                        return ans;\n                    }\n                    return subscripts(ans, allow_calls);\n                }\n                ans.after = expression();\n                return ans;\n            };\n            if (!existential.__argnames__) Object.defineProperties(existential, {\n                __argnames__ : {value: ["expr", "allow_calls"]}\n            });\n\n            function subscripts(expr, allow_calls) {\n                if (is_("punc", ".")) {\n                    return get_attr(expr, allow_calls);\n                }\n                if (is_("punc", "[") && !S.token.nlb) {\n                    return getitem(expr, allow_calls);\n                }\n                if (allow_calls && is_("punc", "(") && !S.token.nlb) {\n                    return call_(expr);\n                }\n                if (is_("punc", "?")) {\n                    return existential(expr, allow_calls);\n                }\n                return expr;\n            };\n            if (!subscripts.__argnames__) Object.defineProperties(subscripts, {\n                __argnames__ : {value: ["expr", "allow_calls"]}\n            });\n\n            function maybe_unary(allow_calls) {\n                var start, expr, ex, val;\n                start = S.token;\n                if (is_("operator", "@")) {\n                    if (S.parsing_decorator) {\n                        croak("Nested decorators are not allowed");\n                    }\n                    next();\n                    S.parsing_decorator = true;\n                    expr = expression();\n                    S.parsing_decorator = false;\n                    S.decorators.push(expr);\n                    return new AST_EmptyStatement((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["stype"] = "@";\n                        RS_d["start"] = prev();\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this));\n                }\n                if (is_("operator") && UNARY_PREFIX[RS_bound_index(start.value, UNARY_PREFIX)]) {\n                    next();\n                    S.in_delete = start.value === "delete";\n                    expr = maybe_unary(allow_calls);\n                    S.in_delete = false;\n                    ex = make_unary(AST_UnaryPrefix, start.value, expr);\n                    ex.start = start;\n                    ex.end = prev();\n                    return ex;\n                }\n                val = expr_atom(allow_calls);\n                return val;\n            };\n            if (!maybe_unary.__argnames__) Object.defineProperties(maybe_unary, {\n                __argnames__ : {value: ["allow_calls"]}\n            });\n\n            function make_unary(ctor, op, expr) {\n                return new ctor((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["operator"] = op;\n                    RS_d["expression"] = expr;\n                    return RS_d;\n                }).call(this));\n            };\n            if (!make_unary.__argnames__) Object.defineProperties(make_unary, {\n                __argnames__ : {value: ["ctor", "op", "expr"]}\n            });\n\n            function expr_op(left, min_prec, no_in) {\n                var op, not_in, prec, right, ret;\n                op = (is_("operator")) ? S.token.value : null;\n                not_in = false;\n                if (op === "!" && peek().type === "operator" && peek().value === "in") {\n                    next();\n                    op = "in";\n                    not_in = true;\n                }\n                if (op === "in") {\n                    if (no_in) {\n                        op = null;\n                    }\n                }\n                prec = (op !== null) ? PRECEDENCE[(typeof op === "number" && op < 0) ? PRECEDENCE.length + op : op] : null;\n                if (prec !== null && prec > min_prec) {\n                    next();\n                    right = expr_op(maybe_unary(true), prec, no_in);\n                    ret = new AST_Binary((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = left.start;\n                        RS_d["left"] = left;\n                        RS_d["operator"] = op;\n                        RS_d["right"] = right;\n                        RS_d["end"] = right.end;\n                        return RS_d;\n                    }).call(this));\n                    if (not_in) {\n                        ret = new AST_UnaryPrefix((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = left.start;\n                            RS_d["operator"] = "!";\n                            RS_d["expression"] = ret;\n                            RS_d["end"] = right.end;\n                            return RS_d;\n                        }).call(this));\n                    }\n                    return expr_op(ret, min_prec, no_in);\n                }\n                return left;\n            };\n            if (!expr_op.__argnames__) Object.defineProperties(expr_op, {\n                __argnames__ : {value: ["left", "min_prec", "no_in"]}\n            });\n\n            function expr_ops(no_in) {\n                return expr_op(maybe_unary(true), 0, no_in);\n            };\n            if (!expr_ops.__argnames__) Object.defineProperties(expr_ops, {\n                __argnames__ : {value: ["no_in"]}\n            });\n\n            function maybe_conditional(no_in) {\n                var start, expr, ne, conditional;\n                start = S.token;\n                expr = expr_ops(no_in);\n                if (is_("keyword", "if") && (S.in_parenthesized_expr || S.statement_starting_token !== S.token && !S.in_comprehension && !S.token.nlb)) {\n                    next();\n                    ne = expression(false);\n                    expect_token("keyword", "else");\n                    conditional = new AST_Conditional((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["condition"] = ne;\n                        RS_d["consequent"] = expr;\n                        RS_d["alternative"] = expression(false, no_in);\n                        RS_d["end"] = peek();\n                        return RS_d;\n                    }).call(this));\n                    return conditional;\n                }\n                return expr;\n            };\n            if (!maybe_conditional.__argnames__) Object.defineProperties(maybe_conditional, {\n                __argnames__ : {value: ["no_in"]}\n            });\n\n            function create_assign(data) {\n                var ans, class_name, c, lhs;\n                if (data.right && is_node_type(data.right, AST_Seq) && (is_node_type(data.right.car, AST_Assign) || is_node_type(data.right.cdr, AST_Assign)) && data.operator !== "=") {\n                    token_error(data.start, "Invalid assignment operator for chained assignment: " + data.operator);\n                }\n                ans = new AST_Assign(data);\n                if (S.in_class.length && (RS_expr_temp = S.in_class)[RS_expr_temp.length-1]) {\n                    class_name = (RS_expr_temp = S.in_class)[RS_expr_temp.length-1];\n                    if (is_node_type(ans.left, AST_SymbolRef) && S.classes.length > 1) {\n                        c = (RS_expr_temp = (RS_expr_temp = S.classes)[RS_expr_temp.length-2])[(typeof class_name === "number" && class_name < 0) ? RS_expr_temp.length + class_name : class_name];\n                        if (c) {\n                            if (ans.is_chained()) {\n                                var RS_Iter70 = RS_Iterable(ans.traverse_chain()[0]);\n                                for (var RS_Index70 = 0; RS_Index70 < RS_Iter70.length; RS_Index70++) {\n                                    lhs = RS_Iter70[RS_Index70];\n                                    (RS_expr_temp = c.provisional_classvars)[RS_bound_index(lhs.name, RS_expr_temp)] = true;\n                                }\n                            } else {\n                                (RS_expr_temp = c.provisional_classvars)[RS_bound_index(ans.left.name, RS_expr_temp)] = true;\n                            }\n                        }\n                    }\n                }\n                return ans;\n            };\n            if (!create_assign.__argnames__) Object.defineProperties(create_assign, {\n                __argnames__ : {value: ["data"]}\n            });\n\n            function maybe_assign(no_in, only_plain_assignment) {\n                var start, left, val;\n                start = S.token;\n                left = maybe_conditional(no_in);\n                val = S.token.value;\n                if (is_("operator") && ASSIGNMENT[(typeof val === "number" && val < 0) ? ASSIGNMENT.length + val : val]) {\n                    if (only_plain_assignment && val !== "=") {\n                        croak("Invalid assignment operator for chained assignment: " + val);\n                    }\n                    next();\n                    return create_assign((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["left"] = left;\n                        RS_d["operator"] = val;\n                        RS_d["right"] = maybe_assign(no_in, true);\n                        RS_d["end"] = prev();\n                        return RS_d;\n                    }).call(this));\n                }\n                return left;\n            };\n            if (!maybe_assign.__argnames__) Object.defineProperties(maybe_assign, {\n                __argnames__ : {value: ["no_in", "only_plain_assignment"]}\n            });\n\n            function expression(commas, no_in) {\n                var start, expr, left;\n                start = S.token;\n                expr = maybe_assign(no_in);\n                function build_seq(a) {\n                    if (a.length === 1) {\n                        return a[0];\n                    }\n                    return new AST_Seq((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["car"] = a.shift();\n                        RS_d["cdr"] = build_seq(a);\n                        RS_d["end"] = peek();\n                        return RS_d;\n                    }).call(this));\n                };\n                if (!build_seq.__argnames__) Object.defineProperties(build_seq, {\n                    __argnames__ : {value: ["a"]}\n                });\n\n                if (commas) {\n                    left = [ expr ];\n                    while (is_("punc", ",") && !peek().nlb) {\n                        next();\n                        if (is_node_type(expr, AST_Assign)) {\n                            left[left.length-1] = left[left.length-1].left;\n                            return create_assign((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["start"] = start;\n                                RS_d["left"] = (left.length === 1) ? left[0] : new AST_Array((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["elements"] = left;\n                                    return RS_d;\n                                }).call(this));\n                                RS_d["operator"] = expr.operator;\n                                RS_d["right"] = new AST_Seq((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["car"] = expr.right;\n                                    RS_d["cdr"] = expression(true, no_in);\n                                    return RS_d;\n                                }).call(this));\n                                RS_d["end"] = peek();\n                                return RS_d;\n                            }).call(this));\n                        }\n                        expr = maybe_assign(no_in);\n                        left.push(expr);\n                    }\n                    if (left.length > 1 && is_node_type(left[left.length-1], AST_Assign)) {\n                        left[left.length-1] = left[left.length-1].left;\n                        return create_assign((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["start"] = start;\n                            RS_d["left"] = new AST_Array((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["elements"] = left;\n                                return RS_d;\n                            }).call(this));\n                            RS_d["operator"] = expr.operator;\n                            RS_d["right"] = expr.right;\n                            RS_d["end"] = peek();\n                            return RS_d;\n                        }).call(this));\n                    }\n                    return build_seq(left);\n                }\n                return expr;\n            };\n            if (!expression.__argnames__) Object.defineProperties(expression, {\n                __argnames__ : {value: ["commas", "no_in"]}\n            });\n\n            function in_loop(cont) {\n                var ret;\n                S.in_loop += 1;\n                ret = cont();\n                S.in_loop -= 1;\n                return ret;\n            };\n            if (!in_loop.__argnames__) Object.defineProperties(in_loop, {\n                __argnames__ : {value: ["cont"]}\n            });\n\n            function run_parser() {\n                var start, body, docstrings, first_token, toplevel, element, shebang, ds, end, seen_exports, item;\n                start = S.token = next();\n                body = [];\n                docstrings = [];\n                first_token = true;\n                toplevel = options.toplevel;\n                while (!is_("eof")) {\n                    element = statement();\n                    if (first_token && is_node_type(element, AST_Directive) && element.value.indexOf("#!") === 0) {\n                        shebang = element.value;\n                    } else {\n                        ds = !toplevel && is_docstring(element);\n                        if (ds) {\n                            docstrings.push(ds);\n                        } else {\n                            body.push(element);\n                        }\n                    }\n                    first_token = false;\n                }\n                end = prev();\n                if (toplevel) {\n                    toplevel.body = toplevel.body.concat(body);\n                    toplevel.end = end;\n                    toplevel.docstrings;\n                } else {\n                    toplevel = new AST_Toplevel((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["start"] = start;\n                        RS_d["body"] = body;\n                        RS_d["shebang"] = shebang;\n                        RS_d["end"] = end;\n                        RS_d["docstrings"] = docstrings;\n                        return RS_d;\n                    }).call(this));\n                }\n                toplevel.nonlocalvars = scan_for_nonlocal_defs(toplevel.body).concat(S.globals);\n                toplevel.localvars = RS_list_decorate([]);\n                toplevel.exports = RS_list_decorate([]);\n                seen_exports = Object.create(null);\n                function add_item(item, isvar) {\n                    var symbol;\n                    if (toplevel.nonlocalvars.indexOf(item) < 0) {\n                        symbol = new_symbol(AST_SymbolVar, item);\n                        if (isvar) {\n                            toplevel.localvars.push(symbol);\n                        }\n                        if (!has_prop(seen_exports, item)) {\n                            toplevel.exports.push(symbol);\n                            seen_exports[(typeof item === "number" && item < 0) ? seen_exports.length + item : item] = true;\n                        }\n                    }\n                };\n                if (!add_item.__argnames__) Object.defineProperties(add_item, {\n                    __argnames__ : {value: ["item", "isvar"]}\n                });\n\n                var RS_Iter71 = RS_Iterable(scan_for_local_vars(toplevel.body));\n                for (var RS_Index71 = 0; RS_Index71 < RS_Iter71.length; RS_Index71++) {\n                    item = RS_Iter71[RS_Index71];\n                    add_item(item, true);\n                }\n                var RS_Iter72 = RS_Iterable(scan_for_top_level_callables(toplevel.body));\n                for (var RS_Index72 = 0; RS_Index72 < RS_Iter72.length; RS_Index72++) {\n                    item = RS_Iter72[RS_Index72];\n                    add_item(item, false);\n                }\n                toplevel.filename = options.filename;\n                toplevel.imported_module_ids = imported_module_ids;\n                toplevel.classes = scan_for_classes(toplevel.body);\n                toplevel.import_order = Object.keys(imported_modules).length;\n                toplevel.module_id = module_id;\n                imported_modules[(typeof module_id === "number" && module_id < 0) ? imported_modules.length + module_id : module_id] = toplevel;\n                toplevel.imports = imported_modules;\n                toplevel.baselib = baselib_items;\n                toplevel.scoped_flags = S.scoped_flags.stack[0];\n                importing_modules[(typeof module_id === "number" && module_id < 0) ? importing_modules.length + module_id : module_id] = false;\n                return toplevel;\n            };\n\n            return run_parser;\n        };\n        if (!create_parser_ctx.__argnames__) Object.defineProperties(create_parser_ctx, {\n            __argnames__ : {value: ["S", "import_dirs", "module_id", "baselib_items", "imported_module_ids", "imported_modules", "importing_modules", "options"]}\n        });\n\n        function parse(text, options) {\n            var import_dirs, x, location, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, S, obj, cname;\n            options = defaults(options, (function(){\n                var RS_d = Object.create(null);\n                RS_d["filename"] = null;\n                RS_d["module_id"] = "__main__";\n                RS_d["toplevel"] = null;\n                RS_d["for_linting"] = false;\n                RS_d["import_dirs"] = [];\n                RS_d["classes"] = undefined;\n                RS_d["scoped_flags"] = Object.create(null);\n                RS_d["discard_asserts"] = false;\n                RS_d["module_cache_dir"] = "";\n                return RS_d;\n            }).call(this));\n            import_dirs = (function() {\n                var RS_Iter = RS_Iterable(options.import_dirs), RS_Result = [], x;\n                for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                    x = RS_Iter[RS_Index];\n                    RS_Result.push(x);\n                }\n                RS_Result = RS_list_constructor(RS_Result);\n                return RS_Result;\n            })();\n            var RS_Iter73 = RS_Iterable([options.libdir, options.basedir]);\n            for (var RS_Index73 = 0; RS_Index73 < RS_Iter73.length; RS_Index73++) {\n                location = RS_Iter73[RS_Index73];\n                if (location) {\n                    import_dirs.push(location);\n                }\n            }\n            module_id = options.module_id;\n            baselib_items = Object.create(null);\n            imported_module_ids = RS_list_decorate([]);\n            imported_modules = options.imported_modules || Object.create(null);\n            importing_modules = options.importing_modules || Object.create(null);\n            importing_modules[(typeof module_id === "number" && module_id < 0) ? importing_modules.length + module_id : module_id] = true;\n            S = (function(){\n                var RS_d = Object.create(null);\n                RS_d["input"] = (typeof text === "string") ? tokenizer(text, options.filename) : text;\n                RS_d["token"] = null;\n                RS_d["prev"] = null;\n                RS_d["peeked"] = RS_list_decorate([]);\n                RS_d["in_function"] = 0;\n                RS_d["statement_starting_token"] = null;\n                RS_d["in_comprehension"] = false;\n                RS_d["in_parenthesized_expr"] = false;\n                RS_d["in_delete"] = false;\n                RS_d["in_loop"] = 0;\n                RS_d["in_class"] = RS_list_decorate([ false ]);\n                RS_d["classes"] = RS_list_decorate([ Object.create(null) ]);\n                RS_d["functions"] = RS_list_decorate([ Object.create(null) ]);\n                RS_d["labels"] = RS_list_decorate([]);\n                RS_d["decorators"] = [];\n                RS_d["parsing_decorator"] = false;\n                RS_d["globals"] = [];\n                RS_d["scoped_flags"] = (function(){\n                    var RS_d = Object.create(null);\n                    RS_d["stack"] = [options.scoped_flags || Object.create(null)];\n                    RS_d["push"] = function () {\n                        this.stack.push(Object.create(null));\n                    };\n                    RS_d["pop"] = function () {\n                        this.stack.pop();\n                    };\n                    RS_d["get"] = (function() {\n                        var RS_anonfunc = function (name, defval) {\n                            var d, q;\n                            for (var i = this.stack.length - 1; i >= 0; i--) {\n                                d = (RS_expr_temp = this.stack)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n                                q = d[(typeof name === "number" && name < 0) ? d.length + name : name];\n                                if (q) {\n                                    return q;\n                                }\n                            }\n                            return defval;\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["name", "defval"]}\n                        });\n                        return RS_anonfunc;\n                    })();\n                    RS_d["set"] = (function() {\n                        var RS_anonfunc = function (name, val) {\n                            (RS_expr_temp = (RS_expr_temp = this.stack)[RS_expr_temp.length-1])[(typeof name === "number" && name < 0) ? RS_expr_temp.length + name : name] = val;\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["name", "val"]}\n                        });\n                        return RS_anonfunc;\n                    })();\n                    return RS_d;\n                }).call(this);\n                return RS_d;\n            }).call(this);\n            if (options.classes) {\n                var RS_Iter74 = RS_Iterable(options.classes);\n                for (var RS_Index74 = 0; RS_Index74 < RS_Iter74.length; RS_Index74++) {\n                    cname = RS_Iter74[RS_Index74];\n                    obj = (RS_expr_temp = options.classes)[(typeof cname === "number" && cname < 0) ? RS_expr_temp.length + cname : cname];\n                    (RS_expr_temp = S.classes[0])[(typeof cname === "number" && cname < 0) ? RS_expr_temp.length + cname : cname] = (function(){\n                        var RS_d = Object.create(null);\n                        RS_d["static"] = obj.static;\n                        RS_d["bound"] = obj.bound;\n                        RS_d["classvars"] = obj.classvars;\n                        return RS_d;\n                    }).call(this);\n                }\n            }\n            return create_parser_ctx(S, import_dirs, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, options)();\n        };\n        if (!parse.__argnames__) Object.defineProperties(parse, {\n            __argnames__ : {value: ["text", "options"]}\n        });\n\n        RS_modules.parse.COMPILER_VERSION = COMPILER_VERSION;\n        RS_modules.parse.PYTHON_FLAGS = PYTHON_FLAGS;\n        RS_modules.parse.NATIVE_CLASSES = NATIVE_CLASSES;\n        RS_modules.parse.ERROR_CLASSES = ERROR_CLASSES;\n        RS_modules.parse.COMMON_STATIC = COMMON_STATIC;\n        RS_modules.parse.FORBIDDEN_CLASS_VARS = FORBIDDEN_CLASS_VARS;\n        RS_modules.parse.UNARY_PREFIX = UNARY_PREFIX;\n        RS_modules.parse.ASSIGNMENT = ASSIGNMENT;\n        RS_modules.parse.PRECEDENCE = PRECEDENCE;\n        RS_modules.parse.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;\n        RS_modules.parse.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\n        RS_modules.parse.compile_time_decorators = compile_time_decorators;\n        RS_modules.parse.static_predicate = static_predicate;\n        RS_modules.parse.has_simple_decorator = has_simple_decorator;\n        RS_modules.parse.has_setter_decorator = has_setter_decorator;\n        RS_modules.parse.create_parser_ctx = create_parser_ctx;\n        RS_modules.parse.parse = parse;\n    })();\n\n    (function(){\n        var __name__ = "output";\n\n    })();\n\n    (function(){\n        var __name__ = "output.stream";\n        var DANGEROUS, require_semi_colon_chars, output_stream_defaults;\n        var make_predicate = RS_modules.utils.make_predicate;\n        var defaults = RS_modules.utils.defaults;\n        var repeat_string = RS_modules.utils.repeat_string;\n\n        var is_identifier_char = RS_modules.tokenizer.is_identifier_char;\n\n        DANGEROUS = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n        function as_hex(code, sz) {\n            var val;\n            val = code.toString(16);\n            if (val.length < sz) {\n                val = "0".repeat(sz - val.length) + val;\n            }\n            return val;\n        };\n        if (!as_hex.__argnames__) Object.defineProperties(as_hex, {\n            __argnames__ : {value: ["code", "sz"]}\n        });\n\n        function to_ascii(str_, identifier) {\n            return str_.replace(/[\\u0080-\\uffff]/g, (function() {\n                var RS_anonfunc = function (ch) {\n                    var code;\n                    code = ch.charCodeAt(0).toString(16);\n                    if (code.length <= 2 && !identifier) {\n                        return "\\\\x" + as_hex(code, 2);\n                    } else {\n                        return "\\\\u" + as_hex(code, 4);\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["ch"]}\n                });\n                return RS_anonfunc;\n            })());\n        };\n        if (!to_ascii.__argnames__) Object.defineProperties(to_ascii, {\n            __argnames__ : {value: ["str_", "identifier"]}\n        });\n\n        function encode_string(str_) {\n            return JSON.stringify(str_).replace(DANGEROUS, (function() {\n                var RS_anonfunc = function (a) {\n                    return "\\\\u" + as_hex(a.charCodeAt(0), 4);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["a"]}\n                });\n                return RS_anonfunc;\n            })());\n        };\n        if (!encode_string.__argnames__) Object.defineProperties(encode_string, {\n            __argnames__ : {value: ["str_"]}\n        });\n\n        require_semi_colon_chars = make_predicate("( [ + * / - , .");\n        output_stream_defaults = (function(){\n            var RS_d = Object.create(null);\n            RS_d["indent_start"] = 0;\n            RS_d["indent_level"] = 4;\n            RS_d["quote_keys"] = false;\n            RS_d["space_colon"] = true;\n            RS_d["ascii_only"] = false;\n            RS_d["width"] = 80;\n            RS_d["max_line_len"] = 32e3;\n            RS_d["ie_proof"] = true;\n            RS_d["beautify"] = false;\n            RS_d["source_map"] = null;\n            RS_d["bracketize"] = false;\n            RS_d["semicolons"] = true;\n            RS_d["comments"] = false;\n            RS_d["preserve_line"] = false;\n            RS_d["omit_baselib"] = false;\n            RS_d["baselib_plain"] = null;\n            RS_d["private_scope"] = true;\n            RS_d["keep_docstrings"] = false;\n            RS_d["discard_asserts"] = false;\n            RS_d["module_cache_dir"] = "";\n            RS_d["js_version"] = 5;\n            RS_d["write_name"] = true;\n            return RS_d;\n        }).call(this);\n        function OutputStream() {\n            if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n            OutputStream.prototype.__init__.apply(this, arguments);\n        }\n        OutputStream.prototype.__init__ = function __init__(options) {\n            var self = this;\n            self.options = defaults(options, output_stream_defaults, true);\n            self._indentation = 0;\n            self.current_col = 0;\n            self.current_line = 1;\n            self.current_pos = 0;\n            self.OUTPUT = "";\n            self.IMPORTED = Object.create(null);\n            self.might_need_space = false;\n            self.might_need_semicolon = false;\n            self._last = null;\n            self._stack = RS_list_decorate([]);\n            self.index_counter = 0;\n            self.with_counter = 0;\n            self.try_else_counter = 0;\n        };\n        if (!OutputStream.prototype.__init__.__argnames__) Object.defineProperties(OutputStream.prototype.__init__, {\n            __argnames__ : {value: ["options"]}\n        });\n        OutputStream.__argnames__ = OutputStream.prototype.__init__.__argnames__;\n        OutputStream.__handles_kwarg_interpolation__ = OutputStream.prototype.__init__.__handles_kwarg_interpolation__;\n        OutputStream.prototype.new_try_else_counter = function new_try_else_counter() {\n            var self = this;\n            self.try_else_counter += 1;\n            return "RS_try_else_" + self.try_else_counter;\n        };\n        OutputStream.prototype.make_name = function make_name(name) {\n            var self = this;\n            name = name.toString();\n            if (self.options.ascii_only) {\n                name = to_ascii(name, true);\n            }\n            return name;\n        };\n        if (!OutputStream.prototype.make_name.__argnames__) Object.defineProperties(OutputStream.prototype.make_name, {\n            __argnames__ : {value: ["name"]}\n        });\n        OutputStream.prototype.print_name = function print_name(name) {\n            var self = this;\n            self.print(self.make_name(name));\n        };\n        if (!OutputStream.prototype.print_name.__argnames__) Object.defineProperties(OutputStream.prototype.print_name, {\n            __argnames__ : {value: ["name"]}\n        });\n        OutputStream.prototype.make_indent = function make_indent(back) {\n            var self = this;\n            return repeat_string(" ", self.options.indent_start + self._indentation - back * self.options.indent_level);\n        };\n        if (!OutputStream.prototype.make_indent.__argnames__) Object.defineProperties(OutputStream.prototype.make_indent, {\n            __argnames__ : {value: ["back"]}\n        });\n        OutputStream.prototype.last_char = function last_char() {\n            var self = this;\n            return self._last.charAt(self._last.length - 1);\n        };\n        OutputStream.prototype.maybe_newline = function maybe_newline() {\n            var self = this;\n            if (self.options.max_line_len && self.current_col > self.options.max_line_len) {\n                self.print("\\n");\n            }\n        };\n        OutputStream.prototype.print = function print(str_) {\n            var self = this;\n            var ch, target_line, prev, a, n;\n            str_ = String(str_);\n            ch = str_.charAt(0);\n            if (self.might_need_semicolon) {\n                if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(self._last)) {\n                    if (self.options.semicolons || require_semi_colon_chars[(typeof ch === "number" && ch < 0) ? require_semi_colon_chars.length + ch : ch]) {\n                        self.OUTPUT += ";";\n                        self.current_col += 1;\n                        self.current_pos += 1;\n                    } else {\n                        self.OUTPUT += "\\n";\n                        self.current_pos += 1;\n                        self.current_line += 1;\n                        self.current_col = 0;\n                    }\n                    if (!self.options.beautify) {\n                        self.might_need_space = false;\n                    }\n                }\n                self.might_need_semicolon = false;\n                self.maybe_newline();\n            }\n            if (!self.options.beautify && self.options.preserve_line && (RS_expr_temp = self._stack)[RS_bound_index(self._stack.length - 1, RS_expr_temp)]) {\n                target_line = (RS_expr_temp = self._stack)[RS_bound_index(self._stack.length - 1, RS_expr_temp)].start.line;\n                while (self.current_line < target_line) {\n                    self.OUTPUT += "\\n";\n                    self.current_pos += 1;\n                    self.current_line += 1;\n                    self.current_col = 0;\n                    self.might_need_space = false;\n                }\n            }\n            if (self.might_need_space) {\n                prev = self.last_char();\n                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch === "\\\\") || /^[\\+\\-\\/]$/.test(ch) && ch === prev) {\n                    self.OUTPUT += " ";\n                    self.current_col += 1;\n                    self.current_pos += 1;\n                }\n                self.might_need_space = false;\n            }\n            a = str_.split(/\\r?\\n/);\n            n = a.length - 1;\n            self.current_line += n;\n            if (n === 0) {\n                self.current_col += a[(typeof n === "number" && n < 0) ? a.length + n : n].length;\n            } else {\n                self.current_col = a[(typeof n === "number" && n < 0) ? a.length + n : n].length;\n            }\n            self.current_pos += str_.length;\n            self._last = str_;\n            self.OUTPUT += str_;\n        };\n        if (!OutputStream.prototype.print.__argnames__) Object.defineProperties(OutputStream.prototype.print, {\n            __argnames__ : {value: ["str_"]}\n        });\n        OutputStream.prototype.space = function space() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(" ");\n            } else {\n                self.might_need_space = true;\n            }\n        };\n        OutputStream.prototype.indent = function indent(half) {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(self.make_indent((half) ? .5 : 0));\n            }\n        };\n        if (!OutputStream.prototype.indent.__argnames__) Object.defineProperties(OutputStream.prototype.indent, {\n            __argnames__ : {value: ["half"]}\n        });\n        OutputStream.prototype.with_indent = function with_indent(col, proceed) {\n            var self = this;\n            var save_indentation, ret;\n            if (self.options.beautify) {\n                if (col === true) {\n                    col = self.next_indent();\n                }\n                save_indentation = self._indentation;\n                self._indentation = col;\n                ret = proceed();\n                self._indentation = save_indentation;\n                return ret;\n            } else {\n                return proceed();\n            }\n        };\n        if (!OutputStream.prototype.with_indent.__argnames__) Object.defineProperties(OutputStream.prototype.with_indent, {\n            __argnames__ : {value: ["col", "proceed"]}\n        });\n        OutputStream.prototype.indentation = function indentation() {\n            var self = this;\n            return self._indentation;\n        };\n        OutputStream.prototype.set_indentation = function set_indentation(val) {\n            var self = this;\n            if (self.options.beautify) {\n                self._indentation = val;\n            }\n        };\n        if (!OutputStream.prototype.set_indentation.__argnames__) Object.defineProperties(OutputStream.prototype.set_indentation, {\n            __argnames__ : {value: ["val"]}\n        });\n        OutputStream.prototype.newline = function newline() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print("\\n");\n            }\n        };\n        OutputStream.prototype.semicolon = function semicolon() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(";");\n            } else {\n                self.might_need_semicolon = true;\n            }\n        };\n        OutputStream.prototype.force_semicolon = function force_semicolon() {\n            var self = this;\n            self.might_need_semicolon = false;\n            self.print(";");\n        };\n        OutputStream.prototype.next_indent = function next_indent() {\n            var self = this;\n            return self._indentation + self.options.indent_level;\n        };\n        OutputStream.prototype.spaced = function spaced() {\n            var self = this;\n            for (var i=0; i < arguments.length; i++) {\n                if (i > 0) {\n                    self.space();\n                }\n                if (typeof arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].print === "function") {\n                    arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].print(self);\n                } else {\n                    self.print(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n                }\n            }\n        };\n        OutputStream.prototype.end_statement = function end_statement() {\n            var self = this;\n            self.semicolon();\n            self.newline();\n        };\n        OutputStream.prototype.with_block = function with_block(cont) {\n            var self = this;\n            var ret;\n            ret = null;\n            self.print("{");\n            self.newline();\n            self.with_indent(self.next_indent(), function () {\n                ret = cont();\n            });\n            self.indent();\n            self.print("}");\n            return ret;\n        };\n        if (!OutputStream.prototype.with_block.__argnames__) Object.defineProperties(OutputStream.prototype.with_block, {\n            __argnames__ : {value: ["cont"]}\n        });\n        OutputStream.prototype.with_parens = function with_parens(cont) {\n            var self = this;\n            var ret;\n            self.print("(");\n            ret = cont();\n            self.print(")");\n            return ret;\n        };\n        if (!OutputStream.prototype.with_parens.__argnames__) Object.defineProperties(OutputStream.prototype.with_parens, {\n            __argnames__ : {value: ["cont"]}\n        });\n        OutputStream.prototype.with_square = function with_square(cont) {\n            var self = this;\n            var ret;\n            self.print("[");\n            ret = cont();\n            self.print("]");\n            return ret;\n        };\n        if (!OutputStream.prototype.with_square.__argnames__) Object.defineProperties(OutputStream.prototype.with_square, {\n            __argnames__ : {value: ["cont"]}\n        });\n        OutputStream.prototype.comma = function comma() {\n            var self = this;\n            self.print(",");\n            self.space();\n        };\n        OutputStream.prototype.colon = function colon() {\n            var self = this;\n            self.print(":");\n            if (self.options.space_colon) {\n                self.space();\n            }\n        };\n        OutputStream.prototype.dump_yield = function dump_yield() {\n            var self = this;\n            var code, ci;\n            self.indent();\n            self.spaced("var", "RS_regenerator", "=", "{}");\n            self.end_statement();\n            code = regenerate(false, self.options.beautify);\n            if (self.options.beautify) {\n                code = code.replace(/\\/\\/.*$/gm, "\\n").replace(/^\\s*$/gm, "");\n                ci = self.make_indent(0);\n                code = (function() {\n                    var RS_Iter = RS_Iterable(code.split("\\n")), RS_Result = [], x;\n                    for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                        x = RS_Iter[RS_Index];\n                        RS_Result.push(ci + x);\n                    }\n                    RS_Result = RS_list_constructor(RS_Result);\n                    return RS_Result;\n                })().join("\\n");\n            }\n            self.print(code + "})(RS_regenerator)");\n            self.end_statement();\n        };\n        OutputStream.prototype.get = function get() {\n            var self = this;\n            return self.OUTPUT;\n        };\n        OutputStream.prototype.toString = function toString() {\n            var self = this;\n            return self.OUTPUT;\n        };\n        OutputStream.prototype.assign = function assign(name) {\n            var self = this;\n            if (typeof name === "string") {\n                self.print(name);\n            } else {\n                name.print(self);\n            }\n            self.space();\n            self.print("=");\n            self.space();\n        };\n        if (!OutputStream.prototype.assign.__argnames__) Object.defineProperties(OutputStream.prototype.assign, {\n            __argnames__ : {value: ["name"]}\n        });\n        OutputStream.prototype.current_width = function current_width() {\n            var self = this;\n            return self.current_col - self._indentation;\n        };\n        OutputStream.prototype.should_break = function should_break() {\n            var self = this;\n            return self.options.width && self.current_width() >= self.options.width;\n        };\n        OutputStream.prototype.last = function last() {\n            var self = this;\n            return self._last;\n        };\n        OutputStream.prototype.print_string = function print_string(str_) {\n            var self = this;\n            self.print(encode_string(str_));\n        };\n        if (!OutputStream.prototype.print_string.__argnames__) Object.defineProperties(OutputStream.prototype.print_string, {\n            __argnames__ : {value: ["str_"]}\n        });\n        OutputStream.prototype.import_ = function import_(module) {\n            var self = this;\n            if (!Object.prototype.hasOwnProperty.call(self.IMPORTED, module.key)) {\n                (RS_expr_temp = self.IMPORTED)[RS_bound_index(module.key, RS_expr_temp)] = module;\n            }\n        };\n        if (!OutputStream.prototype.import_.__argnames__) Object.defineProperties(OutputStream.prototype.import_, {\n            __argnames__ : {value: ["module"]}\n        });\n        OutputStream.prototype.is_main = function is_main() {\n            var self = this;\n            return self.OUTPUT.length === 0;\n        };\n        OutputStream.prototype.line = function line() {\n            var self = this;\n            return self.current_line;\n        };\n        OutputStream.prototype.col = function col() {\n            var self = this;\n            return self.current_col;\n        };\n        OutputStream.prototype.pos = function pos() {\n            var self = this;\n            return self.current_pos;\n        };\n        OutputStream.prototype.push_node = function push_node(node) {\n            var self = this;\n            self._stack.push(node);\n        };\n        if (!OutputStream.prototype.push_node.__argnames__) Object.defineProperties(OutputStream.prototype.push_node, {\n            __argnames__ : {value: ["node"]}\n        });\n        OutputStream.prototype.pop_node = function pop_node() {\n            var self = this;\n            return self._stack.pop();\n        };\n        OutputStream.prototype.stack = function stack() {\n            var self = this;\n            return self._stack;\n        };\n        OutputStream.prototype.parent = function parent(n) {\n            var self = this;\n            return (RS_expr_temp = self._stack)[RS_bound_index(self._stack.length - 2 - (n || 0), RS_expr_temp)];\n        };\n        if (!OutputStream.prototype.parent.__argnames__) Object.defineProperties(OutputStream.prototype.parent, {\n            __argnames__ : {value: ["n"]}\n        });\n        OutputStream.prototype.__repr__ = function __repr__ () {\n                        return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n        };\n        OutputStream.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        Object.defineProperty(OutputStream.prototype, "__bases__", {value: []});\n\n        RS_modules["output.stream"].DANGEROUS = DANGEROUS;\n        RS_modules["output.stream"].require_semi_colon_chars = require_semi_colon_chars;\n        RS_modules["output.stream"].output_stream_defaults = output_stream_defaults;\n        RS_modules["output.stream"].as_hex = as_hex;\n        RS_modules["output.stream"].to_ascii = to_ascii;\n        RS_modules["output.stream"].encode_string = encode_string;\n        RS_modules["output.stream"].OutputStream = OutputStream;\n    })();\n\n    (function(){\n        var __name__ = "output.statements";\n        var AST_Definitions = RS_modules.ast.AST_Definitions;\n        var AST_Scope = RS_modules.ast.AST_Scope;\n        var AST_Method = RS_modules.ast.AST_Method;\n        var AST_Except = RS_modules.ast.AST_Except;\n        var AST_EmptyStatement = RS_modules.ast.AST_EmptyStatement;\n        var AST_Statement = RS_modules.ast.AST_Statement;\n        var AST_Seq = RS_modules.ast.AST_Seq;\n        var AST_BaseCall = RS_modules.ast.AST_BaseCall;\n        var AST_Dot = RS_modules.ast.AST_Dot;\n        var AST_Sub = RS_modules.ast.AST_Sub;\n        var AST_ItemAccess = RS_modules.ast.AST_ItemAccess;\n        var AST_Conditional = RS_modules.ast.AST_Conditional;\n        var AST_Binary = RS_modules.ast.AST_Binary;\n        var AST_BlockStatement = RS_modules.ast.AST_BlockStatement;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        function force_statement(stat, output) {\n            if (output.options.bracketize) {\n                if (!stat || is_node_type(stat, AST_EmptyStatement)) {\n                    output.print("{}");\n                } else if (is_node_type(stat, AST_BlockStatement)) {\n                    stat.print(output);\n                } else {\n                    output.with_block(function () {\n                        output.indent();\n                        stat.print(output);\n                        output.newline();\n                    });\n                }\n            } else {\n                if (!stat || is_node_type(stat, AST_EmptyStatement)) {\n                    output.force_semicolon();\n                } else {\n                    stat.print(output);\n                }\n            }\n        };\n        if (!force_statement.__argnames__) Object.defineProperties(force_statement, {\n            __argnames__ : {value: ["stat", "output"]}\n        });\n\n        function first_in_statement(output) {\n            var a, i, node, p;\n            a = output.stack();\n            i = a.length;\n            node = a[RS_bound_index(i -= 1, a)];\n            p = a[RS_bound_index(i -= 1, a)];\n            while (i > 0) {\n                if (is_node_type(p, AST_Statement) && p.body === node) {\n                    return true;\n                }\n                if (is_node_type(p, AST_Seq) && p.car === node || is_node_type(p, AST_BaseCall) && p.expression === node || is_node_type(p, AST_Dot) && p.expression === node || is_node_type(p, AST_Sub) && p.expression === node || is_node_type(p, AST_ItemAccess) && p.expression === node || is_node_type(p, AST_Conditional) && p.condition === node || is_node_type(p, AST_Binary) && p.left === node) {\n                    node = p;\n                    p = a[RS_bound_index(i -= 1, a)];\n                } else {\n                    return false;\n                }\n            }\n        };\n        if (!first_in_statement.__argnames__) Object.defineProperties(first_in_statement, {\n            __argnames__ : {value: ["output"]}\n        });\n\n        function declare_vars(vars, output) {\n            var RS_unpack, i, arg;\n            if (vars.length) {\n                output.indent();\n                output.print("var");\n                output.space();\n                var RS_Iter75 = RS_Iterable(enumerate(vars));\n                for (var RS_Index75 = 0; RS_Index75 < RS_Iter75.length; RS_Index75++) {\n                    RS_unpack = RS_Iter75[RS_Index75];\n                    i = RS_unpack[0];\n                    arg = RS_unpack[1];\n                    if (i) {\n                        output.comma();\n                    }\n                    arg.print(output);\n                }\n                output.semicolon();\n                output.newline();\n            }\n        };\n        if (!declare_vars.__argnames__) Object.defineProperties(declare_vars, {\n            __argnames__ : {value: ["vars", "output"]}\n        });\n\n        function display_body(body, is_toplevel, output) {\n            var last, RS_unpack, i, stmt;\n            last = body.length - 1;\n            var RS_Iter76 = RS_Iterable(enumerate(body));\n            for (var RS_Index76 = 0; RS_Index76 < RS_Iter76.length; RS_Index76++) {\n                RS_unpack = RS_Iter76[RS_Index76];\n                i = RS_unpack[0];\n                stmt = RS_unpack[1];\n                if (!is_node_type(stmt, AST_EmptyStatement) && !is_node_type(stmt, AST_Definitions)) {\n                    output.indent();\n                    stmt.print(output);\n                    if (!(i === last && is_toplevel)) {\n                        output.newline();\n                    }\n                }\n            }\n        };\n        if (!display_body.__argnames__) Object.defineProperties(display_body, {\n            __argnames__ : {value: ["body", "is_toplevel", "output"]}\n        });\n\n        function display_complex_body(node, is_toplevel, output, function_preamble) {\n            var offset;\n            offset = 0;\n            if (is_node_type(node, AST_Method) && !node.static) {\n                output.indent();\n                output.print("var");\n                output.space();\n                output.assign(node.argnames[0]);\n                output.print("this");\n                output.semicolon();\n                output.newline();\n                offset += 1;\n            }\n            if (is_node_type(node, AST_Scope)) {\n                function_preamble(node, output, offset);\n                declare_vars(node.localvars, output);\n            } else if (is_node_type(node, AST_Except)) {\n                if (node.argname) {\n                    output.indent();\n                    output.print("var");\n                    output.space();\n                    output.assign(node.argname);\n                    output.print("RS_Exception");\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n            display_body(node.body, is_toplevel, output);\n        };\n        if (!display_complex_body.__argnames__) Object.defineProperties(display_complex_body, {\n            __argnames__ : {value: ["node", "is_toplevel", "output", "function_preamble"]}\n        });\n\n        function print_bracketed(node, output, complex, function_preamble, before, after) {\n            if (node.body.length > 0) {\n                output.with_block(function () {\n                    if (before) {\n                        before(output);\n                    }\n                    if (complex) {\n                        display_complex_body(node, false, output, function_preamble);\n                    } else {\n                        display_body(node.body, false, output);\n                    }\n                    if (after) {\n                        after(output);\n                    }\n                });\n            } else {\n                if (before || after) {\n                    output.with_block(function () {\n                        if (before) {\n                            before(output);\n                        }\n                        if (after) {\n                            after(output);\n                        }\n                    });\n                } else {\n                    output.print("{}");\n                }\n            }\n        };\n        if (!print_bracketed.__argnames__) Object.defineProperties(print_bracketed, {\n            __argnames__ : {value: ["node", "output", "complex", "function_preamble", "before", "after"]}\n        });\n\n        function print_with(self, output) {\n            var exits, clause_name, clause;\n            exits = [];\n            [output.assign("RS_with_exception"), output.print("undefined"), output.end_statement()];\n            var RS_Iter77 = RS_Iterable(self.clauses);\n            for (var RS_Index77 = 0; RS_Index77 < RS_Iter77.length; RS_Index77++) {\n                clause = RS_Iter77[RS_Index77];\n                output.with_counter += 1;\n                clause_name = "RS_with_clause_" + output.with_counter;\n                exits.push(clause_name);\n                [output.indent(), output.print("var "), output.assign(clause_name)];\n                clause.expression.print(output);\n                output.end_statement();\n                output.indent();\n                if (clause.alias) {\n                    output.assign(clause.alias.name);\n                }\n                output.print(clause_name + ".__enter__()");\n                output.end_statement();\n            }\n            [output.indent(), output.print("try"), output.space()];\n            output.with_block(function () {\n                output.indent();\n                self._do_print_body(output);\n                output.newline();\n            });\n            [output.space(), output.print("catch(e)")];\n            output.with_block(function () {\n                [output.indent(), output.assign("RS_with_exception"), output.print("e"), output.end_statement()];\n            });\n            [output.newline(), output.indent(), output.spaced("if", "(RS_with_exception", "===", "undefined)")];\n            output.with_block(function () {\n                var clause;\n                var RS_Iter78 = RS_Iterable(exits);\n                for (var RS_Index78 = 0; RS_Index78 < RS_Iter78.length; RS_Index78++) {\n                    clause = RS_Iter78[RS_Index78];\n                    [output.indent(), output.print(clause + ".__exit__()"), output.end_statement()];\n                }\n            });\n            [output.space(), output.print("else"), output.space()];\n            output.with_block(function () {\n                var clause;\n                [output.indent(), output.assign("RS_with_suppress"), output.print("false"), output.end_statement()];\n                var RS_Iter79 = RS_Iterable(exits);\n                for (var RS_Index79 = 0; RS_Index79 < RS_Iter79.length; RS_Index79++) {\n                    clause = RS_Iter79[RS_Index79];\n                    output.indent();\n                    output.spaced("RS_with_suppress", "|=", "RS_bool(" + clause + ".__exit__(RS_with_exception.constructor,", "RS_with_exception,", "RS_with_exception.stack))");\n                    output.end_statement();\n                }\n                [output.indent(), output.spaced("if", "(!RS_with_suppress)", "throw RS_with_exception"), \n                output.end_statement()];\n            });\n        };\n        if (!print_with.__argnames__) Object.defineProperties(print_with, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_assert(self, output) {\n            if (output.options.discard_asserts) {\n                return;\n            }\n            [output.spaced("if", "(!"), self.condition.print(output), output.spaced(")", "throw new AssertionError")];\n            if (self.message) {\n                output.print("(");\n                self.message.print(output);\n                output.print(")");\n            }\n            output.end_statement();\n        };\n        if (!print_assert.__argnames__) Object.defineProperties(print_assert, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        RS_modules["output.statements"].force_statement = force_statement;\n        RS_modules["output.statements"].first_in_statement = first_in_statement;\n        RS_modules["output.statements"].declare_vars = declare_vars;\n        RS_modules["output.statements"].display_body = display_body;\n        RS_modules["output.statements"].display_complex_body = display_complex_body;\n        RS_modules["output.statements"].print_bracketed = print_bracketed;\n        RS_modules["output.statements"].print_with = print_with;\n        RS_modules["output.statements"].print_assert = print_assert;\n    })();\n\n    (function(){\n        var __name__ = "output.exceptions";\n        var print_bracketed = RS_modules["output.statements"].print_bracketed;\n\n        function print_try(self, output) {\n            var else_var_name;\n            else_var_name = null;\n            function update_output_var(output) {\n                [output.indent(), output.assign(else_var_name), output.print("true"), output.end_statement()];\n            };\n            if (!update_output_var.__argnames__) Object.defineProperties(update_output_var, {\n                __argnames__ : {value: ["output"]}\n            });\n\n            if (self.belse) {\n                else_var_name = output.new_try_else_counter();\n                [output.assign("var " + else_var_name), output.print("false"), output.end_statement(), \n                output.indent()];\n            }\n            output.print("try");\n            output.space();\n            print_bracketed(self, output, false, null, null, (else_var_name) ? update_output_var : null);\n            if (self.bcatch) {\n                output.space();\n                print_catch(self.bcatch, output);\n            }\n            if (self.bfinally) {\n                output.space();\n                print_finally(self.bfinally, output, self.belse, else_var_name);\n            } else if (self.belse) {\n                output.newline();\n                print_else(self.belse, else_var_name, output);\n            }\n        };\n        if (!print_try.__argnames__) Object.defineProperties(print_try, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_catch(self, output) {\n            output.print("catch");\n            output.space();\n            output.with_parens(function () {\n                output.print("RS_Exception");\n            });\n            output.space();\n            output.with_block(function () {\n                var no_default, RS_unpack, i, exception;\n                output.indent();\n                [output.spaced("RS_last_exception", "=", "RS_Exception"), output.end_statement()];\n                output.indent();\n                no_default = true;\n                var RS_Iter80 = RS_Iterable(enumerate(self.body));\n                for (var RS_Index80 = 0; RS_Index80 < RS_Iter80.length; RS_Index80++) {\n                    RS_unpack = RS_Iter80[RS_Index80];\n                    i = RS_unpack[0];\n                    exception = RS_unpack[1];\n                    if (i) {\n                        output.print("else ");\n                    }\n                    if (exception.errors.length) {\n                        output.print("if");\n                        output.space();\n                        output.with_parens(function () {\n                            var RS_unpack, i, err;\n                            var RS_Iter81 = RS_Iterable(enumerate(exception.errors));\n                            for (var RS_Index81 = 0; RS_Index81 < RS_Iter81.length; RS_Index81++) {\n                                RS_unpack = RS_Iter81[RS_Index81];\n                                i = RS_unpack[0];\n                                err = RS_unpack[1];\n                                if (i) {\n                                    output.newline();\n                                    output.indent();\n                                    output.print("||");\n                                    output.space();\n                                }\n                                output.print("RS_Exception");\n                                output.space();\n                                output.print("instanceof");\n                                output.space();\n                                if (err.name === "Exception") {\n                                    output.print("Error");\n                                } else {\n                                    err.print(output);\n                                }\n                            }\n                        });\n                        output.space();\n                    } else {\n                        no_default = false;\n                    }\n                    print_bracketed(exception, output, true);\n                    output.space();\n                }\n                if (no_default) {\n                    output.print("else");\n                    output.space();\n                    output.with_block(function () {\n                        output.indent();\n                        output.print("throw");\n                        output.space();\n                        output.print("RS_Exception");\n                        output.semicolon();\n                        output.newline();\n                    });\n                }\n                output.newline();\n            });\n        };\n        if (!print_catch.__argnames__) Object.defineProperties(print_catch, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_finally(self, output, belse, else_var_name) {\n            output.print("finally");\n            output.space();\n            if (else_var_name) {\n                output.with_block(function () {\n                    [output.indent(), output.print("try")];\n                    output.space();\n                    output.with_block(function () {\n                        print_else(belse, else_var_name, output);\n                    });\n                    print_finally(self, output);\n                });\n            } else {\n                print_bracketed(self, output);\n            }\n        };\n        if (!print_finally.__argnames__) Object.defineProperties(print_finally, {\n            __argnames__ : {value: ["self", "output", "belse", "else_var_name"]}\n        });\n\n        function print_else(self, else_var_name, output) {\n            [output.indent(), output.spaced("if", "(" + else_var_name + ")")];\n            output.space();\n            print_bracketed(self, output);\n        };\n        if (!print_else.__argnames__) Object.defineProperties(print_else, {\n            __argnames__ : {value: ["self", "else_var_name", "output"]}\n        });\n\n        RS_modules["output.exceptions"].print_try = print_try;\n        RS_modules["output.exceptions"].print_catch = print_catch;\n        RS_modules["output.exceptions"].print_finally = print_finally;\n        RS_modules["output.exceptions"].print_else = print_else;\n    })();\n\n    (function(){\n        var __name__ = "output.utils";\n        var AST_BlockStatement = RS_modules.ast.AST_BlockStatement;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        function best_of(a) {\n            var best, len_, i;\n            best = a[0];\n            len_ = best.length;\n            for (var RS_Index82 = 1; RS_Index82 < a.length; RS_Index82++) {\n                i = RS_Index82;\n                if (a[(typeof i === "number" && i < 0) ? a.length + i : i].length < len_) {\n                    best = a[(typeof i === "number" && i < 0) ? a.length + i : i];\n                    len_ = best.length;\n                }\n            }\n            return best;\n        };\n        if (!best_of.__argnames__) Object.defineProperties(best_of, {\n            __argnames__ : {value: ["a"]}\n        });\n\n        function make_num(num) {\n            var str_, a, m;\n            str_ = num.toString(10);\n            a = RS_list_decorate([ str_.replace(/^0\\./, ".").replace("e+", "e") ]);\n            m = null;\n            if (Math.floor(num) === num) {\n                if (num >= 0) {\n                    a.push("0x" + num.toString(16).toLowerCase(), "0" + num.toString(8));\n                } else {\n                    a.push("-0x" + (-num).toString(16).toLowerCase(), "-0" + (-num).toString(8));\n                }\n                if (m = /^(.*?)(0+)$/.exec(num)) {\n                    a.push(m[1] + "e" + m[2].length);\n                }\n            } else if (m = /^0?\\.(0+)(.*)$/.exec(num)) {\n                a.push(m[2] + "e-" + (m[1].length + m[2].length), str_.substr(str_.indexOf(".")));\n            }\n            return best_of(a);\n        };\n        if (!make_num.__argnames__) Object.defineProperties(make_num, {\n            __argnames__ : {value: ["num"]}\n        });\n\n        function make_block(stmt, output) {\n            if (is_node_type(stmt, AST_BlockStatement)) {\n                stmt.print(output);\n                return;\n            }\n            output.with_block(function () {\n                output.indent();\n                stmt.print(output);\n                output.newline();\n            });\n        };\n        if (!make_block.__argnames__) Object.defineProperties(make_block, {\n            __argnames__ : {value: ["stmt", "output"]}\n        });\n\n        function create_doctring(docstrings) {\n            var ans, ds, lines, min_leading_whitespace, r, leading_whitespace, line, lw, RS_unpack, l;\n            ans = [];\n            var RS_Iter83 = RS_Iterable(docstrings);\n            for (var RS_Index83 = 0; RS_Index83 < RS_Iter83.length; RS_Index83++) {\n                ds = RS_Iter83[RS_Index83];\n                ds = str.rstrip(ds.value);\n                lines = [];\n                min_leading_whitespace = "";\n                var RS_Iter84 = RS_Iterable(ds.split(/$/gm));\n                for (var RS_Index84 = 0; RS_Index84 < RS_Iter84.length; RS_Index84++) {\n                    line = RS_Iter84[RS_Index84];\n                    r = /^\\s+/.exec(line);\n                    leading_whitespace = "";\n                    if (r) {\n                        leading_whitespace = (r) ? r[0].replace(/[\\n\\r]/g, "") : "";\n                        line = line.slice(r[0].length);\n                    }\n                    if (!str.strip(line)) {\n                        lines.push(["", ""]);\n                    } else {\n                        leading_whitespace = leading_whitespace.replace(/\\t/g, "    ");\n                        if (leading_whitespace && (!min_leading_whitespace || leading_whitespace.length < min_leading_whitespace.length)) {\n                            min_leading_whitespace = leading_whitespace;\n                        }\n                        lines.push([leading_whitespace, line]);\n                    }\n                }\n                var RS_Iter85 = RS_Iterable(lines);\n                for (var RS_Index85 = 0; RS_Index85 < RS_Iter85.length; RS_Index85++) {\n                    RS_unpack = RS_Iter85[RS_Index85];\n                    lw = RS_unpack[0];\n                    l = RS_unpack[1];\n                    if (min_leading_whitespace) {\n                        lw = lw.slice(min_leading_whitespace.length);\n                    }\n                    ans.push(lw + l);\n                }\n                ans.push("");\n            }\n            return str.rstrip(ans.join("\\n"));\n        };\n        if (!create_doctring.__argnames__) Object.defineProperties(create_doctring, {\n            __argnames__ : {value: ["docstrings"]}\n        });\n\n        RS_modules["output.utils"].best_of = best_of;\n        RS_modules["output.utils"].make_num = make_num;\n        RS_modules["output.utils"].make_block = make_block;\n        RS_modules["output.utils"].create_doctring = create_doctring;\n    })();\n\n    (function(){\n        var __name__ = "output.loops";\n        var AST_BaseCall = RS_modules.ast.AST_BaseCall;\n        var AST_SymbolRef = RS_modules.ast.AST_SymbolRef;\n        var AST_Array = RS_modules.ast.AST_Array;\n        var AST_Unary = RS_modules.ast.AST_Unary;\n        var AST_Number = RS_modules.ast.AST_Number;\n        var has_calls = RS_modules.ast.has_calls;\n        var AST_Seq = RS_modules.ast.AST_Seq;\n        var AST_ListComprehension = RS_modules.ast.AST_ListComprehension;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        var OutputStream = RS_modules["output.stream"].OutputStream;\n\n        function unpack_tuple(elems, output, in_statement) {\n            var RS_unpack, i, elem;\n            var RS_Iter86 = RS_Iterable(enumerate(elems));\n            for (var RS_Index86 = 0; RS_Index86 < RS_Iter86.length; RS_Index86++) {\n                RS_unpack = RS_Iter86[RS_Index86];\n                i = RS_unpack[0];\n                elem = RS_unpack[1];\n                output.indent();\n                output.assign(elem);\n                output.print("RS_unpack");\n                output.with_square(function () {\n                    output.print(i);\n                });\n                if (!in_statement || i < elems.length - 1) {\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n        };\n        if (!unpack_tuple.__argnames__) Object.defineProperties(unpack_tuple, {\n            __argnames__ : {value: ["elems", "output", "in_statement"]}\n        });\n\n        function print_do_loop(self, output) {\n            output.print("do");\n            output.space();\n            self._do_print_body(output);\n            output.space();\n            output.print("while");\n            output.space();\n            output.with_parens(function () {\n                self.condition.print(output);\n            });\n            output.semicolon();\n        };\n        if (!print_do_loop.__argnames__) Object.defineProperties(print_do_loop, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_while_loop(self, output) {\n            output.print("while");\n            output.space();\n            output.with_parens(function () {\n                self.condition.print(output);\n            });\n            output.space();\n            self._do_print_body(output);\n        };\n        if (!print_while_loop.__argnames__) Object.defineProperties(print_while_loop, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function is_simple_for_in(self) {\n            if (is_node_type(self.object, AST_BaseCall) && is_node_type(self.object.expression, AST_SymbolRef) && self.object.expression.name === "dir" && self.object.args.length === 1) {\n                return true;\n            }\n            return false;\n        };\n        if (!is_simple_for_in.__argnames__) Object.defineProperties(is_simple_for_in, {\n            __argnames__ : {value: ["self"]}\n        });\n\n        function is_simple_for(self) {\n            var a, l;\n            if (is_node_type(self.object, AST_BaseCall) && is_node_type(self.object.expression, AST_SymbolRef) && self.object.expression.name === "range" && !is_node_type(self.init, AST_Array)) {\n                a = self.object.args;\n                l = a.length;\n                if (l < 3 || is_node_type(a[2], AST_Number) || is_node_type(a[2], AST_Unary) && a[2].operator === "-" && is_node_type(a[2].expression, AST_Number)) {\n                    if (l === 1 && !has_calls(a[0]) || l > 1 && !has_calls(a[1])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        if (!is_simple_for.__argnames__) Object.defineProperties(is_simple_for, {\n            __argnames__ : {value: ["self"]}\n        });\n\n        function print_for_loop_body(output) {\n            var self;\n            self = this;\n            output.with_block(function () {\n                var itervar, flat, stmt;\n                if (!(self.simple_for_index || is_simple_for_in(self))) {\n                    output.indent();\n                    if (output.options.js_version === 5) {\n                        itervar = "RS_Iter" + output.index_counter + "[RS_Index" + output.index_counter + "]";\n                    } else {\n                        itervar = "RS_Index" + output.index_counter;\n                    }\n                    if (is_node_type(self.init, AST_Array)) {\n                        flat = self.init.flatten();\n                        output.assign("RS_unpack");\n                        if (flat.length > self.init.elements.length) {\n                            output.print("RS_flatten(" + itervar + ")");\n                        } else {\n                            output.print(itervar);\n                        }\n                        output.end_statement();\n                        unpack_tuple(flat, output);\n                    } else {\n                        output.assign(self.init);\n                        output.print(itervar);\n                        output.end_statement();\n                    }\n                    output.index_counter += 1;\n                }\n                if (self.simple_for_index) {\n                    output.indent();\n                    output.assign(self.init);\n                    output.print(self.simple_for_index);\n                    output.end_statement();\n                }\n                var RS_Iter87 = RS_Iterable(self.body.body);\n                for (var RS_Index87 = 0; RS_Index87 < RS_Iter87.length; RS_Index87++) {\n                    stmt = RS_Iter87[RS_Index87];\n                    output.indent();\n                    stmt.print(output);\n                    output.newline();\n                }\n            });\n        };\n        if (!print_for_loop_body.__argnames__) Object.defineProperties(print_for_loop_body, {\n            __argnames__ : {value: ["output"]}\n        });\n\n        function init_es6_itervar(output, itervar) {\n            output.indent();\n            output.spaced(itervar, "=", "((typeof", itervar + "[Symbol.iterator]", "===", "\\"function\\")", "?", "(" + itervar, "instanceof", "Map", "?", itervar + ".keys()", ":", itervar + ")", ":", "Object.keys(" + itervar + "))");\n            output.end_statement();\n        };\n        if (!init_es6_itervar.__argnames__) Object.defineProperties(init_es6_itervar, {\n            __argnames__ : {value: ["output", "itervar"]}\n        });\n\n        function print_for_in(self, output) {\n            var increment, args, tmp_, start, end, idx, itervar;\n            function write_object() {\n                if (self.object.constructor === AST_Seq) {\n                    new AST_Array((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["elements"] = self.object.to_array();\n                        return RS_d;\n                    }).call(this)).print(output);\n                } else {\n                    self.object.print(output);\n                }\n            };\n\n            if (is_simple_for(self)) {\n                increment = null;\n                args = self.object.args;\n                tmp_ = args.length;\n                if (tmp_ === 1) {\n                    start = 0;\n                    end = args[0];\n                } else if (tmp_ === 2) {\n                    start = args[0];\n                    end = args[1];\n                } else if (tmp_ === 3) {\n                    start = args[0];\n                    end = args[1];\n                    increment = args[2];\n                }\n                self.simple_for_index = idx = "RS_Index" + output.index_counter;\n                output.index_counter += 1;\n                output.print("for");\n                output.space();\n                output.with_parens(function () {\n                    [output.spaced("var", idx, "="), output.space()];\n                    (start.print) ? start.print(output) : output.print(start);\n                    output.semicolon();\n                    output.space();\n                    output.print(idx);\n                    output.space();\n                    (is_node_type(increment, AST_Unary)) ? output.print(">") : output.print("<");\n                    output.space();\n                    end.print(output);\n                    output.semicolon();\n                    output.space();\n                    output.print(idx);\n                    if (increment && (!is_node_type(increment, AST_Unary) || increment.expression.value !== "1")) {\n                        if (is_node_type(increment, AST_Unary)) {\n                            output.print("-=");\n                            increment.expression.print(output);\n                        } else {\n                            output.print("+=");\n                            increment.print(output);\n                        }\n                    } else {\n                        if (is_node_type(increment, AST_Unary)) {\n                            output.print("--");\n                        } else {\n                            output.print("++");\n                        }\n                    }\n                });\n            } else if (is_simple_for_in(self)) {\n                output.print("for");\n                output.space();\n                output.with_parens(function () {\n                    self.init.print(output);\n                    output.space();\n                    output.print("in");\n                    output.space();\n                    self.object.args[0].print(output);\n                });\n            } else {\n                if (output.options.js_version === 5) {\n                    output.assign("var RS_Iter" + output.index_counter);\n                    output.print("RS_Iterable");\n                    output.with_parens(write_object);\n                    output.semicolon();\n                    output.newline();\n                    output.indent();\n                    output.print("for");\n                    output.space();\n                    output.with_parens(function () {\n                        output.print("var");\n                        output.space();\n                        output.assign("RS_Index" + output.index_counter);\n                        output.print("0");\n                        output.semicolon();\n                        output.space();\n                        output.print("RS_Index" + output.index_counter);\n                        output.space();\n                        output.print("<");\n                        output.space();\n                        output.print("RS_Iter" + output.index_counter + ".length");\n                        output.semicolon();\n                        output.space();\n                        output.print("RS_Index" + output.index_counter + "++");\n                    });\n                } else {\n                    itervar = "RS_Iter" + output.index_counter;\n                    output.assign("var " + itervar);\n                    write_object();\n                    output.end_statement();\n                    init_es6_itervar(output, itervar);\n                    output.indent();\n                    output.spaced("for", "(var", "RS_Index" + output.index_counter, "of", itervar + ")");\n                }\n            }\n            output.space();\n            self._do_print_body(output);\n        };\n        if (!print_for_in.__argnames__) Object.defineProperties(print_for_in, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_list_comprehension(self, output) {\n            var tname, result_obj, is_generator, es5, add_to_result, push_func;\n            tname = self.constructor.name.slice(4);\n            result_obj = (RS_expr_temp = (function(){\n                var RS_d = Object.create(null);\n                RS_d["ListComprehension"] = "[]";\n                RS_d["DictComprehension"] = (self.is_jshash) ? "Object.create(null)" : "{}";\n                RS_d["SetComprehension"] = "RS_set()";\n                return RS_d;\n            }).call(this))[(typeof tname === "number" && tname < 0) ? RS_expr_temp.length + tname : tname];\n            is_generator = tname === "GeneratorComprehension";\n            es5 = output.options.js_version === 5;\n            if (tname === "DictComprehension") {\n                if (self.is_pydict) {\n                    result_obj = "RS_dict()";\n                    add_to_result = (function() {\n                        var RS_anonfunc = function (output) {\n                            output.indent();\n                            output.print("RS_Result.set");\n                            output.with_parens(function () {\n                                self.statement.print(output);\n                                [output.space(), output.print(","), output.space()];\n                                output.with_parens(function () {\n                                    if (self.value_statement.constructor === AST_Seq) {\n                                        output.with_square(function () {\n                                            self.value_statement.print(output);\n                                        });\n                                    } else {\n                                        self.value_statement.print(output);\n                                    }\n                                });\n                            });\n                            output.end_statement();\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["output"]}\n                        });\n                        return RS_anonfunc;\n                    })();\n                } else {\n                    add_to_result = (function() {\n                        var RS_anonfunc = function (output) {\n                            output.indent();\n                            output.print("RS_Result");\n                            output.with_square(function () {\n                                self.statement.print(output);\n                            });\n                            [output.space(), output.print("="), output.space()];\n                            output.with_parens(function () {\n                                if (self.value_statement.constructor === AST_Seq) {\n                                    output.with_square(function () {\n                                        self.value_statement.print(output);\n                                    });\n                                } else {\n                                    self.value_statement.print(output);\n                                }\n                            });\n                            output.end_statement();\n                        };\n                        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                            __argnames__ : {value: ["output"]}\n                        });\n                        return RS_anonfunc;\n                    })();\n                }\n            } else {\n                push_func = "RS_Result." + ((self.constructor === AST_ListComprehension) ? "push" : "add");\n                if (is_generator) {\n                    push_func = "yield ";\n                }\n                add_to_result = (function() {\n                    var RS_anonfunc = function (output) {\n                        output.indent();\n                        output.print(push_func);\n                        output.with_parens(function () {\n                            if (self.statement.constructor === AST_Seq) {\n                                output.with_square(function () {\n                                    self.statement.print(output);\n                                });\n                            } else {\n                                self.statement.print(output);\n                            }\n                        });\n                        output.end_statement();\n                    };\n                    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                        __argnames__ : {value: ["output"]}\n                    });\n                    return RS_anonfunc;\n                })();\n            }\n            output.with_parens(function () {\n                output.print("function");\n                output.print("()");\n                output.space();\n                output.with_block(function () {\n                    var body_out, previous_indentation, i, transpiled, ci;\n                    body_out = output;\n                    if (is_generator) {\n                        if (es5) {\n                            body_out = new OutputStream((function(){\n                                var RS_d = Object.create(null);\n                                RS_d["beautify"] = true;\n                                return RS_d;\n                            }).call(this));\n                        }\n                        body_out.indent();\n                        [body_out.print("function* js_generator()"), body_out.space(), body_out.print("{")];\n                        body_out.newline();\n                        previous_indentation = output.indentation();\n                        output.set_indentation(output.next_indent());\n                    }\n                    body_out.indent();\n                    body_out.assign("var RS_Iter");\n                    if (es5) {\n                        body_out.print("RS_Iterable");\n                        body_out.with_parens(function () {\n                            self.object.print(body_out);\n                        });\n                    } else {\n                        self.object.print(body_out);\n                    }\n                    if (result_obj) {\n                        body_out.comma();\n                        body_out.assign("RS_Result");\n                        body_out.print(result_obj);\n                    }\n                    if (is_node_type(self.init, AST_Array)) {\n                        var RS_Iter88 = RS_Iterable(self.init.elements);\n                        for (var RS_Index88 = 0; RS_Index88 < RS_Iter88.length; RS_Index88++) {\n                            i = RS_Iter88[RS_Index88];\n                            body_out.comma();\n                            i.print(body_out);\n                        }\n                    } else {\n                        body_out.comma();\n                        self.init.print(body_out);\n                    }\n                    body_out.end_statement();\n                    if (!es5) {\n                        init_es6_itervar(body_out, "RS_Iter");\n                    }\n                    body_out.indent();\n                    body_out.print("for");\n                    body_out.space();\n                    body_out.with_parens(function () {\n                        if (es5) {\n                            body_out.print("var");\n                            body_out.space();\n                            body_out.assign("RS_Index");\n                            body_out.print("0");\n                            body_out.semicolon();\n                            body_out.space();\n                            body_out.print("RS_Index");\n                            body_out.space();\n                            body_out.print("<");\n                            body_out.space();\n                            body_out.print("RS_Iter.length");\n                            body_out.semicolon();\n                            body_out.space();\n                            body_out.print("RS_Index++");\n                        } else {\n                            body_out.spaced("var", "RS_Index", "of", "RS_Iter");\n                        }\n                    });\n                    body_out.space();\n                    body_out.with_block(function () {\n                        var itervar, flat;\n                        body_out.indent();\n                        itervar = (es5) ? "RS_Iter[RS_Index]" : "RS_Index";\n                        if (is_node_type(self.init, AST_Array)) {\n                            flat = self.init.flatten();\n                            body_out.assign("RS_unpack");\n                            if (flat.length > self.init.elements.length) {\n                                body_out.print("RS_flatten(" + itervar + ")");\n                            } else {\n                                body_out.print(itervar);\n                            }\n                            body_out.end_statement();\n                            unpack_tuple(flat, body_out);\n                        } else {\n                            body_out.assign(self.init);\n                            body_out.print(itervar);\n                            body_out.end_statement();\n                        }\n                        if (self.condition) {\n                            body_out.indent();\n                            body_out.print("if");\n                            body_out.space();\n                            body_out.with_parens(function () {\n                                self.condition.print(body_out);\n                            });\n                            body_out.space();\n                            body_out.with_block(function () {\n                                add_to_result(body_out);\n                            });\n                            body_out.newline();\n                        } else {\n                            add_to_result(body_out);\n                        }\n                    });\n                    body_out.newline();\n                    if (self.constructor === AST_ListComprehension) {\n                        body_out.indent();\n                        body_out.spaced("RS_Result", "=", "RS_list_constructor(RS_Result)");\n                        body_out.end_statement();\n                    }\n                    if (!is_generator) {\n                        body_out.indent();\n                        body_out.print("return RS_Result");\n                        body_out.end_statement();\n                    }\n                    if (is_generator) {\n                        output.set_indentation(previous_indentation);\n                        [body_out.newline(), body_out.indent(), body_out.print("}")];\n                        if (es5) {\n                            transpiled = regenerate(body_out.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, "RS_regenerator.regeneratorRuntime.$1");\n                            if (output.options.beautify) {\n                                ci = output.make_indent(0);\n                                transpiled = (function() {\n                                    var RS_Iter = RS_Iterable(transpiled.split("\\n")), RS_Result = [], x;\n                                    for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                                        x = RS_Iter[RS_Index];\n                                        RS_Result.push(ci + x);\n                                    }\n                                    RS_Result = RS_list_constructor(RS_Result);\n                                    return RS_Result;\n                                })().join("\\n");\n                            }\n                            output.print(transpiled);\n                        }\n                        [output.newline(), output.indent()];\n                        output.spaced("var", "result", "=", "js_generator.call(this)");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced("result.send", "=", "result.next");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced("return", "result");\n                        output.end_statement();\n                    }\n                });\n            });\n            output.print("()");\n        };\n        if (!print_list_comprehension.__argnames__) Object.defineProperties(print_list_comprehension, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        RS_modules["output.loops"].unpack_tuple = unpack_tuple;\n        RS_modules["output.loops"].print_do_loop = print_do_loop;\n        RS_modules["output.loops"].print_while_loop = print_while_loop;\n        RS_modules["output.loops"].is_simple_for_in = is_simple_for_in;\n        RS_modules["output.loops"].is_simple_for = is_simple_for;\n        RS_modules["output.loops"].print_for_loop_body = print_for_loop_body;\n        RS_modules["output.loops"].init_es6_itervar = init_es6_itervar;\n        RS_modules["output.loops"].print_for_in = print_for_in;\n        RS_modules["output.loops"].print_list_comprehension = print_list_comprehension;\n    })();\n\n    (function(){\n        var __name__ = "output.operators";\n        var comparators, function_ops, after_map;\n        var AST_Array = RS_modules.ast.AST_Array;\n        var AST_Assign = RS_modules.ast.AST_Assign;\n        var AST_BaseCall = RS_modules.ast.AST_BaseCall;\n        var AST_Binary = RS_modules.ast.AST_Binary;\n        var AST_Conditional = RS_modules.ast.AST_Conditional;\n        var AST_ItemAccess = RS_modules.ast.AST_ItemAccess;\n        var AST_Number = RS_modules.ast.AST_Number;\n        var AST_Object = RS_modules.ast.AST_Object;\n        var AST_Return = RS_modules.ast.AST_Return;\n        var AST_Seq = RS_modules.ast.AST_Seq;\n        var AST_Set = RS_modules.ast.AST_Set;\n        var AST_SimpleStatement = RS_modules.ast.AST_SimpleStatement;\n        var AST_Statement = RS_modules.ast.AST_Statement;\n        var AST_String = RS_modules.ast.AST_String;\n        var AST_Sub = RS_modules.ast.AST_Sub;\n        var AST_Symbol = RS_modules.ast.AST_Symbol;\n        var AST_SymbolRef = RS_modules.ast.AST_SymbolRef;\n        var AST_Unary = RS_modules.ast.AST_Unary;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        var unpack_tuple = RS_modules["output.loops"].unpack_tuple;\n\n        function print_getattr(self, output, skip_expression) {\n            var expr;\n            if (!skip_expression) {\n                expr = self.expression;\n                expr.print(output);\n            }\n            if (is_node_type(expr, AST_Number) && expr.value >= 0) {\n                if (!/[xa-f.]/i.test(output.last())) {\n                    output.print(".");\n                }\n            }\n            output.print(".");\n            output.print_name(self.property);\n        };\n        if (!print_getattr.__argnames__) Object.defineProperties(print_getattr, {\n            __argnames__ : {value: ["self", "output", "skip_expression"]}\n        });\n\n        function print_getitem(self, output) {\n            var expr, prop, is_negative_number, is_repeatable;\n            expr = self.expression;\n            prop = self.property;\n            if (is_node_type(prop, AST_Number) || is_node_type(prop, AST_String) || is_node_type(prop, AST_SymbolRef) && prop.name && prop.name.startsWith("RS_")) {\n                expr.print(output);\n                [output.print("["), prop.print(output), output.print("]")];\n                return;\n            }\n            is_negative_number = is_node_type(prop, AST_Unary) && prop.operator === "-" && is_node_type(prop.expression, AST_Number);\n            is_repeatable = is_node_type(expr, AST_SymbolRef);\n            if (is_repeatable) {\n                expr.print(output);\n            } else {\n                [output.spaced("(RS_expr_temp", "=", expr), output.print(")")];\n                expr = (function(){\n                    var RS_d = Object.create(null);\n                    RS_d["print"] = function () {\n                        output.print("RS_expr_temp");\n                    };\n                    return RS_d;\n                }).call(this);\n            }\n            if (is_negative_number) {\n                [output.print("["), expr.print(output), output.print(".length"), prop.print(output), \n                output.print("]")];\n                return;\n            }\n            is_repeatable = is_node_type(prop, AST_SymbolRef);\n            if (is_repeatable) {\n                output.spaced("[(typeof", prop, "===", "\\"number\\"", "&&", prop);\n                [output.spaced("", "<", "0)", "?", expr), output.spaced(".length", "+", prop, ":", prop)];\n                output.print("]");\n            } else {\n                [output.print("[RS_bound_index("), prop.print(output), output.comma(), expr.print(output), \n                output.print(")]")];\n            }\n        };\n        if (!print_getitem.__argnames__) Object.defineProperties(print_getitem, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_rich_getitem(self, output) {\n            var func;\n            func = "RS_" + ((self.assignment) ? "setitem" : "getitem");\n            output.print(func + "(");\n            [self.expression.print(output), output.comma(), self.property.print(output)];\n            if (self.assignment) {\n                [output.comma(), self.assignment.print(output)];\n            }\n            output.print(")");\n        };\n        if (!print_rich_getitem.__argnames__) Object.defineProperties(print_rich_getitem, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_splice_assignment(self, output) {\n            output.print("RS_splice(");\n            [self.expression.print(output), output.comma(), self.assignment.print(output), output.comma()];\n            (self.property) ? self.property.print(output) : output.print("0");\n            if (self.property2) {\n                output.comma();\n                self.property2.print(output);\n            }\n            output.print(")");\n        };\n        if (!print_splice_assignment.__argnames__) Object.defineProperties(print_splice_assignment, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_delete(self, output) {\n            if (is_node_type(self, AST_Symbol)) {\n                [output.assign(self), output.print("undefined")];\n            } else if (is_node_type(self, AST_Sub) || is_node_type(self, AST_ItemAccess)) {\n                [output.print("RS_delitem("), self.expression.print(output), output.comma(), self.property.print(output), \n                output.print(")")];\n            } else {\n                output.spaced("delete", self);\n            }\n        };\n        if (!print_delete.__argnames__) Object.defineProperties(print_delete, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_unary_prefix(self, output) {\n            var op;\n            op = self.operator;\n            if (op === "delete") {\n                return print_delete(self.expression, output);\n            }\n            output.print(op);\n            if (/^[a-z]/i.test(op)) {\n                output.space();\n            }\n            self.expression.print(output);\n        };\n        if (!print_unary_prefix.__argnames__) Object.defineProperties(print_unary_prefix, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function write_instanceof(left, right, output) {\n            function do_many(vals) {\n                [output.print("RS_instanceof.apply(null,"), output.space()];\n                [output.print("["), left.print(output), output.comma()];\n                for (var i = 0; i < vals.length; i++) {\n                    vals[(typeof i === "number" && i < 0) ? vals.length + i : i].print(output);\n                    if (i !== vals.length - 1) {\n                        output.comma();\n                    }\n                }\n                output.print("])");\n            };\n            if (!do_many.__argnames__) Object.defineProperties(do_many, {\n                __argnames__ : {value: ["vals"]}\n            });\n\n            if (is_node_type(right, AST_Seq)) {\n                do_many(right.to_array());\n            } else if (is_node_type(right, AST_Array)) {\n                do_many(right.elements);\n            } else {\n                output.print("RS_instanceof(");\n                [left.print(output), output.comma(), right.print(output), output.print(")")];\n            }\n        };\n        if (!write_instanceof.__argnames__) Object.defineProperties(write_instanceof, {\n            __argnames__ : {value: ["left", "right", "output"]}\n        });\n\n        function write_smart_equality(self, output) {\n            function is_ok(x) {\n                return !(is_node_type(x, AST_Array) || is_node_type(x, AST_Set) || is_node_type(x, AST_Object) || is_node_type(x, AST_Statement) || is_node_type(x, AST_Binary) || is_node_type(x, AST_Conditional) || is_node_type(x, AST_BaseCall));\n            };\n            if (!is_ok.__argnames__) Object.defineProperties(is_ok, {\n                __argnames__ : {value: ["x"]}\n            });\n\n            if (is_ok(self.left) && is_ok(self.right)) {\n                if (self.operator === "==") {\n                    output.print("(");\n                    output.spaced(self.left, "===", self.right, "||", "typeof", self.left, "===", "\\"object\\"", "&&", "RS_equals(");\n                    [self.left.print(output), output.print(","), output.space(), self.right.print(output), \n                    output.print("))")];\n                } else {\n                    output.print("(");\n                    output.spaced(self.left, "!==", self.right, "&&", "(typeof", self.left, "!==", "\\"object\\"", "||", "RS_not_equals(");\n                    [self.left.print(output), output.print(","), output.space(), self.right.print(output), \n                    output.print(")))")];\n                }\n            } else {\n                output.print("RS_" + ((self.operator === "==") ? "equals(" : "not_equals("));\n                [self.left.print(output), output.print(","), output.space(), self.right.print(output), \n                output.print(")")];\n            }\n        };\n        if (!write_smart_equality.__argnames__) Object.defineProperties(write_smart_equality, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        comparators = (function(){\n            var RS_d = Object.create(null);\n            RS_d["<"] = true;\n            RS_d[">"] = true;\n            RS_d["<="] = true;\n            RS_d[">="] = true;\n            return RS_d;\n        }).call(this);\n        function_ops = (function(){\n            var RS_d = Object.create(null);\n            RS_d["in"] = "RS_in";\n            return RS_d;\n        }).call(this);\n        function print_binary_op(self, output) {\n            var leftvar, left;\n            if (function_ops[RS_bound_index(self.operator, function_ops)]) {\n                output.print(function_ops[RS_bound_index(self.operator, function_ops)]);\n                output.with_parens(function () {\n                    self.left.print(output);\n                    output.comma();\n                    self.right.print(output);\n                });\n            } else if (comparators[RS_bound_index(self.operator, comparators)] && is_node_type(self.left, AST_Binary) && comparators[RS_bound_index(self.left.operator, comparators)]) {\n                if (is_node_type(self.left.right, AST_Symbol)) {\n                    self.left.print(output);\n                    leftvar = self.left.right.name;\n                } else {\n                    self.left.left.print(output);\n                    output.space();\n                    output.print(self.left.operator);\n                    output.space();\n                    output.with_parens(function () {\n                        output.assign("RS_cond_temp");\n                        self.left.right.print(output);\n                        leftvar = "RS_cond_temp";\n                    });\n                }\n                output.space();\n                output.print("&&");\n                output.space();\n                output.print(leftvar);\n                output.space();\n                output.print(self.operator);\n                output.space();\n                self.right.print(output);\n            } else if (self.operator === "//") {\n                output.print("Math.floor");\n                output.with_parens(function () {\n                    self.left.print(output);\n                    output.space();\n                    output.print("/");\n                    output.space();\n                    self.right.print(output);\n                });\n            } else if (self.operator === "**") {\n                left = self.left;\n                if (is_node_type(self.left, AST_Unary) && !self.left.parenthesized) {\n                    left = self.left.expression;\n                    output.print(self.left.operator);\n                }\n                if (output.options.js_version > 6) {\n                    [output.print("(("), left.print(output), output.spaced(")", "**", "("), self.right.print(output), \n                    output.print("))")];\n                } else {\n                    [output.print("Math.pow("), left.print(output), output.comma(), self.right.print(output), \n                    output.print(")")];\n                }\n            } else if (self.operator === "==" || self.operator === "!=") {\n                write_smart_equality(self, output);\n            } else if (self.operator === "instanceof") {\n                write_instanceof(self.left, self.right, output);\n            } else if (self.operator === "*" && is_node_type(self.left, AST_String)) {\n                [self.left.print(output), output.print(".repeat("), self.right.print(output), output.print(")")];\n            } else {\n                output.spaced(self.left, self.operator, self.right);\n            }\n        };\n        if (!print_binary_op.__argnames__) Object.defineProperties(print_binary_op, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        after_map = (function(){\n            var RS_d = Object.create(null);\n            RS_d["."] = "d";\n            RS_d["("] = "c";\n            RS_d["["] = "d";\n            RS_d["g"] = "g";\n            RS_d["null"] = "n";\n            return RS_d;\n        }).call(this);\n        function print_existential(self, output) {\n            var key, after;\n            key = (self.after === null || typeof self.after === "string") ? after_map[RS_bound_index(self.after, after_map)] : "e";\n            if (is_node_type(self.expression, AST_SymbolRef)) {\n                if (key === "n") {\n                    output.spaced("(typeof", self.expression, "!==", "\\"undefined\\"", "&&", self.expression, "!==", "null)");\n                    return;\n                }\n                if (key === "c") {\n                    output.spaced("(typeof", self.expression, "===", "\\"function\\"", "?", self.expression, ":", "(function(){return undefined;}))");\n                    return;\n                }\n                after = self.after;\n                if (key === "d") {\n                    after = "Object.create(null)";\n                } else if (key === "g") {\n                    after = "{__getitem__:function(){return undefined;}}";\n                }\n                output.spaced("(typeof", self.expression, "!==", "\\"undefined\\"", "&&", self.expression, "!==", "null", "?", self.expression, ":", after);\n                output.print(")");\n                return;\n            }\n            output.print("RS_exists." + key + "(");\n            self.expression.print(output);\n            if (key === "e") {\n                [output.comma(), self.after.print(output)];\n            }\n            output.print(")");\n        };\n        if (!print_existential.__argnames__) Object.defineProperties(print_existential, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_assignment(self, output) {\n            var flattened, left, flat;\n            flattened = false;\n            left = self.left;\n            if (is_node_type(left, AST_Seq)) {\n                left = new AST_Array((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["elements"] = [left.car, left.cdr];\n                    return RS_d;\n                }).call(this));\n            }\n            if (is_node_type(left, AST_Array)) {\n                flat = left.flatten();\n                flattened = flat.length > left.elements.length;\n                output.print("RS_unpack");\n            } else {\n                left.print(output);\n            }\n            output.space();\n            output.print(self.operator);\n            output.space();\n            if (flattened) {\n                output.print("RS_flatten");\n                output.with_parens(function () {\n                    self.right.print(output);\n                });\n            } else {\n                self.right.print(output);\n            }\n            if (is_node_type(left, AST_Array)) {\n                output.end_statement();\n                if (!is_node_type(self.right, AST_Seq) && !is_node_type(self.right, AST_Array)) {\n                    output.assign("RS_unpack");\n                    [output.print("RS_unpack_asarray(" + flat.length), output.comma(), output.print("RS_unpack)")];\n                    output.end_statement();\n                }\n                unpack_tuple(flat, output, true);\n            }\n        };\n        if (!print_assignment.__argnames__) Object.defineProperties(print_assignment, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_assign(self, output) {\n            var RS_unpack, left_hand_sides, rhs, is_compound_assign, lhs, temp_rhs;\n            if (self.operator === "//=") {\n                output.assign(self.left);\n                output.print("Math.floor");\n                output.with_parens(function () {\n                    self.left.print(output);\n                    output.space();\n                    output.print("/");\n                    output.space();\n                    self.right.print(output);\n                });\n                return;\n            }\n            if (self.operator === "=" && self.is_chained()) {\n                RS_unpack = self.traverse_chain();\nRS_unpack = RS_unpack_asarray(2, RS_unpack);\n                left_hand_sides = RS_unpack[0];\n                rhs = RS_unpack[1];\n                is_compound_assign = false;\n                var RS_Iter89 = RS_Iterable(left_hand_sides);\n                for (var RS_Index89 = 0; RS_Index89 < RS_Iter89.length; RS_Index89++) {\n                    lhs = RS_Iter89[RS_Index89];\n                    if (is_node_type(lhs, AST_Seq) || is_node_type(lhs, AST_Array)) {\n                        is_compound_assign = true;\n                        break;\n                    }\n                }\n                if (is_compound_assign) {\n                    temp_rhs = new AST_SymbolRef((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["name"] = "RS_chain_assign_temp";\n                        return RS_d;\n                    }).call(this));\n                    print_assignment(new AST_Assign((function(){\n                        var RS_d = Object.create(null);\n                        RS_d["left"] = temp_rhs;\n                        RS_d["operator"] = "=";\n                        RS_d["right"] = rhs;\n                        return RS_d;\n                    }).call(this)), output);\n                    var RS_Iter90 = RS_Iterable(left_hand_sides);\n                    for (var RS_Index90 = 0; RS_Index90 < RS_Iter90.length; RS_Index90++) {\n                        lhs = RS_Iter90[RS_Index90];\n                        [output.end_statement(), output.indent()];\n                        print_assignment(new AST_Assign((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["left"] = lhs;\n                            RS_d["right"] = temp_rhs;\n                            RS_d["operator"] = self.operator;\n                            return RS_d;\n                        }).call(this)), output);\n                    }\n                } else {\n                    var RS_Iter91 = RS_Iterable(left_hand_sides);\n                    for (var RS_Index91 = 0; RS_Index91 < RS_Iter91.length; RS_Index91++) {\n                        lhs = RS_Iter91[RS_Index91];\n                        output.spaced(lhs, "=", "");\n                    }\n                    rhs.print(output);\n                }\n            } else {\n                print_assignment(self, output);\n            }\n        };\n        if (!print_assign.__argnames__) Object.defineProperties(print_assign, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_conditional(self, output, condition, consequent, alternative) {\n            var RS_unpack;\n            RS_unpack = [self.condition, self.consequent, self.alternative];\n            condition = RS_unpack[0];\n            consequent = RS_unpack[1];\n            alternative = RS_unpack[2];\n            output.with_parens(function () {\n                condition.print(output);\n            });\n            output.space();\n            output.print("?");\n            output.space();\n            consequent.print(output);\n            output.space();\n            output.colon();\n            alternative.print(output);\n        };\n        if (!print_conditional.__argnames__) Object.defineProperties(print_conditional, {\n            __argnames__ : {value: ["self", "output", "condition", "consequent", "alternative"]}\n        });\n\n        function print_seq(output) {\n            var self, p, print_seq;\n            self = this;\n            p = output.parent();\n            print_seq = function () {\n                self.car.print(output);\n                if (self.cdr) {\n                    output.comma();\n                    if (output.should_break()) {\n                        output.newline();\n                        output.indent();\n                    }\n                    self.cdr.print(output);\n                }\n            };\n            if (is_node_type(p, AST_Binary) || is_node_type(p, AST_Return) || is_node_type(p, AST_Array) || is_node_type(p, AST_BaseCall) || is_node_type(p, AST_SimpleStatement)) {\n                output.with_square(print_seq);\n            } else {\n                print_seq();\n            }\n        };\n        if (!print_seq.__argnames__) Object.defineProperties(print_seq, {\n            __argnames__ : {value: ["output"]}\n        });\n\n        RS_modules["output.operators"].comparators = comparators;\n        RS_modules["output.operators"].function_ops = function_ops;\n        RS_modules["output.operators"].after_map = after_map;\n        RS_modules["output.operators"].print_getattr = print_getattr;\n        RS_modules["output.operators"].print_getitem = print_getitem;\n        RS_modules["output.operators"].print_rich_getitem = print_rich_getitem;\n        RS_modules["output.operators"].print_splice_assignment = print_splice_assignment;\n        RS_modules["output.operators"].print_delete = print_delete;\n        RS_modules["output.operators"].print_unary_prefix = print_unary_prefix;\n        RS_modules["output.operators"].write_instanceof = write_instanceof;\n        RS_modules["output.operators"].write_smart_equality = write_smart_equality;\n        RS_modules["output.operators"].print_binary_op = print_binary_op;\n        RS_modules["output.operators"].print_existential = print_existential;\n        RS_modules["output.operators"].print_assignment = print_assignment;\n        RS_modules["output.operators"].print_assign = print_assign;\n        RS_modules["output.operators"].print_conditional = print_conditional;\n        RS_modules["output.operators"].print_seq = print_seq;\n    })();\n\n    (function(){\n        var __name__ = "output.functions";\n        var anonfunc;\n        var AST_ClassCall = RS_modules.ast.AST_ClassCall;\n        var AST_New = RS_modules.ast.AST_New;\n        var has_calls = RS_modules.ast.has_calls;\n        var AST_Dot = RS_modules.ast.AST_Dot;\n        var AST_SymbolRef = RS_modules.ast.AST_SymbolRef;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        var OutputStream = RS_modules["output.stream"].OutputStream;\n\n        var print_bracketed = RS_modules["output.statements"].print_bracketed;\n\n        var create_doctring = RS_modules["output.utils"].create_doctring;\n\n        var print_getattr = RS_modules["output.operators"].print_getattr;\n\n        anonfunc = "RS_anonfunc";\n        function decorate(decorators, output, func) {\n            var pos;\n            pos = 0;\n            function wrap() {\n                if (pos < decorators.length) {\n                    decorators[(typeof pos === "number" && pos < 0) ? decorators.length + pos : pos].expression.print(output);\n                    pos += 1;\n                    output.with_parens(function () {\n                        wrap();\n                    });\n                } else {\n                    func();\n                }\n            };\n\n            wrap();\n        };\n        if (!decorate.__argnames__) Object.defineProperties(decorate, {\n            __argnames__ : {value: ["decorators", "output", "func"]}\n        });\n\n        function function_args(argnames, output, strip_first) {\n            output.with_parens(function () {\n                var RS_unpack, i, arg;\n                if (argnames && argnames.length && (argnames.is_simple_func === true || argnames.is_simple_func === undefined)) {\n                    var RS_Iter92 = RS_Iterable(enumerate((strip_first) ? argnames.slice(1) : argnames));\n                    for (var RS_Index92 = 0; RS_Index92 < RS_Iter92.length; RS_Index92++) {\n                        RS_unpack = RS_Iter92[RS_Index92];\n                        i = RS_unpack[0];\n                        arg = RS_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        arg.print(output);\n                    }\n                }\n            });\n            output.space();\n        };\n        if (!function_args.__argnames__) Object.defineProperties(function_args, {\n            __argnames__ : {value: ["argnames", "output", "strip_first"]}\n        });\n\n        function function_preamble(node, output, offset) {\n            var a, fname, kw, i, RS_unpack, c, arg, dname, nargs;\n            a = node.argnames;\n            if (!a || a.is_simple_func) {\n                return;\n            }\n            fname = (node.name) ? node.name.name : anonfunc;\n            kw = "arguments[arguments.length-1]";\n            var RS_Iter93 = RS_Iterable(enumerate(a));\n            for (var RS_Index93 = 0; RS_Index93 < RS_Iter93.length; RS_Index93++) {\n                RS_unpack = RS_Iter93[RS_Index93];\n                c = RS_unpack[0];\n                arg = RS_unpack[1];\n                i = c - offset;\n                if (i >= 0) {\n                    output.indent();\n                    output.print("var");\n                    output.space();\n                    output.assign(arg);\n                    if (Object.prototype.hasOwnProperty.call(a.defaults, arg.name)) {\n                        output.spaced("(arguments[" + i + "]", "===", "undefined", "||", "(", i, "===", "arguments.length-1", "&&", kw, "!==", "null", "&&", "typeof", kw, "===", "\\"object\\"", "&&", kw, "[RS_kwargs_symbol]", "===", "true))", "?", "");\n                        [output.print(fname + ".__defaults__."), arg.print(output)];\n                        [output.space(), output.print(":"), output.space()];\n                    } else {\n                        output.spaced("(", i, "===", "arguments.length-1", "&&", kw, "!==", "null", "&&", "typeof", kw, "===", "\\"object\\"", "&&", kw, "[RS_kwargs_symbol]", "===", "true)", "?", "undefined", ":", "");\n                    }\n                    output.print("arguments[" + i + "]");\n                    output.end_statement();\n                }\n            }\n            if (a.kwargs || a.has_defaults) {\n                kw = (a.kwargs) ? a.kwargs.name : "RS_kwargs_obj";\n                output.indent();\n                output.spaced("var", kw, "=", "arguments[arguments.length-1]");\n                output.end_statement();\n                output.indent();\n                output.spaced("if", "(" + kw, "===", "null", "||", "typeof", kw, "!==", "\\"object\\"", "||", kw, "[RS_kwargs_symbol]", "!==", "true)", kw, "=", "{}");\n                output.end_statement();\n                if (a.has_defaults) {\n                    var RS_Iter94 = RS_Iterable(Object.keys(a.defaults));\n                    for (var RS_Index94 = 0; RS_Index94 < RS_Iter94.length; RS_Index94++) {\n                        dname = RS_Iter94[RS_Index94];\n                        output.indent();\n                        output.spaced("if", "(Object.prototype.hasOwnProperty.call(" + kw + ",", "\\"" + dname + "\\"))");\n                        output.with_block(function () {\n                            output.indent();\n                            output.spaced(dname, "=", kw + "." + dname);\n                            output.end_statement();\n                            if (a.kwargs) {\n                                output.indent();\n                                output.spaced("delete", kw + "." + dname);\n                                output.end_statement();\n                            }\n                        });\n                        output.newline();\n                    }\n                }\n            }\n            if (a.starargs !== undefined) {\n                nargs = a.length - offset;\n                output.indent();\n                output.spaced("var", a.starargs.name, "=", "Array.prototype.slice.call(arguments,", nargs + ")");\n                output.end_statement();\n                output.indent();\n                output.spaced("if", "(" + kw, "!==", "null", "&&", "typeof", kw, "===", "\\"object\\"", "&&", kw, "[RS_kwargs_symbol]", "===", "true)", a.starargs.name);\n                output.print(".pop()");\n                output.end_statement();\n            }\n        };\n        if (!function_preamble.__argnames__) Object.defineProperties(function_preamble, {\n            __argnames__ : {value: ["node", "output", "offset"]}\n        });\n\n        function has_annotations(self) {\n            var arg;\n            if (self.return_annotation) {\n                return true;\n            }\n            var RS_Iter95 = RS_Iterable(self.argnames);\n            for (var RS_Index95 = 0; RS_Index95 < RS_Iter95.length; RS_Index95++) {\n                arg = RS_Iter95[RS_Index95];\n                if (arg.annotation) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (!has_annotations.__argnames__) Object.defineProperties(has_annotations, {\n            __argnames__ : {value: ["self"]}\n        });\n\n        function function_annotation(self, output, strip_first, name) {\n            var fname, props, defaults, dkeys, names;\n            fname = name || ((self.name) ? self.name.name : anonfunc);\n            props = Object.create(null);\n            if (has_annotations(self)) {\n                props.__annotations__ = function () {\n                    var RS_unpack, i, arg;\n                    output.print("{");\n                    if (self.argnames && self.argnames.length) {\n                        var RS_Iter96 = RS_Iterable(enumerate(self.argnames));\n                        for (var RS_Index96 = 0; RS_Index96 < RS_Iter96.length; RS_Index96++) {\n                            RS_unpack = RS_Iter96[RS_Index96];\n                            i = RS_unpack[0];\n                            arg = RS_unpack[1];\n                            if (arg.annotation) {\n                                arg.print(output);\n                                [output.print(":"), output.space()];\n                                arg.annotation.print(output);\n                                if (i < self.argnames.length - 1 || self.return_annotation) {\n                                    output.comma();\n                                }\n                            }\n                        }\n                    }\n                    if (self.return_annotation) {\n                        [output.print("return:"), output.space()];\n                        self.return_annotation.print(output);\n                    }\n                    output.print("}");\n                };\n            }\n            defaults = self.argnames.defaults;\n            dkeys = Object.keys(self.argnames.defaults);\n            if (dkeys.length) {\n                props.__defaults__ = function () {\n                    var RS_unpack, i, k;\n                    output.print("{");\n                    var RS_Iter97 = RS_Iterable(enumerate(dkeys));\n                    for (var RS_Index97 = 0; RS_Index97 < RS_Iter97.length; RS_Index97++) {\n                        RS_unpack = RS_Iter97[RS_Index97];\n                        i = RS_unpack[0];\n                        k = RS_unpack[1];\n                        [output.print(k + ":"), defaults[(typeof k === "number" && k < 0) ? defaults.length + k : k].print(output)];\n                        if (i !== dkeys.length - 1) {\n                            output.comma();\n                        }\n                    }\n                    output.print("}");\n                };\n            }\n            if (!self.argnames.is_simple_func) {\n                props.__handles_kwarg_interpolation__ = function () {\n                    output.print("true");\n                };\n            }\n            if (self.argnames.length > ((strip_first) ? 1 : 0)) {\n                props.__argnames__ = function () {\n                    var RS_unpack, i, arg;\n                    output.print("[");\n                    var RS_Iter98 = RS_Iterable(enumerate(self.argnames));\n                    for (var RS_Index98 = 0; RS_Index98 < RS_Iter98.length; RS_Index98++) {\n                        RS_unpack = RS_Iter98[RS_Index98];\n                        i = RS_unpack[0];\n                        arg = RS_unpack[1];\n                        if (strip_first && i === 0) {\n                            continue;\n                        }\n                        output.print(JSON.stringify(arg.name));\n                        if (i !== self.argnames.length - 1) {\n                            output.comma();\n                        }\n                    }\n                    output.print("]");\n                };\n            }\n            if (output.options.keep_docstrings && self.docstrings && self.docstrings.length) {\n                props.__doc__ = function () {\n                    output.print(JSON.stringify(create_doctring(self.docstrings)));\n                };\n            }\n            names = Object.keys(props);\n            if (names.length) {\n                output.indent();\n                output.spaced("if", "(!" + fname + "." + names[0] + ")", "Object.defineProperties(" + fname);\n                output.comma();\n                output.with_block(function () {\n                    var name;\n                    for (var i = 0; i < names.length; i++) {\n                        name = names[(typeof i === "number" && i < 0) ? names.length + i : i];\n                        [output.indent(), output.spaced(name, ":", "{value:", ""), props[(typeof name === "number" && name < 0) ? props.length + name : name](), \n                        output.print("}")];\n                        if (i < names.length - 1) {\n                            output.print(",");\n                        }\n                        output.newline();\n                    }\n                });\n                [output.print(")"), output.end_statement()];\n            }\n        };\n        if (!function_annotation.__argnames__) Object.defineProperties(function_annotation, {\n            __argnames__ : {value: ["self", "output", "strip_first", "name"]}\n        });\n\n        function function_definition(self, output, strip_first, as_expression) {\n            var has_argnames, orig_indent;\n            as_expression = as_expression || self.is_expression || self.is_anonymous;\n            has_argnames = self.argnames.length > ((strip_first) ? 1 : 0);\n            if (!has_argnames && !self.return_annotation && (!output.options.keep_docstrings || !self.docstrings || !self.docstrings.length)) {\n                as_expression = false;\n            }\n            if (as_expression) {\n                orig_indent = output.indentation();\n                output.set_indentation(output.next_indent());\n                [output.spaced("(function()", "{"), output.newline()];\n                [output.indent(), output.spaced("var", anonfunc, "="), output.space()];\n            }\n            [output.print("function"), output.space()];\n            if (self.name) {\n                self.name.print(output);\n            }\n            if (self.is_generator) {\n                [output.print("()"), output.space()];\n                output.with_block(function () {\n                    var temp, transpiled, ci;\n                    if (output.options.js_version >= 6) {\n                        output.indent();\n                        output.print("function* js_generator");\n                        function_args(self.argnames, output, strip_first);\n                        print_bracketed(self, output, true, function_preamble);\n                    } else {\n                        temp = new OutputStream((function(){\n                            var RS_d = Object.create(null);\n                            RS_d["beautify"] = true;\n                            return RS_d;\n                        }).call(this));\n                        temp.print("function* js_generator");\n                        function_args(self.argnames, temp, strip_first);\n                        print_bracketed(self, temp, true, function_preamble);\n                        transpiled = regenerate(temp.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, "RS_regenerator.regeneratorRuntime.$1");\n                        if (output.options.beautify) {\n                            ci = output.make_indent(0);\n                            transpiled = (function() {\n                                var RS_Iter = RS_Iterable(transpiled.split("\\n")), RS_Result = [], x;\n                                for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                                    x = RS_Iter[RS_Index];\n                                    RS_Result.push(ci + x);\n                                }\n                                RS_Result = RS_list_constructor(RS_Result);\n                                return RS_Result;\n                            })().join("\\n");\n                        }\n                        output.print(transpiled);\n                    }\n                    output.newline();\n                    output.indent();\n                    output.spaced("var", "result", "=", "js_generator.apply(this,", "arguments)");\n                    output.end_statement();\n                    output.indent();\n                    output.spaced("result.send", "=", "result.next");\n                    output.end_statement();\n                    output.indent();\n                    output.spaced("return", "result");\n                    output.end_statement();\n                });\n            } else {\n                function_args(self.argnames, output, strip_first);\n                print_bracketed(self, output, true, function_preamble);\n            }\n            if (as_expression) {\n                output.end_statement();\n                function_annotation(self, output, strip_first, anonfunc);\n                [output.indent(), output.spaced("return", anonfunc), output.end_statement()];\n                output.set_indentation(orig_indent);\n                [output.indent(), output.print("})()")];\n            }\n        };\n        if (!function_definition.__argnames__) Object.defineProperties(function_definition, {\n            __argnames__ : {value: ["self", "output", "strip_first", "as_expression"]}\n        });\n\n        function print_function(output) {\n            var self;\n            self = this;\n            if (self.decorators && self.decorators.length) {\n                output.print("var");\n                output.space();\n                output.assign(self.name.name);\n                decorate(self.decorators, output, function () {\n                    function_definition(self, output, false, true);\n                });\n                output.end_statement();\n            } else {\n                function_definition(self, output, false);\n                if (!self.is_expression && !self.is_anonymous) {\n                    output.end_statement();\n                    function_annotation(self, output, false);\n                }\n            }\n        };\n        if (!print_function.__argnames__) Object.defineProperties(print_function, {\n            __argnames__ : {value: ["output"]}\n        });\n\n        function find_this(expression) {\n            if (is_node_type(expression, AST_Dot)) {\n                return expression.expression;\n            }\n            if (!is_node_type(expression, AST_SymbolRef)) {\n                return expression;\n            }\n        };\n        if (!find_this.__argnames__) Object.defineProperties(find_this, {\n            __argnames__ : {value: ["expression"]}\n        });\n\n        function print_this(expression, output) {\n            var obj;\n            obj = find_this(expression);\n            if (obj) {\n                obj.print(output);\n            } else {\n                output.print("this");\n            }\n        };\n        if (!print_this.__argnames__) Object.defineProperties(print_this, {\n            __argnames__ : {value: ["expression", "output"]}\n        });\n\n        function print_function_call(self, output) {\n            var is_prototype_call, has_kwarg_items, has_kwarg_formals, has_kwargs, is_new, is_repeatable;\n            is_prototype_call = false;\n            function print_function_name(no_call) {\n                if (is_node_type(self, AST_ClassCall)) {\n                    if (self.static) {\n                        self.class.print(output);\n                        output.print(".");\n                        output.print(self.method);\n                    } else {\n                        is_prototype_call = true;\n                        self.class.print(output);\n                        output.print(".prototype.");\n                        output.print(self.method);\n                        if (!no_call) {\n                            output.print(".call");\n                        }\n                    }\n                } else {\n                    if (!is_repeatable) {\n                        output.print("RS_expr_temp");\n                        if (is_node_type(self.expression, AST_Dot)) {\n                            print_getattr(self.expression, output, true);\n                        }\n                    } else {\n                        self.expression.print(output);\n                    }\n                }\n            };\n            if (!print_function_name.__argnames__) Object.defineProperties(print_function_name, {\n                __argnames__ : {value: ["no_call"]}\n            });\n\n            function print_kwargs() {\n                var RS_unpack, i, kwname, pair;\n                output.print("RS_desugar_kwargs(");\n                if (has_kwarg_items) {\n                    var RS_Iter99 = RS_Iterable(enumerate(self.args.kwarg_items));\n                    for (var RS_Index99 = 0; RS_Index99 < RS_Iter99.length; RS_Index99++) {\n                        RS_unpack = RS_Iter99[RS_Index99];\n                        i = RS_unpack[0];\n                        kwname = RS_unpack[1];\n                        if (i > 0) {\n                            output.print(",");\n                            output.space();\n                        }\n                        kwname.print(output);\n                    }\n                    if (has_kwarg_formals) {\n                        output.print(",");\n                        output.space();\n                    }\n                }\n                if (has_kwarg_formals) {\n                    output.print("{");\n                    var RS_Iter100 = RS_Iterable(enumerate(self.args.kwargs));\n                    for (var RS_Index100 = 0; RS_Index100 < RS_Iter100.length; RS_Index100++) {\n                        RS_unpack = RS_Iter100[RS_Index100];\n                        i = RS_unpack[0];\n                        pair = RS_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        pair[0].print(output);\n                        output.print(":");\n                        output.space();\n                        pair[1].print(output);\n                    }\n                    output.print("}");\n                }\n                output.print(")");\n            };\n\n            function print_new(apply) {\n                output.print("RS_interpolate_kwargs_constructor.call(");\n                [output.print("Object.create("), self.expression.print(output), output.print(".prototype)")];\n                output.comma();\n                output.print((apply) ? "true" : "false");\n                output.comma();\n            };\n            if (!print_new.__argnames__) Object.defineProperties(print_new, {\n                __argnames__ : {value: ["apply"]}\n            });\n\n            function do_print_this() {\n                if (!is_repeatable) {\n                    output.print("RS_expr_temp");\n                } else {\n                    print_this(self.expression, output);\n                }\n                output.comma();\n            };\n\n            function print_positional_args() {\n                var i, expr, is_first;\n                i = 0;\n                while (i < self.args.length) {\n                    expr = (RS_expr_temp = self.args)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n                    is_first = i === 0;\n                    if (!is_first) {\n                        output.print(".concat(");\n                    }\n                    if (expr.is_array) {\n                        expr.print(output);\n                        i += 1;\n                    } else {\n                        output.print("[");\n                        while (i < self.args.length && !(RS_expr_temp = self.args)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].is_array) {\n                            (RS_expr_temp = self.args)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].print(output);\n                            if (i + 1 < self.args.length && !(RS_expr_temp = self.args)[RS_bound_index(i + 1, RS_expr_temp)].is_array) {\n                                output.print(",");\n                                output.space();\n                            }\n                            i += 1;\n                        }\n                        output.print("]");\n                    }\n                    if (!is_first) {\n                        output.print(")");\n                    }\n                }\n            };\n\n            has_kwarg_items = self.args.kwarg_items && self.args.kwarg_items.length;\n            has_kwarg_formals = self.args.kwargs && self.args.kwargs.length;\n            has_kwargs = has_kwarg_items || has_kwarg_formals;\n            is_new = is_node_type(self, AST_New);\n            is_repeatable = true;\n            if (is_new && !self.args.length && !has_kwargs && !self.args.starargs) {\n                [output.print("new"), output.space()];\n                print_function_name();\n                return;\n            }\n            if (!has_kwargs && !self.args.starargs) {\n                if (is_new) {\n                    [output.print("new"), output.space()];\n                }\n                print_function_name();\n                output.with_parens(function () {\n                    var RS_unpack, i, a;\n                    var RS_Iter101 = RS_Iterable(enumerate(self.args));\n                    for (var RS_Index101 = 0; RS_Index101 < RS_Iter101.length; RS_Index101++) {\n                        RS_unpack = RS_Iter101[RS_Index101];\n                        i = RS_unpack[0];\n                        a = RS_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        a.print(output);\n                    }\n                });\n                return;\n            }\n            is_repeatable = is_new || !has_calls(self.expression);\n            if (!is_repeatable) {\n                [output.assign("(RS_expr_temp"), print_this(self.expression, output), output.comma()];\n            }\n            if (has_kwargs) {\n                if (is_new) {\n                    print_new(false);\n                } else {\n                    output.print("RS_interpolate_kwargs.call(");\n                    do_print_this();\n                }\n                print_function_name(true);\n                output.comma();\n            } else {\n                if (is_new) {\n                    print_new(true);\n                    print_function_name(true);\n                    output.comma();\n                } else {\n                    print_function_name(true);\n                    output.print(".apply(");\n                    do_print_this();\n                }\n            }\n            if (is_prototype_call && self.args.length > 1) {\n                self.args.shift();\n            }\n            print_positional_args();\n            if (has_kwargs) {\n                if (self.args.length) {\n                    output.print(".concat(");\n                }\n                output.print("[");\n                print_kwargs();\n                output.print("]");\n                if (self.args.length) {\n                    output.print(")");\n                }\n            }\n            output.print(")");\n            if (!is_repeatable) {\n                output.print(")");\n            }\n        };\n        if (!print_function_call.__argnames__) Object.defineProperties(print_function_call, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        RS_modules["output.functions"].anonfunc = anonfunc;\n        RS_modules["output.functions"].decorate = decorate;\n        RS_modules["output.functions"].function_args = function_args;\n        RS_modules["output.functions"].function_preamble = function_preamble;\n        RS_modules["output.functions"].has_annotations = has_annotations;\n        RS_modules["output.functions"].function_annotation = function_annotation;\n        RS_modules["output.functions"].function_definition = function_definition;\n        RS_modules["output.functions"].print_function = print_function;\n        RS_modules["output.functions"].find_this = find_this;\n        RS_modules["output.functions"].print_this = print_this;\n        RS_modules["output.functions"].print_function_call = print_function_call;\n    })();\n\n    (function(){\n        var __name__ = "output.classes";\n        var AST_Class = RS_modules.ast.AST_Class;\n        var AST_Method = RS_modules.ast.AST_Method;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        var decorate = RS_modules["output.functions"].decorate;\n        var function_definition = RS_modules["output.functions"].function_definition;\n        var function_annotation = RS_modules["output.functions"].function_annotation;\n\n        var create_doctring = RS_modules["output.utils"].create_doctring;\n\n        var has_prop = RS_modules.utils.has_prop;\n\n        function print_class(output) {\n            var self, seen_methods, property_names, defined_methods, sname, attr, stmt;\n            self = this;\n            if (self.external) {\n                return;\n            }\n            function class_def(method, is_var) {\n                output.indent();\n                self.name.print(output);\n                if (!is_var && method && has_prop(self.static, method)) {\n                    output.assign("." + method);\n                } else {\n                    if (is_var) {\n                        output.assign(".prototype[" + method + "]");\n                    } else {\n                        output.assign(".prototype" + ((method) ? "." + method : ""));\n                    }\n                }\n            };\n            if (!class_def.__argnames__) Object.defineProperties(class_def, {\n                __argnames__ : {value: ["method", "is_var"]}\n            });\n\n            function define_method(stmt, is_property) {\n                var name, is_static, strip_first, fname;\n                name = stmt.name.name;\n                if (!is_property) {\n                    class_def(name);\n                }\n                is_static = has_prop(self.static, name);\n                strip_first = !is_static;\n                if (stmt.decorators && stmt.decorators.length) {\n                    decorate(stmt.decorators, output, function () {\n                        function_definition(stmt, output, strip_first, true);\n                    });\n                    output.end_statement();\n                } else {\n                    function_definition(stmt, output, strip_first);\n                    if (!is_property) {\n                        output.end_statement();\n                        fname = self.name.name + ((is_static) ? "." : ".prototype.") + name;\n                        function_annotation(stmt, output, strip_first, fname);\n                    }\n                }\n            };\n            if (!define_method.__argnames__) Object.defineProperties(define_method, {\n                __argnames__ : {value: ["stmt", "is_property"]}\n            });\n\n            function define_default_method(name, body) {\n                class_def(name);\n                output.spaced("function", name, "()", "");\n                output.with_block(function () {\n                    [output.indent(), body()];\n                });\n                output.end_statement();\n            };\n            if (!define_default_method.__argnames__) Object.defineProperties(define_default_method, {\n                __argnames__ : {value: ["name", "body"]}\n            });\n\n            function add_hidden_property(name, proceed) {\n                [output.indent(), output.print("Object.defineProperty(")];\n                [self.name.print(output), output.print(".prototype"), output.comma(), output.print(JSON.stringify(name)), \n                output.comma()];\n                [output.spaced("{value:", ""), proceed(), output.print("})"), output.end_statement()];\n            };\n            if (!add_hidden_property.__argnames__) Object.defineProperties(add_hidden_property, {\n                __argnames__ : {value: ["name", "proceed"]}\n            });\n\n            function write_constructor() {\n                output.print("function");\n                output.space();\n                self.name.print(output);\n                output.print("()");\n                output.space();\n                output.with_block(function () {\n                    output.indent();\n                    output.spaced("if", "(this.RS_object_id", "===", "undefined)", "Object.defineProperty(this,", "\\"RS_object_id\\",", "{\\"value\\":++RS_object_counter})");\n                    output.end_statement();\n                    if (self.bound.length) {\n                        output.indent();\n                        [self.name.print(output), output.print(".prototype.__bind_methods__.call(this)")];\n                        output.end_statement();\n                    }\n                    output.indent();\n                    self.name.print(output);\n                    [output.print(".prototype.__init__.apply(this"), output.comma(), output.print("arguments)")];\n                    output.end_statement();\n                });\n            };\n\n            if (self.decorators && self.decorators.length) {\n                output.print("var ");\n                output.assign(self.name);\n                decorate(self.decorators, output, write_constructor);\n                output.semicolon();\n            } else {\n                write_constructor();\n            }\n            output.newline();\n            if (self.parent) {\n                output.indent();\n                output.print("RS_extends");\n                output.with_parens(function () {\n                    self.name.print(output);\n                    output.comma();\n                    self.parent.print(output);\n                });\n                output.end_statement();\n            }\n            if (self.bound.length) {\n                seen_methods = Object.create(null);\n                add_hidden_property("__bind_methods__", function () {\n                    output.spaced("function", "()", "");\n                    output.with_block(function () {\n                        var base, bname;\n                        if (self.bases.length) {\n                            for (var i = self.bases.length - 1; i >= 0; i--) {\n                                base = (RS_expr_temp = self.bases)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n                                [output.indent(), base.print(output), output.spaced(".prototype.__bind_methods__", "&&", "")];\n                                [base.print(output), output.print(".prototype.__bind_methods__.call(this)")];\n                                output.end_statement();\n                            }\n                        }\n                        var RS_Iter102 = RS_Iterable(self.bound);\n                        for (var RS_Index102 = 0; RS_Index102 < RS_Iter102.length; RS_Index102++) {\n                            bname = RS_Iter102[RS_Index102];\n                            if (seen_methods[(typeof bname === "number" && bname < 0) ? seen_methods.length + bname : bname] || (RS_expr_temp = self.dynamic_properties)[(typeof bname === "number" && bname < 0) ? RS_expr_temp.length + bname : bname]) {\n                                continue;\n                            }\n                            seen_methods[(typeof bname === "number" && bname < 0) ? seen_methods.length + bname : bname] = true;\n                            [output.indent(), output.assign("this." + bname)];\n                            [self.name.print(output), output.print(".prototype." + bname + ".bind(this)")];\n                            output.end_statement();\n                        }\n                    });\n                });\n            }\n            property_names = Object.keys(self.dynamic_properties);\n            if (property_names.length) {\n                output.indent();\n                output.print("Object.defineProperties");\n                output.with_parens(function () {\n                    [self.name.print(output), output.print(".prototype"), output.comma(), output.space(), \n                    output.with_block(function () {\n                        var prop, name;\n                        var RS_Iter103 = RS_Iterable(property_names);\n                        for (var RS_Index103 = 0; RS_Index103 < RS_Iter103.length; RS_Index103++) {\n                            name = RS_Iter103[RS_Index103];\n                            prop = (RS_expr_temp = self.dynamic_properties)[(typeof name === "number" && name < 0) ? RS_expr_temp.length + name : name];\n                            [output.indent(), output.print(JSON.stringify(name) + ":"), output.space()];\n                            output.with_block(function () {\n                                [output.indent(), output.print("\\"enumerable\\":"), output.space(), output.print("true"), \n                                output.comma(), output.newline()];\n                                if (prop.getter) {\n                                    [output.indent(), output.print("\\"get\\":"), output.space()];\n                                    [define_method(prop.getter, true), output.comma(), output.newline()];\n                                }\n                                [output.indent(), output.print("\\"set\\":"), output.space()];\n                                if (prop.setter) {\n                                    [define_method(prop.setter, true), output.newline()];\n                                } else {\n                                    [output.spaced("function", "()", "{", "throw new AttributeError(\\"can\'t set attribute\\")", "}"), \n                                    output.newline()];\n                                }\n                            });\n                            [output.comma(), output.newline()];\n                        }\n                    })];\n                });\n                output.end_statement();\n            }\n            if (!self.init) {\n                define_default_method("__init__", function () {\n                    if (self.parent) {\n                        self.parent.print(output);\n                        output.spaced(".prototype.__init__", "&&");\n                        [output.space(), self.parent.print(output)];\n                        output.print(".prototype.__init__.apply");\n                        output.with_parens(function () {\n                            output.print("this");\n                            output.comma();\n                            output.print("arguments");\n                        });\n                        output.end_statement();\n                    }\n                });\n            }\n            defined_methods = Object.create(null);\n            var RS_Iter104 = RS_Iterable(self.body);\n            for (var RS_Index104 = 0; RS_Index104 < RS_Iter104.length; RS_Index104++) {\n                stmt = RS_Iter104[RS_Index104];\n                if (is_node_type(stmt, AST_Method)) {\n                    if (stmt.is_getter || stmt.is_setter) {\n                        continue;\n                    }\n                    define_method(stmt);\n                    defined_methods[RS_bound_index(stmt.name.name, defined_methods)] = true;\n                    sname = stmt.name.name;\n                    if (sname === "__init__") {\n                        var RS_Iter105 = RS_Iterable(RS_list_decorate([ ".__argnames__", ".__handles_kwarg_interpolation__" ]));\n                        for (var RS_Index105 = 0; RS_Index105 < RS_Iter105.length; RS_Index105++) {\n                            attr = RS_Iter105[RS_Index105];\n                            [output.indent(), self.name.print(output), output.assign(attr)];\n                            [self.name.print(output), output.print(".prototype.__init__" + attr), output.end_statement()];\n                        }\n                    }\n                    if (sname === "__iter__") {\n                        class_def("RS_iterator_symbol", true);\n                        self.name.print(output);\n                        output.print(".prototype." + stmt.name.name);\n                        output.end_statement();\n                    }\n                } else if (is_node_type(stmt, AST_Class)) {\n                    console.error("Nested classes aren\'t supported yet");\n                }\n            }\n            if (!defined_methods["__repr__"]) {\n                define_default_method("__repr__", function () {\n                    if (self.parent) {\n                        [output.print("if("), self.parent.print(output), output.spaced(".prototype.__repr__)", "return", self.parent)];\n                        [output.print(".prototype.__repr__.call(this)"), output.end_statement()];\n                    }\n                    [output.indent(), output.spaced("return", "\\"<\\"", "+", "__name__", "+", "\\".\\"", "+", "this.constructor.name", "")];\n                    output.spaced("+", "\\" #\\"", "+", "this.RS_object_id", "+", "\\">\\"");\n                    output.end_statement();\n                });\n            }\n            if (!defined_methods["__str__"]) {\n                define_default_method("__str__", function () {\n                    if (self.parent) {\n                        [output.print("if("), self.parent.print(output), output.spaced(".prototype.__str__)", "return", self.parent)];\n                        [output.print(".prototype.__str__.call(this)"), output.end_statement()];\n                    }\n                    output.spaced("return", "this.__repr__()");\n                    output.end_statement();\n                });\n            }\n            add_hidden_property("__bases__", function () {\n                output.print("[");\n                for (var i = 0; i < self.bases.length; i++) {\n                    (RS_expr_temp = self.bases)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].print(output);\n                    if (i < self.bases.length - 1) {\n                        output.comma();\n                    }\n                }\n                output.print("]");\n            });\n            if (self.bases.length > 1) {\n                output.indent();\n                output.print("RS_mixin(");\n                self.name.print(output);\n                for (var i = 1; i < self.bases.length; i++) {\n                    output.comma();\n                    (RS_expr_temp = self.bases)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].print(output);\n                }\n                [output.print(")"), output.end_statement()];\n            }\n            if (self.docstrings && self.docstrings.length && output.options.keep_docstrings) {\n                add_hidden_property("__doc__", function () {\n                    output.print(JSON.stringify(create_doctring(self.docstrings)));\n                });\n            }\n            var RS_Iter106 = RS_Iterable(self.statements);\n            for (var RS_Index106 = 0; RS_Index106 < RS_Iter106.length; RS_Index106++) {\n                stmt = RS_Iter106[RS_Index106];\n                if (!is_node_type(stmt, AST_Method)) {\n                    output.indent();\n                    stmt.print(output);\n                    output.newline();\n                }\n            }\n        };\n        if (!print_class.__argnames__) Object.defineProperties(print_class, {\n            __argnames__ : {value: ["output"]}\n        });\n\n        RS_modules["output.classes"].print_class = print_class;\n    })();\n\n    (function(){\n        var __name__ = "output.literals";\n        var AST_Binary = RS_modules.ast.AST_Binary;\n        var is_node_type = RS_modules.ast.is_node_type;\n\n        function print_array(self, output) {\n            output.print("RS_list_decorate");\n            output.with_parens(function () {\n                output.with_square(function () {\n                    var a, len_, RS_unpack, i, exp;\n                    a = self.elements;\n                    len_ = a.length;\n                    if (len_ > 0) {\n                        output.space();\n                    }\n                    var RS_Iter107 = RS_Iterable(enumerate(a));\n                    for (var RS_Index107 = 0; RS_Index107 < RS_Iter107.length; RS_Index107++) {\n                        RS_unpack = RS_Iter107[RS_Index107];\n                        i = RS_unpack[0];\n                        exp = RS_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        exp.print(output);\n                    }\n                    if (len_ > 0) {\n                        output.space();\n                    }\n                });\n            });\n        };\n        if (!print_array.__argnames__) Object.defineProperties(print_array, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_obj_literal(self, output) {\n            output.with_parens(function () {\n                output.print("function()");\n                output.with_block(function () {\n                    var RS_unpack, i, prop;\n                    output.indent();\n                    if (self.is_pydict) {\n                        output.spaced.apply(output, "var RS_d = RS_dict()".split(" "));\n                    } else {\n                        output.spaced("var", "RS_d", "=", (self.is_jshash) ? "Object.create(null)" : "{}");\n                    }\n                    output.end_statement();\n                    var RS_Iter108 = RS_Iterable(enumerate(self.properties));\n                    for (var RS_Index108 = 0; RS_Index108 < RS_Iter108.length; RS_Index108++) {\n                        RS_unpack = RS_Iter108[RS_Index108];\n                        i = RS_unpack[0];\n                        prop = RS_unpack[1];\n                        output.indent();\n                        if (self.is_pydict) {\n                            output.print("RS_d.set");\n                            output.with_parens(function () {\n                                prop.key.print(output);\n                                [output.print(","), output.space()];\n                                prop.value.print(output);\n                            });\n                        } else {\n                            output.print("RS_d");\n                            output.with_square(function () {\n                                prop.key.print(output);\n                            });\n                            [output.space(), output.print("="), output.space()];\n                            prop.value.print(output);\n                        }\n                        output.end_statement();\n                    }\n                    output.indent();\n                    output.spaced("return", "RS_d");\n                    output.end_statement();\n                });\n            });\n            output.print(".call(this)");\n        };\n        if (!print_obj_literal.__argnames__) Object.defineProperties(print_obj_literal, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_object(self, output) {\n            if (self.is_pydict) {\n                if (self.properties.length > 0) {\n                    print_obj_literal(self, output);\n                } else {\n                    output.print("RS_dict()");\n                }\n            } else {\n                if (self.properties.length > 0) {\n                    print_obj_literal(self, output);\n                } else {\n                    output.print((self.is_jshash) ? "Object.create(null)" : "{}");\n                }\n            }\n        };\n        if (!print_object.__argnames__) Object.defineProperties(print_object, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_set(self, output) {\n            if (self.items.length === 0) {\n                output.print("RS_set()");\n                return;\n            }\n            output.with_parens(function () {\n                output.print("function()");\n                output.with_block(function () {\n                    var item;\n                    output.indent();\n                    output.spaced.apply(output, "var s = RS_set()".split(" "));\n                    output.end_statement();\n                    var RS_Iter109 = RS_Iterable(self.items);\n                    for (var RS_Index109 = 0; RS_Index109 < RS_Iter109.length; RS_Index109++) {\n                        item = RS_Iter109[RS_Index109];\n                        output.indent();\n                        output.print("s.jsset.add");\n                        output.with_parens(function () {\n                            item.value.print(output);\n                        });\n                        output.end_statement();\n                    }\n                    output.indent();\n                    output.spaced("return", "s");\n                    output.end_statement();\n                });\n            });\n            output.print("()");\n        };\n        if (!print_set.__argnames__) Object.defineProperties(print_set, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_regexp(self, output) {\n            var str_, p;\n            str_ = self.value.toString();\n            if (output.options.ascii_only) {\n                str_ = output.to_ascii(str_);\n            }\n            output.print(str_);\n            p = output.parent();\n            if (is_node_type(p, AST_Binary) && /^in/.test(p.operator) && p.left === self) {\n                output.print(" ");\n            }\n        };\n        if (!print_regexp.__argnames__) Object.defineProperties(print_regexp, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        RS_modules["output.literals"].print_array = print_array;\n        RS_modules["output.literals"].print_obj_literal = print_obj_literal;\n        RS_modules["output.literals"].print_object = print_object;\n        RS_modules["output.literals"].print_set = print_set;\n        RS_modules["output.literals"].print_regexp = print_regexp;\n    })();\n\n    (function(){\n        var __name__ = "output.modules";\n        var COMPILER_VERSION = RS_modules.parse.COMPILER_VERSION;\n\n        var cache_file_name = RS_modules.utils.cache_file_name;\n\n        var declare_vars = RS_modules["output.statements"].declare_vars;\n        var display_body = RS_modules["output.statements"].display_body;\n\n        var OutputStream = RS_modules["output.stream"].OutputStream;\n\n        var create_doctring = RS_modules["output.utils"].create_doctring;\n\n        function write_imports(module, output) {\n            var imports, import_id, nonlocalvars, name, module_, module_id;\n            imports = RS_list_decorate([]);\n            var RS_Iter110 = RS_Iterable(Object.keys(module.imports));\n            for (var RS_Index110 = 0; RS_Index110 < RS_Iter110.length; RS_Index110++) {\n                import_id = RS_Iter110[RS_Index110];\n                imports.push((RS_expr_temp = module.imports)[(typeof import_id === "number" && import_id < 0) ? RS_expr_temp.length + import_id : import_id]);\n            }\n            imports.sort((function() {\n                var RS_anonfunc = function (a, b) {\n                    var RS_unpack;\n                    RS_unpack = [a.import_order, b.import_order];\n                    a = RS_unpack[0];\n                    b = RS_unpack[1];\n                    return (a < b) ? -1 : (a > b) ? 1 : 0;\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["a", "b"]}\n                });\n                return RS_anonfunc;\n            })());\n            if (imports.length > 1) {\n                output.indent();\n                output.print("var RS_modules = {};");\n                output.newline();\n            }\n            nonlocalvars = Object.create(null);\n            var RS_Iter111 = RS_Iterable(imports);\n            for (var RS_Index111 = 0; RS_Index111 < RS_Iter111.length; RS_Index111++) {\n                module_ = RS_Iter111[RS_Index111];\n                var RS_Iter112 = RS_Iterable(module_.nonlocalvars);\n                for (var RS_Index112 = 0; RS_Index112 < RS_Iter112.length; RS_Index112++) {\n                    name = RS_Iter112[RS_Index112];\n                    nonlocalvars[(typeof name === "number" && name < 0) ? nonlocalvars.length + name : name] = true;\n                }\n            }\n            nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(", ");\n            if (nonlocalvars.length) {\n                output.indent();\n                output.print("var " + nonlocalvars);\n                output.semicolon();\n                output.newline();\n            }\n            var RS_Iter113 = RS_Iterable(imports);\n            for (var RS_Index113 = 0; RS_Index113 < RS_Iter113.length; RS_Index113++) {\n                module_ = RS_Iter113[RS_Index113];\n                module_id = module_.module_id;\n                if (module_id !== "__main__") {\n                    output.indent();\n                    if (module_id.indexOf(".") === -1) {\n                        output.print("RS_modules." + module_id);\n                    } else {\n                        output.print("RS_modules[\\"" + module_id + "\\"]");\n                    }\n                    [output.space(), output.print("="), output.space(), output.print("{}")];\n                    output.end_statement();\n                }\n            }\n            var RS_Iter114 = RS_Iterable(imports);\n            for (var RS_Index114 = 0; RS_Index114 < RS_Iter114.length; RS_Index114++) {\n                module_ = RS_Iter114[RS_Index114];\n                if (module_.module_id !== "__main__") {\n                    print_module(module_, output);\n                }\n            }\n        };\n        if (!write_imports.__argnames__) Object.defineProperties(write_imports, {\n            __argnames__ : {value: ["module", "output"]}\n        });\n\n        function write_main_name(output) {\n            if (output.options.write_name) {\n                output.newline();\n                output.indent();\n                output.print("var __name__ = \\"__main__\\"");\n                output.semicolon();\n                output.newline();\n                output.newline();\n            }\n        };\n        if (!write_main_name.__argnames__) Object.defineProperties(write_main_name, {\n            __argnames__ : {value: ["output"]}\n        });\n\n        function const_decl(js_version) {\n            return "var";\n        };\n        if (!const_decl.__argnames__) Object.defineProperties(const_decl, {\n            __argnames__ : {value: ["js_version"]}\n        });\n\n        function declare_exports(module_id, exports, output, docstrings) {\n            var seen, v, symbol;\n            seen = Object.create(null);\n            if (output.options.keep_docstrings && docstrings && docstrings.length) {\n                exports.push((function(){\n                    var RS_d = Object.create(null);\n                    RS_d["name"] = "__doc__";\n                    RS_d["refname"] = "RS_module_doc__";\n                    return RS_d;\n                }).call(this));\n                [output.newline(), output.indent()];\n                v = const_decl(output.options.js_version);\n                [output.assign(v + " RS_module_doc__"), output.print(JSON.stringify(create_doctring(docstrings)))];\n                output.end_statement();\n            }\n            output.newline();\n            var RS_Iter115 = RS_Iterable(exports);\n            for (var RS_Index115 = 0; RS_Index115 < RS_Iter115.length; RS_Index115++) {\n                symbol = RS_Iter115[RS_Index115];\n                if (!Object.prototype.hasOwnProperty.call(seen, symbol.name)) {\n                    output.indent();\n                    if (module_id.indexOf(".") === -1) {\n                        output.print("RS_modules." + module_id + "." + symbol.name);\n                    } else {\n                        output.print("RS_modules[\\"" + module_id + "\\"]." + symbol.name);\n                    }\n                    [output.space(), output.print("="), output.space(), output.print(symbol.refname || symbol.name)];\n                    seen[RS_bound_index(symbol.name, seen)] = true;\n                    output.end_statement();\n                }\n            }\n        };\n        if (!declare_exports.__argnames__) Object.defineProperties(declare_exports, {\n            __argnames__ : {value: ["module_id", "exports", "output", "docstrings"]}\n        });\n\n        function prologue(module, output) {\n            var v, needs_yield;\n            if (output.options.omit_baselib) {\n                return;\n            }\n            output.indent();\n            v = const_decl(output.options.js_version);\n            [output.print(v), output.space()];\n            output.spaced.apply(output, "RS_iterator_symbol = (typeof Symbol === \\"function\\" && typeof Symbol.iterator === \\"symbol\\") ? Symbol.iterator : \\"iterator-Symbol-5d0927e5554349048cf0e3762a228256\\"".split(" "));\n            output.end_statement();\n            [output.indent(), output.print(v), output.space()];\n            output.spaced.apply(output, "RS_kwargs_symbol = (typeof Symbol === \\"function\\") ? Symbol(\\"kwargs-object\\") : \\"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\\"".split(" "));\n            output.end_statement();\n            [output.indent(), output.spaced("var", "RS_cond_temp,", "RS_expr_temp,", "RS_last_exception"), \n            output.end_statement()];\n            [output.indent(), output.spaced("var", "RS_object_counter", "=", "0"), output.end_statement()];\n            if (output.options.js_version > 5) {\n                [output.indent(), output.spaced("if(", "typeof", "HTMLCollection", "!==", "\\"undefined\\"", "&&", "typeof", "Symbol", "===", "\\"function\\")", "NodeList.prototype[Symbol.iterator]", "=", "HTMLCollection.prototype[Symbol.iterator]", "=", "NamedNodeMap.prototype[Symbol.iterator]", "=", "Array.prototype[Symbol.iterator]")];\n                output.end_statement();\n            }\n            needs_yield = output.options.js_version < 6 && module.baselib["yield"];\n            if (needs_yield) {\n                output.dump_yield();\n            }\n            if (!output.options.baselib_plain) {\n                throw new ValueError("The baselib is missing! Remember to set the baselib_plain field on the options for OutputStream");\n            }\n            output.print(output.options.baselib_plain);\n            output.end_statement();\n        };\n        if (!prologue.__argnames__) Object.defineProperties(prologue, {\n            __argnames__ : {value: ["module", "output"]}\n        });\n\n        function print_top_level(self, output) {\n            var is_main;\n            is_main = output.is_main();\n            function write_docstrings() {\n                var v;\n                if (is_main && output.options.keep_docstrings && self.docstrings && self.docstrings.length) {\n                    [output.newline(), output.indent()];\n                    v = const_decl(output.options.js_version);\n                    [output.assign(v + " RS_module_doc__"), output.print(JSON.stringify(create_doctring(self.docstrings)))];\n                    output.end_statement();\n                }\n            };\n\n            if (output.options.private_scope && is_main) {\n                output.with_parens(function () {\n                    output.print("function()");\n                    output.with_block(function () {\n                        output.indent();\n                        output.print("\\"use strict\\"");\n                        output.end_statement();\n                        prologue(self, output);\n                        write_imports(self, output);\n                        output.newline();\n                        output.indent();\n                        output.with_parens(function () {\n                            output.print("function()");\n                            output.with_block(function () {\n                                write_main_name(output);\n                                output.newline();\n                                declare_vars(self.localvars, output);\n                                display_body(self.body, true, output);\n                                output.newline();\n                                write_docstrings();\n                            });\n                        });\n                        output.print("();");\n                        output.newline();\n                    });\n                });\n                output.print("();");\n                output.print("");\n            } else {\n                if (is_main) {\n                    prologue(self, output);\n                    write_imports(self, output);\n                    write_main_name(output);\n                }\n                declare_vars(self.localvars, output);\n                display_body(self.body, true, output);\n            }\n        };\n        if (!print_top_level.__argnames__) Object.defineProperties(print_top_level, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_module(self, output) {\n            function output_module(output) {\n                declare_vars(self.localvars, output);\n                display_body(self.body, true, output);\n                declare_exports(self.module_id, self.exports, output, self.docstrings);\n            };\n            if (!output_module.__argnames__) Object.defineProperties(output_module, {\n                __argnames__ : {value: ["output"]}\n            });\n\n            output.newline();\n            output.indent();\n            output.with_parens(function () {\n                output.print("function()");\n                output.with_block(function () {\n                    var okey, cached, cobj, cname, symdef, co, raw, js_version, keep_docstrings, beautify;\n                    if (output.options.write_name) {\n                        output.indent();\n                        output.print("var ");\n                        output.assign("__name__");\n                        output.print("\\"" + self.module_id + "\\"");\n                        output.semicolon();\n                        output.newline();\n                    }\n                    function output_key(beautify, keep_docstrings, js_version) {\n                        return "beautify:" + beautify + " keep_docstrings:" + keep_docstrings + " js_version:" + js_version;\n                    };\n                    if (!output_key.__argnames__) Object.defineProperties(output_key, {\n                        __argnames__ : {value: ["beautify", "keep_docstrings", "js_version"]}\n                    });\n\n                    okey = output_key(output.options.beautify, output.options.keep_docstrings, output.options.js_version);\n                    if (self.is_cached && RS_in(okey, self.outputs)) {\n                        output.print((RS_expr_temp = self.outputs)[(typeof okey === "number" && okey < 0) ? RS_expr_temp.length + okey : okey]);\n                    } else {\n                        output_module(output);\n                        if (self.srchash && self.filename) {\n                            cached = (function(){\n                                var RS_d = Object.create(null);\n                                RS_d["version"] = COMPILER_VERSION;\n                                RS_d["signature"] = self.srchash;\n                                RS_d["classes"] = Object.create(null);\n                                RS_d["baselib"] = self.baselib;\n                                RS_d["nonlocalvars"] = self.nonlocalvars;\n                                RS_d["imported_module_ids"] = self.imported_module_ids;\n                                RS_d["exports"] = RS_list_decorate([]);\n                                RS_d["outputs"] = Object.create(null);\n                                RS_d["discard_asserts"] = output.options.discard_asserts;\n                                return RS_d;\n                            }).call(this);\n                            var RS_Iter116 = RS_Iterable(Object.keys(self.classes));\n                            for (var RS_Index116 = 0; RS_Index116 < RS_Iter116.length; RS_Index116++) {\n                                cname = RS_Iter116[RS_Index116];\n                                cobj = (RS_expr_temp = self.classes)[(typeof cname === "number" && cname < 0) ? RS_expr_temp.length + cname : cname];\n                                (RS_expr_temp = cached.classes)[(typeof cname === "number" && cname < 0) ? RS_expr_temp.length + cname : cname] = (function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["name"] = (function(){\n                                        var RS_d = Object.create(null);\n                                        RS_d["name"] = cobj.name.name;\n                                        return RS_d;\n                                    }).call(this);\n                                    RS_d["static"] = cobj.static;\n                                    RS_d["bound"] = cobj.bound;\n                                    RS_d["classvars"] = cobj.classvars;\n                                    return RS_d;\n                                }).call(this);\n                            }\n                            var RS_Iter117 = RS_Iterable(self.exports);\n                            for (var RS_Index117 = 0; RS_Index117 < RS_Iter117.length; RS_Index117++) {\n                                symdef = RS_Iter117[RS_Index117];\n                                cached.exports.push((function(){\n                                    var RS_d = Object.create(null);\n                                    RS_d["name"] = symdef.name;\n                                    return RS_d;\n                                }).call(this));\n                            }\n                            var RS_Iter118 = RS_Iterable(RS_list_decorate([ true, false ]));\n                            for (var RS_Index118 = 0; RS_Index118 < RS_Iter118.length; RS_Index118++) {\n                                beautify = RS_Iter118[RS_Index118];\n                                var RS_Iter119 = RS_Iterable(RS_list_decorate([ true, false ]));\n                                for (var RS_Index119 = 0; RS_Index119 < RS_Iter119.length; RS_Index119++) {\n                                    keep_docstrings = RS_Iter119[RS_Index119];\n                                    var RS_Iter120 = RS_Iterable(RS_list_decorate([ 5, 6 ]));\n                                    for (var RS_Index120 = 0; RS_Index120 < RS_Iter120.length; RS_Index120++) {\n                                        js_version = RS_Iter120[RS_Index120];\n                                        co = new OutputStream((function(){\n                                            var RS_d = Object.create(null);\n                                            RS_d["beautify"] = beautify;\n                                            RS_d["keep_docstrings"] = keep_docstrings;\n                                            RS_d["js_version"] = js_version;\n                                            RS_d["private_scope"] = false;\n                                            RS_d["write_name"] = false;\n                                            RS_d["discard_asserts"] = output.options.discard_asserts;\n                                            return RS_d;\n                                        }).call(this));\n                                        co.with_indent(output.indentation(), function () {\n                                            output_module(co);\n                                        });\n                                        raw = co.get();\n                                        (RS_expr_temp = cached.outputs)[RS_bound_index(output_key(beautify, keep_docstrings, js_version), RS_expr_temp)] = raw;\n                                    }\n                                }\n                            }\n                            try {\n                                writefile(cache_file_name(self.filename, output.options.module_cache_dir), JSON.stringify(cached, null, "\\t"));\n                            } catch (RS_Exception) {\n                                RS_last_exception = RS_Exception;\n                                if (RS_Exception instanceof Error) {\n                                    var e = RS_Exception;\n                                    console.error("Failed to write output cache file:", self.filename + "-cached", "with error:", e);\n                                } else {\n                                    throw RS_Exception;\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n            output.print("()");\n            output.semicolon();\n            output.newline();\n        };\n        if (!print_module.__argnames__) Object.defineProperties(print_module, {\n            __argnames__ : {value: ["self", "output"]}\n        });\n\n        function print_imports(container, output) {\n            var is_first_aname, akey, argname, parts, q, RS_unpack, i, part, self;\n            is_first_aname = true;\n            function add_aname(aname, key, from_import) {\n                if (is_first_aname) {\n                    is_first_aname = false;\n                } else {\n                    output.indent();\n                }\n                output.print("var ");\n                output.assign(aname);\n                if (key.indexOf(".") === -1) {\n                    [output.print("RS_modules."), output.print(key)];\n                } else {\n                    [output.print("RS_modules[\\""), output.print(key), output.print("\\"]")];\n                }\n                if (from_import) {\n                    output.print(".");\n                    output.print(from_import);\n                }\n                output.end_statement();\n            };\n            if (!add_aname.__argnames__) Object.defineProperties(add_aname, {\n                __argnames__ : {value: ["aname", "key", "from_import"]}\n            });\n\n            var RS_Iter121 = RS_Iterable(container.imports);\n            for (var RS_Index121 = 0; RS_Index121 < RS_Iter121.length; RS_Index121++) {\n                self = RS_Iter121[RS_Index121];\n                output.import_(self.module);\n                if (self.argnames) {\n                    var RS_Iter122 = RS_Iterable(self.argnames);\n                    for (var RS_Index122 = 0; RS_Index122 < RS_Iter122.length; RS_Index122++) {\n                        argname = RS_Iter122[RS_Index122];\n                        akey = (argname.alias) ? argname.alias.name : argname.name;\n                        add_aname(akey, self.key, argname.name);\n                    }\n                } else {\n                    if (self.alias) {\n                        add_aname(self.alias.name, self.key, false);\n                    } else {\n                        parts = self.key.split(".");\n                        var RS_Iter123 = RS_Iterable(enumerate(parts));\n                        for (var RS_Index123 = 0; RS_Index123 < RS_Iter123.length; RS_Index123++) {\n                            RS_unpack = RS_Iter123[RS_Index123];\n                            i = RS_unpack[0];\n                            part = RS_unpack[1];\n                            if (i === 0) {\n                                add_aname(part, part, false);\n                            } else {\n                                q = parts.slice(0, i + 1).join(".");\n                                output.indent();\n                                output.spaced(q, "=", "RS_modules[\\"" + q + "\\"]");\n                                output.end_statement();\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        if (!print_imports.__argnames__) Object.defineProperties(print_imports, {\n            __argnames__ : {value: ["container", "output"]}\n        });\n\n        RS_modules["output.modules"].write_imports = write_imports;\n        RS_modules["output.modules"].write_main_name = write_main_name;\n        RS_modules["output.modules"].const_decl = const_decl;\n        RS_modules["output.modules"].declare_exports = declare_exports;\n        RS_modules["output.modules"].prologue = prologue;\n        RS_modules["output.modules"].print_top_level = print_top_level;\n        RS_modules["output.modules"].print_module = print_module;\n        RS_modules["output.modules"].print_imports = print_imports;\n    })();\n\n    (function(){\n        var __name__ = "output.codegen";\n        var noop = RS_modules.utils.noop;\n\n        var PRECEDENCE = RS_modules.parse.PRECEDENCE;\n\n        var AST_Array = RS_modules.ast.AST_Array;\n        var AST_Assign = RS_modules.ast.AST_Assign;\n        var AST_BaseCall = RS_modules.ast.AST_BaseCall;\n        var AST_Binary = RS_modules.ast.AST_Binary;\n        var AST_BlockStatement = RS_modules.ast.AST_BlockStatement;\n        var AST_Break = RS_modules.ast.AST_Break;\n        var AST_Catch = RS_modules.ast.AST_Catch;\n        var AST_Class = RS_modules.ast.AST_Class;\n        var AST_Conditional = RS_modules.ast.AST_Conditional;\n        var AST_Constant = RS_modules.ast.AST_Constant;\n        var AST_Continue = RS_modules.ast.AST_Continue;\n        var AST_Debugger = RS_modules.ast.AST_Debugger;\n        var AST_Definitions = RS_modules.ast.AST_Definitions;\n        var AST_Directive = RS_modules.ast.AST_Directive;\n        var AST_Do = RS_modules.ast.AST_Do;\n        var AST_Dot = RS_modules.ast.AST_Dot;\n        var is_node_type = RS_modules.ast.is_node_type;\n        var AST_EmptyStatement = RS_modules.ast.AST_EmptyStatement;\n        var AST_Exit = RS_modules.ast.AST_Exit;\n        var AST_ExpressiveObject = RS_modules.ast.AST_ExpressiveObject;\n        var AST_Finally = RS_modules.ast.AST_Finally;\n        var AST_ForIn = RS_modules.ast.AST_ForIn;\n        var AST_ForJS = RS_modules.ast.AST_ForJS;\n        var AST_Function = RS_modules.ast.AST_Function;\n        var AST_Hole = RS_modules.ast.AST_Hole;\n        var AST_If = RS_modules.ast.AST_If;\n        var AST_Imports = RS_modules.ast.AST_Imports;\n        var AST_Infinity = RS_modules.ast.AST_Infinity;\n        var AST_Lambda = RS_modules.ast.AST_Lambda;\n        var AST_ListComprehension = RS_modules.ast.AST_ListComprehension;\n        var AST_LoopControl = RS_modules.ast.AST_LoopControl;\n        var AST_NaN = RS_modules.ast.AST_NaN;\n        var AST_New = RS_modules.ast.AST_New;\n        var AST_Node = RS_modules.ast.AST_Node;\n        var AST_Number = RS_modules.ast.AST_Number;\n        var AST_Object = RS_modules.ast.AST_Object;\n        var AST_ObjectKeyVal = RS_modules.ast.AST_ObjectKeyVal;\n        var AST_ObjectProperty = RS_modules.ast.AST_ObjectProperty;\n        var AST_PropAccess = RS_modules.ast.AST_PropAccess;\n        var AST_RegExp = RS_modules.ast.AST_RegExp;\n        var AST_Return = RS_modules.ast.AST_Return;\n        var AST_Set = RS_modules.ast.AST_Set;\n        var AST_Seq = RS_modules.ast.AST_Seq;\n        var AST_SimpleStatement = RS_modules.ast.AST_SimpleStatement;\n        var AST_Splice = RS_modules.ast.AST_Splice;\n        var AST_Statement = RS_modules.ast.AST_Statement;\n        var AST_StatementWithBody = RS_modules.ast.AST_StatementWithBody;\n        var AST_String = RS_modules.ast.AST_String;\n        var AST_Sub = RS_modules.ast.AST_Sub;\n        var AST_ItemAccess = RS_modules.ast.AST_ItemAccess;\n        var AST_Symbol = RS_modules.ast.AST_Symbol;\n        var AST_This = RS_modules.ast.AST_This;\n        var AST_Throw = RS_modules.ast.AST_Throw;\n        var AST_Toplevel = RS_modules.ast.AST_Toplevel;\n        var AST_Try = RS_modules.ast.AST_Try;\n        var AST_Unary = RS_modules.ast.AST_Unary;\n        var AST_UnaryPrefix = RS_modules.ast.AST_UnaryPrefix;\n        var AST_Undefined = RS_modules.ast.AST_Undefined;\n        var AST_Var = RS_modules.ast.AST_Var;\n        var AST_VarDef = RS_modules.ast.AST_VarDef;\n        var AST_Assert = RS_modules.ast.AST_Assert;\n        var AST_Verbatim = RS_modules.ast.AST_Verbatim;\n        var AST_While = RS_modules.ast.AST_While;\n        var AST_With = RS_modules.ast.AST_With;\n        var AST_Yield = RS_modules.ast.AST_Yield;\n        var TreeWalker = RS_modules.ast.TreeWalker;\n        var AST_Existential = RS_modules.ast.AST_Existential;\n\n        var print_try = RS_modules["output.exceptions"].print_try;\n\n        var print_class = RS_modules["output.classes"].print_class;\n\n        var print_array = RS_modules["output.literals"].print_array;\n        var print_obj_literal = RS_modules["output.literals"].print_obj_literal;\n        var print_object = RS_modules["output.literals"].print_object;\n        var print_set = RS_modules["output.literals"].print_set;\n        var print_regexp = RS_modules["output.literals"].print_regexp;\n\n        var print_do_loop = RS_modules["output.loops"].print_do_loop;\n        var print_while_loop = RS_modules["output.loops"].print_while_loop;\n        var print_for_loop_body = RS_modules["output.loops"].print_for_loop_body;\n        var print_for_in = RS_modules["output.loops"].print_for_in;\n        var print_list_comprehension = RS_modules["output.loops"].print_list_comprehension;\n\n        var print_top_level = RS_modules["output.modules"].print_top_level;\n        var print_imports = RS_modules["output.modules"].print_imports;\n\n        var print_getattr = RS_modules["output.operators"].print_getattr;\n        var print_getitem = RS_modules["output.operators"].print_getitem;\n        var print_rich_getitem = RS_modules["output.operators"].print_rich_getitem;\n        var print_splice_assignment = RS_modules["output.operators"].print_splice_assignment;\n        var print_unary_prefix = RS_modules["output.operators"].print_unary_prefix;\n        var print_binary_op = RS_modules["output.operators"].print_binary_op;\n        var print_assign = RS_modules["output.operators"].print_assign;\n        var print_conditional = RS_modules["output.operators"].print_conditional;\n        var print_seq = RS_modules["output.operators"].print_seq;\n        var print_existential = RS_modules["output.operators"].print_existential;\n\n        var print_function = RS_modules["output.functions"].print_function;\n        var print_function_call = RS_modules["output.functions"].print_function_call;\n\n        var print_bracketed = RS_modules["output.statements"].print_bracketed;\n        var first_in_statement = RS_modules["output.statements"].first_in_statement;\n        var force_statement = RS_modules["output.statements"].force_statement;\n        var print_with = RS_modules["output.statements"].print_with;\n        var print_assert = RS_modules["output.statements"].print_assert;\n\n        var make_block = RS_modules["output.utils"].make_block;\n        var make_num = RS_modules["output.utils"].make_num;\n\n        function generate_code() {\n            function DEFPRINT(nodetype, generator) {\n                nodetype.prototype._codegen = generator;\n            };\n            if (!DEFPRINT.__argnames__) Object.defineProperties(DEFPRINT, {\n                __argnames__ : {value: ["nodetype", "generator"]}\n            });\n\n            AST_Node.prototype.print = (function() {\n                var RS_anonfunc = function (stream, force_parens) {\n                    var self, generator;\n                    self = this;\n                    generator = self._codegen;\n                    stream.push_node(self);\n                    if (force_parens || self.needs_parens(stream)) {\n                        stream.with_parens(function () {\n                            self.add_comments(stream);\n                            generator(self, stream);\n                        });\n                    } else {\n                        self.add_comments(stream);\n                        generator(self, stream);\n                    }\n                    stream.pop_node();\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["stream", "force_parens"]}\n                });\n                return RS_anonfunc;\n            })();\n            AST_Node.prototype.add_comments = (function() {\n                var RS_anonfunc = function (output) {\n                    var c, self, start, comments, comm;\n                    c = output.options.comments;\n                    self = this;\n                    if (c) {\n                        start = self.start;\n                        if (start && !start._comments_dumped) {\n                            start._comments_dumped = true;\n                            comments = start.comments_before;\n                            if (is_node_type(self, AST_Exit) && self.value && self.value.start.comments_before && self.value.start.comments_before.length > 0) {\n                                comments = (comments || RS_list_decorate([])).concat(self.value.start.comments_before);\n                                self.value.start.comments_before = RS_list_decorate([]);\n                            }\n                            if (c.test) {\n                                comments = comments.filter((function() {\n                                    var RS_anonfunc = function (comment) {\n                                        return c.test(comment.value);\n                                    };\n                                    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                                        __argnames__ : {value: ["comment"]}\n                                    });\n                                    return RS_anonfunc;\n                                })());\n                            } else if (typeof c === "function") {\n                                comments = comments.filter((function() {\n                                    var RS_anonfunc = function (comment) {\n                                        return c(self, comment);\n                                    };\n                                    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                                        __argnames__ : {value: ["comment"]}\n                                    });\n                                    return RS_anonfunc;\n                                })());\n                            }\n                            var RS_Iter124 = RS_Iterable(comments);\n                            for (var RS_Index124 = 0; RS_Index124 < RS_Iter124.length; RS_Index124++) {\n                                comm = RS_Iter124[RS_Index124];\n                                if (comm.type === "comment1") {\n                                    output.print("//" + comm.value + "\\n");\n                                    output.indent();\n                                } else if (comm.type === "comment2") {\n                                    output.print("/*" + comm.value + "*/");\n                                    if (start.nlb) {\n                                        output.print("\\n");\n                                        output.indent();\n                                    } else {\n                                        output.space();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })();\n            function PARENS(nodetype, func) {\n                nodetype.prototype.needs_parens = func;\n            };\n            if (!PARENS.__argnames__) Object.defineProperties(PARENS, {\n                __argnames__ : {value: ["nodetype", "func"]}\n            });\n\n            PARENS(AST_Node, function () {\n                return false;\n            });\n            PARENS(AST_Function, (function() {\n                var RS_anonfunc = function (output) {\n                    return first_in_statement(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_Object, (function() {\n                var RS_anonfunc = function (output) {\n                    return first_in_statement(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_Unary, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return is_node_type(p, AST_PropAccess) && p.expression === this;\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_Seq, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return is_node_type(p, AST_Unary) || is_node_type(p, AST_VarDef) || is_node_type(p, AST_Dot) || is_node_type(p, AST_ObjectProperty) || is_node_type(p, AST_Conditional);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_Binary, (function() {\n                var RS_anonfunc = function (output) {\n                    var p, po, pp, so, sp;\n                    p = output.parent();\n                    if (is_node_type(p, AST_BaseCall) && p.expression === this) {\n                        return true;\n                    }\n                    if (is_node_type(p, AST_Unary)) {\n                        return true;\n                    }\n                    if (is_node_type(p, AST_PropAccess) && p.expression === this) {\n                        return true;\n                    }\n                    if (is_node_type(p, AST_Binary)) {\n                        po = p.operator;\n                        pp = PRECEDENCE[(typeof po === "number" && po < 0) ? PRECEDENCE.length + po : po];\n                        so = this.operator;\n                        sp = PRECEDENCE[(typeof so === "number" && so < 0) ? PRECEDENCE.length + so : so];\n                        if (pp > sp || pp === sp && this === p.right && !(so === po && (so === "*" || so === "&&" || so === "||"))) {\n                            return true;\n                        }\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_PropAccess, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (is_node_type(p, AST_New) && p.expression === this) {\n                        try {\n                            this.walk(new TreeWalker((function() {\n                                var RS_anonfunc = function (node) {\n                                    if (is_node_type(node, AST_BaseCall)) {\n                                        throw p;\n                                    }\n                                };\n                                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                                    __argnames__ : {value: ["node"]}\n                                });\n                                return RS_anonfunc;\n                            })()));\n                        } catch (RS_Exception) {\n                            RS_last_exception = RS_Exception;\n                            {\n                                var ex = RS_Exception;\n                                if (ex !== p) {\n                                    throw ex;\n                                }\n                                return true;\n                            } \n                        }\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_BaseCall, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return is_node_type(p, AST_New) && p.expression === this;\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_New, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (this.args.length === 0 && (is_node_type(p, AST_PropAccess) || is_node_type(p, AST_BaseCall) && p.expression === this)) {\n                        return true;\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_Number, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (this.value < 0 && is_node_type(p, AST_PropAccess) && p.expression === this) {\n                        return true;\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            PARENS(AST_NaN, (function() {\n                var RS_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (is_node_type(p, AST_PropAccess) && p.expression === this) {\n                        return true;\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })());\n            function assign_and_conditional_paren_rules(output) {\n                var p;\n                p = output.parent();\n                if (is_node_type(p, AST_Unary)) {\n                    return true;\n                }\n                if (is_node_type(p, AST_Binary) && !is_node_type(p, AST_Assign)) {\n                    return true;\n                }\n                if (is_node_type(p, AST_BaseCall) && p.expression === this) {\n                    return true;\n                }\n                if (is_node_type(p, AST_Conditional) && p.condition === this) {\n                    return true;\n                }\n                if (is_node_type(p, AST_PropAccess) && p.expression === this) {\n                    return true;\n                }\n            };\n            if (!assign_and_conditional_paren_rules.__argnames__) Object.defineProperties(assign_and_conditional_paren_rules, {\n                __argnames__ : {value: ["output"]}\n            });\n\n            PARENS(AST_Assign, assign_and_conditional_paren_rules);\n            PARENS(AST_Conditional, assign_and_conditional_paren_rules);\n            DEFPRINT(AST_Directive, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print_string(self.value);\n                    output.semicolon();\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Debugger, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("debugger");\n                    output.semicolon();\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            AST_StatementWithBody.prototype._do_print_body = (function() {\n                var RS_anonfunc = function (output) {\n                    force_statement(this.body, output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })();\n            DEFPRINT(AST_Statement, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self.body.print(output);\n                    output.semicolon();\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Toplevel, print_top_level);\n            DEFPRINT(AST_Imports, print_imports);\n            DEFPRINT(AST_SimpleStatement, (function() {\n                var RS_anonfunc = function (self, output) {\n                    if (!is_node_type(self.body, AST_EmptyStatement)) {\n                        self.body.print(output);\n                        output.semicolon();\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_BlockStatement, (function() {\n                var RS_anonfunc = function (self, output) {\n                    print_bracketed(self, output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_EmptyStatement, (function() {\n                var RS_anonfunc = function (self, output) {\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Do, print_do_loop);\n            DEFPRINT(AST_While, print_while_loop);\n            AST_ForIn.prototype._do_print_body = print_for_loop_body;\n            DEFPRINT(AST_ForIn, print_for_in);\n            AST_ForJS.prototype._do_print_body = (function() {\n                var RS_anonfunc = function (output) {\n                    var self;\n                    self = this;\n                    output.with_block(function () {\n                        var stmt;\n                        var RS_Iter125 = RS_Iterable(self.body.body);\n                        for (var RS_Index125 = 0; RS_Index125 < RS_Iter125.length; RS_Index125++) {\n                            stmt = RS_Iter125[RS_Index125];\n                            output.indent();\n                            stmt.print(output);\n                            output.newline();\n                        }\n                    });\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output"]}\n                });\n                return RS_anonfunc;\n            })();\n            DEFPRINT(AST_ForJS, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("for");\n                    output.space();\n                    output.with_parens(function () {\n                        self.condition.print(output);\n                    });\n                    output.space();\n                    self._do_print_body(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_ListComprehension, print_list_comprehension);\n            DEFPRINT(AST_With, print_with);\n            DEFPRINT(AST_Assert, print_assert);\n            AST_Lambda.prototype._do_print = print_function;\n            DEFPRINT(AST_Lambda, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            AST_Class.prototype._do_print = print_class;\n            DEFPRINT(AST_Class, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            AST_Exit.prototype._do_print = (function() {\n                var RS_anonfunc = function (output, kind) {\n                    var self;\n                    self = this;\n                    output.print(kind);\n                    if (self.value) {\n                        output.space();\n                        self.value.print(output);\n                    }\n                    output.semicolon();\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output", "kind"]}\n                });\n                return RS_anonfunc;\n            })();\n            DEFPRINT(AST_Yield, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output, "yield" + ((self.is_yield_from) ? "*" : ""));\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Return, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output, "return");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Throw, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output, "throw");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            AST_LoopControl.prototype._do_print = (function() {\n                var RS_anonfunc = function (output, kind) {\n                    output.print(kind);\n                    if (this.label) {\n                        output.space();\n                        this.label.print(output);\n                    }\n                    output.semicolon();\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output", "kind"]}\n                });\n                return RS_anonfunc;\n            })();\n            DEFPRINT(AST_Break, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output, "break");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Continue, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output, "continue");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            function make_then(self, output) {\n                var b;\n                if (output.options.bracketize) {\n                    make_block(self.body, output);\n                    return;\n                }\n                if (!self.body) {\n                    return output.force_semicolon();\n                }\n                if (is_node_type(self.body, AST_Do) && output.options.ie_proof) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = self.body;\n                while (true) {\n                    if (is_node_type(b, AST_If)) {\n                        if (!b.alternative) {\n                            make_block(self.body, output);\n                            return;\n                        }\n                        b = b.alternative;\n                    } else if (is_node_type(b, AST_StatementWithBody)) {\n                        b = b.body;\n                    } else {\n                        break;\n                    }\n                }\n                force_statement(self.body, output);\n            };\n            if (!make_then.__argnames__) Object.defineProperties(make_then, {\n                __argnames__ : {value: ["self", "output"]}\n            });\n\n            DEFPRINT(AST_If, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("if");\n                    output.space();\n                    output.with_parens(function () {\n                        self.condition.print(output);\n                    });\n                    output.space();\n                    if (self.alternative) {\n                        make_then(self, output);\n                        output.space();\n                        output.print("else");\n                        output.space();\n                        force_statement(self.alternative, output);\n                    } else {\n                        self._do_print_body(output);\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Try, print_try);\n            AST_Definitions.prototype._do_print = (function() {\n                var RS_anonfunc = function (output, kind) {\n                    var RS_unpack, i, def_, p, in_for, avoid_semicolon;\n                    output.print(kind);\n                    output.space();\n                    var RS_Iter126 = RS_Iterable(enumerate(this.definitions));\n                    for (var RS_Index126 = 0; RS_Index126 < RS_Iter126.length; RS_Index126++) {\n                        RS_unpack = RS_Iter126[RS_Index126];\n                        i = RS_unpack[0];\n                        def_ = RS_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        def_.print(output);\n                    }\n                    p = output.parent();\n                    in_for = is_node_type(p, AST_ForIn);\n                    avoid_semicolon = in_for && p.init === this;\n                    if (!avoid_semicolon) {\n                        output.semicolon();\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["output", "kind"]}\n                });\n                return RS_anonfunc;\n            })();\n            DEFPRINT(AST_Var, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output, "var");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            function parenthesize_for_noin(node, output, noin) {\n                if (!noin) {\n                    node.print(output);\n                } else {\n                    try {\n                        node.walk(new TreeWalker((function() {\n                            var RS_anonfunc = function (node) {\n                                if (is_node_type(node, AST_Binary) && node.operator === "in") {\n                                    throw output;\n                                }\n                            };\n                            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                                __argnames__ : {value: ["node"]}\n                            });\n                            return RS_anonfunc;\n                        })()));\n                        node.print(output);\n                    } catch (RS_Exception) {\n                        RS_last_exception = RS_Exception;\n                        {\n                            var ex = RS_Exception;\n                            if (ex !== output) {\n                                throw ex;\n                            }\n                            node.print(output, true);\n                        } \n                    }\n                }\n            };\n            if (!parenthesize_for_noin.__argnames__) Object.defineProperties(parenthesize_for_noin, {\n                __argnames__ : {value: ["node", "output", "noin"]}\n            });\n\n            DEFPRINT(AST_VarDef, (function() {\n                var RS_anonfunc = function (self, output) {\n                    var p, noin;\n                    self.name.print(output);\n                    if (self.value) {\n                        output.assign("");\n                        p = output.parent(1);\n                        noin = is_node_type(p, AST_ForIn);\n                        parenthesize_for_noin(self.value, output, noin);\n                    }\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_BaseCall, print_function_call);\n            AST_Seq.prototype._do_print = print_seq;\n            DEFPRINT(AST_Seq, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Dot, print_getattr);\n            DEFPRINT(AST_Sub, print_getitem);\n            DEFPRINT(AST_ItemAccess, print_rich_getitem);\n            DEFPRINT(AST_Splice, print_splice_assignment);\n            DEFPRINT(AST_UnaryPrefix, print_unary_prefix);\n            DEFPRINT(AST_Binary, print_binary_op);\n            DEFPRINT(AST_Existential, print_existential);\n            DEFPRINT(AST_Assign, print_assign);\n            DEFPRINT(AST_Conditional, print_conditional);\n            DEFPRINT(AST_Array, print_array);\n            DEFPRINT(AST_ExpressiveObject, print_obj_literal);\n            DEFPRINT(AST_Object, print_object);\n            DEFPRINT(AST_ObjectKeyVal, (function() {\n                var RS_anonfunc = function (self, output) {\n                    self.key.print(output);\n                    output.colon();\n                    self.value.print(output);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Set, print_set);\n            AST_Symbol.prototype.definition = function () {\n                return this.thedef;\n            };\n            DEFPRINT(AST_Symbol, (function() {\n                var RS_anonfunc = function (self, output) {\n                    var def_;\n                    def_ = self.definition();\n                    output.print_name((def_) ? def_.mangled_name || def_.name : self.name);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Undefined, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("void 0");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Hole, noop);\n            DEFPRINT(AST_Infinity, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("1/0");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_NaN, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("0/0");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_This, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print("this");\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Constant, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print(self.value);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_String, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print_string(self.value);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Verbatim, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print(self.value);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_Number, (function() {\n                var RS_anonfunc = function (self, output) {\n                    output.print(make_num(self.value));\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["self", "output"]}\n                });\n                return RS_anonfunc;\n            })());\n            DEFPRINT(AST_RegExp, print_regexp);\n        };\n\n        RS_modules["output.codegen"].generate_code = generate_code;\n    })();\n\n    (function(){\n\n        var __name__ = "__main__";\n\n\n        var ast, ast_node;\n        var DefaultsError = RS_modules.utils.DefaultsError;\n        var string_template = RS_modules.utils.string_template;\n\n        var ImportError = RS_modules.errors.ImportError;\n        var SyntaxError = RS_modules.errors.SyntaxError;\n\n        var ALL_KEYWORDS = RS_modules.tokenizer.ALL_KEYWORDS;\n        var IDENTIFIER_PAT = RS_modules.tokenizer.IDENTIFIER_PAT;\n        var tokenizer = RS_modules.tokenizer.tokenizer;\n\n        var parse = RS_modules.parse.parse;\n        var NATIVE_CLASSES = RS_modules.parse.NATIVE_CLASSES;\n        var compile_time_decorators = RS_modules.parse.compile_time_decorators;\n\n        var OutputStream = RS_modules["output.stream"].OutputStream;\n\n        var generate_code = RS_modules["output.codegen"].generate_code;\n\n        generate_code();\n        if (typeof exports === "object") {\n            exports.DefaultsError = DefaultsError;\n            exports.parse = parse;\n            exports.compile_time_decorators = compile_time_decorators;\n            exports.OutputStream = OutputStream;\n            exports.string_template = string_template;\n            exports.ALL_KEYWORDS = ALL_KEYWORDS;\n            exports.IDENTIFIER_PAT = IDENTIFIER_PAT;\n            exports.NATIVE_CLASSES = NATIVE_CLASSES;\n            exports.ImportError = ImportError;\n            exports.SyntaxError = SyntaxError;\n            exports.tokenizer = tokenizer;\n            ast = RS_modules["ast"];\n            var RS_Iter127 = RS_Iterable(ast);\n            for (var RS_Index127 = 0; RS_Index127 < RS_Iter127.length; RS_Index127++) {\n                ast_node = RS_Iter127[RS_Index127];\n                if (ast_node.substr(0, 4) === "AST_") {\n                    exports[(typeof ast_node === "number" && ast_node < 0) ? exports.length + ast_node : ast_node] = ast[(typeof ast_node === "number" && ast_node < 0) ? ast.length + ast_node : ast_node];\n                }\n            }\n        }\n    })();\n})();',"baselib-plain-pretty.js":'var RS_len;\nfunction RS_bool(val) {\n    return !!val;\n};\nif (!RS_bool.__argnames__) Object.defineProperties(RS_bool, {\n    __argnames__ : {value: ["val"]}\n});\n\nfunction RS_print() {\n    var parts;\n    if (typeof console === "object") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(RS_str(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]));\n        }\n        console.log(parts.join(" "));\n    }\n};\n\nfunction RS_int(val, base) {\n    var ans;\n    if (typeof val === "number") {\n        ans = val | 0;\n    } else {\n        ans = parseInt(val, base || 10);\n    }\n    if (isNaN(ans)) {\n        throw new ValueError("Invalid literal for int with base " + (base || 10) + ": " + val);\n    }\n    return ans;\n};\nif (!RS_int.__argnames__) Object.defineProperties(RS_int, {\n    __argnames__ : {value: ["val", "base"]}\n});\n\nfunction RS_float(val) {\n    var ans;\n    if (typeof val === "number") {\n        ans = val;\n    } else {\n        ans = parseFloat(val);\n    }\n    if (isNaN(ans)) {\n        throw new ValueError("Could not convert string to float: " + arguments[0]);\n    }\n    return ans;\n};\nif (!RS_float.__argnames__) Object.defineProperties(RS_float, {\n    __argnames__ : {value: ["val"]}\n});\n\nfunction RS_arraylike_creator() {\n    var names;\n    names = "Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" ");\n    if (typeof HTMLCollection === "function") {\n        names = names.concat("HTMLCollection NodeList NamedNodeMap TouchList".split(" "));\n    }\n    return (function() {\n        var RS_anonfunc = function (x) {\n            if (Array.isArray(x) || typeof x === "string" || names.indexOf(Object.prototype.toString.call(x).slice(8, -1)) > -1) {\n                return true;\n            }\n            return false;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["x"]}\n        });\n        return RS_anonfunc;\n    })();\n};\n\nfunction options_object(f) {\n    return function () {\n        if (typeof arguments[arguments.length - 1] === "object") {\n            arguments[RS_bound_index(arguments.length - 1, arguments)][RS_kwargs_symbol] = true;\n        }\n        return f.apply(this, arguments);\n    };\n};\nif (!options_object.__argnames__) Object.defineProperties(options_object, {\n    __argnames__ : {value: ["f"]}\n});\n\nfunction RS_id(x) {\n    return x.RS_object_id;\n};\nif (!RS_id.__argnames__) Object.defineProperties(RS_id, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_dir(item) {\n    var arr;\n    arr = RS_list_decorate([]);\n    for (var i in item) {\n        arr.push(i);\n    }\n    return arr;\n};\nif (!RS_dir.__argnames__) Object.defineProperties(RS_dir, {\n    __argnames__ : {value: ["item"]}\n});\n\nfunction RS_ord(x) {\n    var ans, second;\n    ans = x.charCodeAt(0);\n    if (55296 <= ans && ans <= 56319) {\n        second = x.charCodeAt(1);\n        if (56320 <= second && second <= 57343) {\n            return (ans - 55296) * 1024 + second - 56320 + 65536;\n        }\n        throw new TypeError("string is missing the low surrogate char");\n    }\n    return ans;\n};\nif (!RS_ord.__argnames__) Object.defineProperties(RS_ord, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_chr(code) {\n    if (code <= 65535) {\n        return String.fromCharCode(code);\n    }\n    code -= 65536;\n    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n};\nif (!RS_chr.__argnames__) Object.defineProperties(RS_chr, {\n    __argnames__ : {value: ["code"]}\n});\n\nfunction RS_callable(x) {\n    return typeof x === "function";\n};\nif (!RS_callable.__argnames__) Object.defineProperties(RS_callable, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_bin(x) {\n    var ans;\n    if (typeof x !== "number" || x % 1 !== 0) {\n        throw new TypeError("integer required");\n    }\n    ans = x.toString(2);\n    if (ans[0] === "-") {\n        ans = "-" + "0b" + ans.slice(1);\n    } else {\n        ans = "0b" + ans;\n    }\n    return ans;\n};\nif (!RS_bin.__argnames__) Object.defineProperties(RS_bin, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_hex(x) {\n    var ans;\n    if (typeof x !== "number" || x % 1 !== 0) {\n        throw new TypeError("integer required");\n    }\n    ans = x.toString(16);\n    if (ans[0] === "-") {\n        ans = "-" + "0x" + ans.slice(1);\n    } else {\n        ans = "0x" + ans;\n    }\n    return ans;\n};\nif (!RS_hex.__argnames__) Object.defineProperties(RS_hex, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_enumerate(iterable) {\n    var ans, iterator;\n    ans = {"_i":-1};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    if (RS_arraylike(iterable)) {\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {\'done\':false, \'value\':[this._i, iterable[this._i]]};\n            }\n            return {\'done\':true};\n        };\n        return ans;\n    }\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        ans["_iterator"] = iterator;\n        ans["next"] = function () {\n            var r;\n            r = this._iterator.next();\n            if (r.done) {\n                return {\'done\':true};\n            }\n            this._i += 1;\n            return {\'done\':false, \'value\':[this._i, r.value]};\n        };\n        return ans;\n    }\n    return RS_enumerate(Object.keys(iterable));\n};\nif (!RS_enumerate.__argnames__) Object.defineProperties(RS_enumerate, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_reversed(iterable) {\n    var ans;\n    if (RS_arraylike(iterable)) {\n        ans = {"_i": iterable.length};\n        ans["next"] = function () {\n            this._i -= 1;\n            if (this._i > -1) {\n                return {\'done\':false, \'value\':iterable[this._i]};\n            }\n            return {\'done\':true};\n        };\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        return ans;\n    }\n    throw new TypeError("reversed() can only be called on arrays or strings");\n};\nif (!RS_reversed.__argnames__) Object.defineProperties(RS_reversed, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_iter(iterable) {\n    var ans;\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        return (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n    }\n    if (RS_arraylike(iterable)) {\n        ans = {"_i":-1};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {\'done\':false, \'value\':iterable[this._i]};\n            }\n            return {\'done\':true};\n        };\n        return ans;\n    }\n    return RS_iter(Object.keys(iterable));\n};\nif (!RS_iter.__argnames__) Object.defineProperties(RS_iter, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_range_next(step, length) {\n    var RS_unpack;\n    this._i += step;\n    this._idx += 1;\n    if (this._idx >= length) {\n        RS_unpack = [this.__i, -1];\n        this._i = RS_unpack[0];\n        this._idx = RS_unpack[1];\n        return {\'done\':true};\n    }\n    return {\'done\':false, \'value\':this._i};\n};\nif (!RS_range_next.__argnames__) Object.defineProperties(RS_range_next, {\n    __argnames__ : {value: ["step", "length"]}\n});\n\nfunction RS_range(start, stop, step) {\n    var length, ans;\n    if (arguments.length <= 1) {\n        stop = start || 0;\n        start = 0;\n    }\n    step = arguments[2] || 1;\n    length = Math.max(Math.ceil((stop - start) / step), 0);\n    ans = {start:start, step:step, stop:stop};\n    ans[RS_iterator_symbol] = function () {\n        var it;\n        it = {"_i": start - step, "_idx": -1};\n        it.next = RS_range_next.bind(it, step, length);\n        it[RS_iterator_symbol] = function () {\n            return this;\n        };\n        return it;\n    };\n    ans.count = (function() {\n        var RS_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.count(val);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["val"]}\n        });\n        return RS_anonfunc;\n    })();\n    ans.index = (function() {\n        var RS_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.index(val);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["val"]}\n        });\n        return RS_anonfunc;\n    })();\n    if (typeof Proxy === "function") {\n        ans = new Proxy(ans, (function(){\n            var RS_d = {};\n            RS_d["get"] = (function() {\n                var RS_anonfunc = function (obj, prop) {\n                    var iprop;\n                    if (typeof prop === "string") {\n                        iprop = parseInt(prop);\n                        if (!isNaN(iprop)) {\n                            prop = iprop;\n                        }\n                    }\n                    if (typeof prop === "number") {\n                        if (!obj._cached) {\n                            obj._cached = list(obj);\n                        }\n                        return (RS_expr_temp = obj._cached)[(typeof prop === "number" && prop < 0) ? RS_expr_temp.length + prop : prop];\n                    }\n                    return obj[(typeof prop === "number" && prop < 0) ? obj.length + prop : prop];\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["obj", "prop"]}\n                });\n                return RS_anonfunc;\n            })();\n            return RS_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!RS_range.__argnames__) Object.defineProperties(RS_range, {\n    __argnames__ : {value: ["start", "stop", "step"]}\n});\n\nfunction RS_getattr(obj, name, defval) {\n    var ret;\n    try {\n        ret = obj[(typeof name === "number" && name < 0) ? obj.length + name : name];\n    } catch (RS_Exception) {\n        RS_last_exception = RS_Exception;\n        if (RS_Exception instanceof TypeError) {\n            if (defval === undefined) {\n                throw new AttributeError("The attribute " + name + " is not present");\n            }\n            return defval;\n        } else {\n            throw RS_Exception;\n        }\n    }\n    if (ret === undefined && !(name in obj)) {\n        if (defval === undefined) {\n            throw new AttributeError("The attribute " + name + " is not present");\n        }\n        ret = defval;\n    }\n    return ret;\n};\nif (!RS_getattr.__argnames__) Object.defineProperties(RS_getattr, {\n    __argnames__ : {value: ["obj", "name", "defval"]}\n});\n\nfunction RS_setattr(obj, name, value) {\n    obj[(typeof name === "number" && name < 0) ? obj.length + name : name] = value;\n};\nif (!RS_setattr.__argnames__) Object.defineProperties(RS_setattr, {\n    __argnames__ : {value: ["obj", "name", "value"]}\n});\n\nfunction RS_hasattr(obj, name) {\n    return name in obj;\n};\nif (!RS_hasattr.__argnames__) Object.defineProperties(RS_hasattr, {\n    __argnames__ : {value: ["obj", "name"]}\n});\n\nRS_len = function () {\n    function len(obj) {\n        if (RS_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === "function") {\n            return obj.__len__();\n        }\n        if (obj instanceof Set || obj instanceof Map) {\n            return obj.size;\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len.__argnames__) Object.defineProperties(len, {\n        __argnames__ : {value: ["obj"]}\n    });\n\n    function len5(obj) {\n        if (RS_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === "function") {\n            return obj.__len__();\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len5.__argnames__) Object.defineProperties(len5, {\n        __argnames__ : {value: ["obj"]}\n    });\n\n    return (typeof Set === "function" && typeof Map === "function") ? len : len5;\n}();\nfunction RS_get_module(name) {\n    return RS_modules[(typeof name === "number" && name < 0) ? RS_modules.length + name : name];\n};\nif (!RS_get_module.__argnames__) Object.defineProperties(RS_get_module, {\n    __argnames__ : {value: ["name"]}\n});\n\nfunction RS_pow(x, y, z) {\n    var ans;\n    ans = Math.pow(x, y);\n    if (z !== undefined) {\n        ans %= z;\n    }\n    return ans;\n};\nif (!RS_pow.__argnames__) Object.defineProperties(RS_pow, {\n    __argnames__ : {value: ["x", "y", "z"]}\n});\n\nfunction RS_type(x) {\n    return x.constructor;\n};\nif (!RS_type.__argnames__) Object.defineProperties(RS_type, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_divmod(x, y) {\n    var d;\n    if (y === 0) {\n        throw new ZeroDivisionError("integer division or modulo by zero");\n    }\n    d = Math.floor(x / y);\n    return [d, x - d * y];\n};\nif (!RS_divmod.__argnames__) Object.defineProperties(RS_divmod, {\n    __argnames__ : {value: ["x", "y"]}\n});\n\nfunction RS_max() {\n    var kwargs = arguments[arguments.length-1];\n    if (kwargs === null || typeof kwargs !== "object" || kwargs [RS_kwargs_symbol] !== true) kwargs = {};\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (kwargs !== null && typeof kwargs === "object" && kwargs [RS_kwargs_symbol] === true) args.pop();\n    var args, x;\n    if (args.length === 0) {\n        if (kwargs.defval !== undefined) {\n            return kwargs.defval;\n        }\n        throw new TypeError("expected at least one argument");\n    }\n    if (args.length === 1) {\n        args = args[0];\n    }\n    if (kwargs.key) {\n        args = (function() {\n            var RS_Iter = RS_Iterable(args), RS_Result = [], x;\n            for (var RS_Index = 0; RS_Index < RS_Iter.length; RS_Index++) {\n                x = RS_Iter[RS_Index];\n                RS_Result.push(kwargs.key(x));\n            }\n            RS_Result = RS_list_constructor(RS_Result);\n            return RS_Result;\n        })();\n    }\n    if (!Array.isArray(args)) {\n        args = list(args);\n    }\n    if (args.length) {\n        return this.apply(null, args);\n    }\n    if (kwargs.defval !== undefined) {\n        return kwargs.defval;\n    }\n    throw new TypeError("expected at least one argument");\n};\nif (!RS_max.__handles_kwarg_interpolation__) Object.defineProperties(RS_max, {\n    __handles_kwarg_interpolation__ : {value: true}\n});\n\nvar abs = Math.abs, max = RS_max.bind(Math.max), min = RS_max.bind(Math.min), bool = RS_bool, type = RS_type;\nvar float = RS_float, int = RS_int, arraylike = RS_arraylike_creator(), RS_arraylike = arraylike;\nvar print = RS_print, id = RS_id, get_module = RS_get_module, pow = RS_pow, divmod = RS_divmod;\nvar dir = RS_dir, ord = RS_ord, chr = RS_chr, bin = RS_bin, hex = RS_hex, callable = RS_callable;\nvar enumerate = RS_enumerate, iter = RS_iter, reversed = RS_reversed, len = RS_len;\nvar range = RS_range, getattr = RS_getattr, setattr = RS_setattr, hasattr = RS_hasattr;function RS_equals(a, b) {\n    var RS_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === "function") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === "function") {\n        return b.__eq__(a);\n    }\n    if (RS_arraylike(a) && RS_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== "object" || RS_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[(typeof i === "number" && i < 0) ? a.length + i : i] === b[(typeof i === "number" && i < 0) ? b.length + i : i] || typeof a[(typeof i === "number" && i < 0) ? a.length + i : i] === "object" && RS_equals(a[(typeof i === "number" && i < 0) ? a.length + i : i], b[(typeof i === "number" && i < 0) ? b.length + i : i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof a === "object" && typeof b === "object" && a !== null && b !== null && (a.constructor === Object && b.constructor === Object || Object.getPrototypeOf(a) === null && Object.getPrototypeOf(b) === null)) {\n        RS_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = RS_unpack[0];\n        bkeys = RS_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var j=0; j < akeys.length; j++) {\n            key = akeys[(typeof j === "number" && j < 0) ? akeys.length + j : j];\n            if (!((a[(typeof key === "number" && key < 0) ? a.length + key : key] === b[(typeof key === "number" && key < 0) ? b.length + key : key] || typeof a[(typeof key === "number" && key < 0) ? a.length + key : key] === "object" && RS_equals(a[(typeof key === "number" && key < 0) ? a.length + key : key], b[(typeof key === "number" && key < 0) ? b.length + key : key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\nif (!RS_equals.__argnames__) Object.defineProperties(RS_equals, {\n    __argnames__ : {value: ["a", "b"]}\n});\n\nfunction RS_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === "function") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === "function") {\n        return b.__ne__(a);\n    }\n    return !RS_equals(a, b);\n};\nif (!RS_not_equals.__argnames__) Object.defineProperties(RS_not_equals, {\n    __argnames__ : {value: ["a", "b"]}\n});\n\nvar equals = RS_equals;\nfunction RS_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === "string") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            (RS_expr_temp = this)[RS_bound_index(start + i, RS_expr_temp)] = iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i];\n        }\n    } else {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n};\nif (!RS_list_extend.__argnames__) Object.defineProperties(RS_list_extend, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction RS_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + " is not in list");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + " is not in list");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if (((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === val || typeof (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === "object" && RS_equals((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + " is not in list");\n};\nif (!RS_list_index.__argnames__) Object.defineProperties(RS_list_index, {\n    __argnames__ : {value: ["val", "start", "stop"]}\n});\n\nfunction RS_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError("list is empty");\n    }\n    if (index === undefined) {\n        index = -1;\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError("pop index out of range");\n    }\n    return ans[0];\n};\nif (!RS_list_pop.__argnames__) Object.defineProperties(RS_list_pop, {\n    __argnames__ : {value: ["index"]}\n});\n\nfunction RS_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + " not in list");\n    }\n    this.splice(idx, 1);\n};\nif (!RS_list_remove.__argnames__) Object.defineProperties(RS_list_remove, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_to_string() {\n    return "[" + this.join(", ") + "]";\n};\n\nfunction RS_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] = (RS_expr_temp = this)[RS_bound_index(i - 1, RS_expr_temp)];\n    }\n    (RS_expr_temp = this)[(typeof index === "number" && index < 0) ? RS_expr_temp.length + index : index] = val;\n};\nif (!RS_list_insert.__argnames__) Object.defineProperties(RS_list_insert, {\n    __argnames__ : {value: ["index", "val"]}\n});\n\nfunction RS_list_copy() {\n    return RS_list_constructor(this);\n};\n\nfunction RS_list_clear() {\n    this.length = 0;\n};\n\nfunction RS_list_as_array() {\n    return Array.prototype.slice.call(this);\n};\n\nfunction RS_list_count(value) {\n    return this.reduce((function() {\n        var RS_anonfunc = function (n, val) {\n            return n + (val === value);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["n", "val"]}\n        });\n        return RS_anonfunc;\n    })(), 0);\n};\nif (!RS_list_count.__argnames__) Object.defineProperties(RS_list_count, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === "string" || t === "number") {\n        return value;\n    }\n    return value.toString();\n};\nif (!RS_list_sort_key.__argnames__) Object.defineProperties(RS_list_sort_key, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_sort_cmp(a, b, ap, bp) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return ap - bp;\n};\nif (!RS_list_sort_cmp.__argnames__) Object.defineProperties(RS_list_sort_cmp, {\n    __argnames__ : {value: ["a", "b", "ap", "bp"]}\n});\n\nfunction RS_list_sort() {\n    var key = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? RS_list_sort.__defaults__.key : arguments[0];\n    var reverse = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? RS_list_sort.__defaults__.reverse : arguments[1];\n    var RS_kwargs_obj = arguments[arguments.length-1];\n    if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "key")){\n        key = RS_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "reverse")){\n        reverse = RS_kwargs_obj.reverse;\n    }\n    var mult, keymap, posmap, k;\n    key = key || RS_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    posmap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n        keymap.set(k, key(k));\n        posmap.set(k, i);\n    }\n    this.sort((function() {\n        var RS_anonfunc = function (a, b) {\n            return mult * RS_list_sort_cmp(keymap.get(a), keymap.get(b), posmap.get(a), posmap.get(b));\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["a", "b"]}\n        });\n        return RS_anonfunc;\n    })());\n};\nif (!RS_list_sort.__defaults__) Object.defineProperties(RS_list_sort, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: ["key", "reverse"]}\n});\n\nfunction RS_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    RS_list_decorate(ans);\n    return ans;\n};\n\nfunction RS_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    RS_list_decorate(ans);\n    return ans;\n};\n\nfunction RS_list_iterator(value) {\n    var self;\n    self = this;\n    return (function(){\n        var RS_d = {};\n        RS_d["_i"] = -1;\n        RS_d["_list"] = self;\n        RS_d["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._list.length) {\n                return (function(){\n                    var RS_d = {};\n                    RS_d["done"] = true;\n                    return RS_d;\n                }).call(this);\n            }\n            return (function(){\n                var RS_d = {};\n                RS_d["done"] = false;\n                RS_d["value"] = (RS_expr_temp = this._list)[RS_bound_index(this._i, RS_expr_temp)];\n                return RS_d;\n            }).call(this);\n        };\n        return RS_d;\n    }).call(this);\n};\nif (!RS_list_iterator.__argnames__) Object.defineProperties(RS_list_iterator, {\n    __argnames__ : {value: ["value"]}\n});\n\nfunction RS_list_len() {\n    return this.length;\n};\n\nfunction RS_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if (((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === val || typeof (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === "object" && RS_equals((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i], val))) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!RS_list_contains.__argnames__) Object.defineProperties(RS_list_contains, {\n    __argnames__ : {value: ["val"]}\n});\n\nfunction RS_list_eq(other) {\n    if (!RS_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== "object" || RS_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!(((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === other[(typeof i === "number" && i < 0) ? other.length + i : i] || typeof (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] === "object" && RS_equals((RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i], other[(typeof i === "number" && i < 0) ? other.length + i : i])))) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!RS_list_eq.__argnames__) Object.defineProperties(RS_list_eq, {\n    __argnames__ : {value: ["other"]}\n});\n\nfunction RS_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = RS_list_to_string;\n    ans.inspect = RS_list_to_string;\n    ans.extend = RS_list_extend;\n    ans.index = RS_list_index;\n    ans.pypop = RS_list_pop;\n    ans.remove = RS_list_remove;\n    ans.insert = RS_list_insert;\n    ans.copy = RS_list_copy;\n    ans.clear = RS_list_clear;\n    ans.count = RS_list_count;\n    ans.concat = RS_list_concat;\n    ans.pysort = RS_list_sort;\n    ans.slice = RS_list_slice;\n    ans.as_array = RS_list_as_array;\n    ans.__len__ = RS_list_len;\n    ans.__contains__ = RS_list_contains;\n    ans.__eq__ = RS_list_eq;\n    ans.constructor = RS_list_constructor;\n    if (typeof ans[RS_iterator_symbol] !== "function") {\n        ans[RS_iterator_symbol] = RS_list_iterator;\n    }\n    return ans;\n};\nif (!RS_list_decorate.__argnames__) Object.defineProperties(RS_list_decorate, {\n    __argnames__ : {value: ["ans"]}\n});\n\nfunction RS_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (RS_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[(typeof i === "number" && i < 0) ? ans.length + i : i] = iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i];\n        }\n    } else if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        ans = RS_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === "number") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return RS_list_decorate(ans);\n};\nif (!RS_list_constructor.__argnames__) Object.defineProperties(RS_list_constructor, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_list_constructor.__name__ = "list";\nvar list = RS_list_constructor, list_wrap = RS_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? sorted.__defaults__.key : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? sorted.__defaults__.reverse : arguments[2];\n    var RS_kwargs_obj = arguments[arguments.length-1];\n    if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "key")){\n        key = RS_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "reverse")){\n        reverse = RS_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = RS_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n};\nif (!sorted.__defaults__) Object.defineProperties(sorted, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: ["iterable", "key", "reverse"]}\n});\n\nvar RS_global_object_id = 0, RS_set_implementation;\nfunction RS_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === "string" || t === "number" || t === "boolean") {\n        return "_" + t[0] + x;\n    }\n    if (x === null) {\n        return "__!@#$0";\n    }\n    ans = x.RS_hash_key_prop;\n    if (ans === undefined) {\n        ans = "_!@#$" + (++RS_global_object_id);\n        Object.defineProperty(x, "RS_hash_key_prop", (function(){\n            var RS_d = {};\n            RS_d["value"] = ans;\n            return RS_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!RS_set_keyfor.__argnames__) Object.defineProperties(RS_set_keyfor, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nRS_set_polyfill.prototype.add = (function() {\n    var RS_anonfunc = function (x) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n            (RS_expr_temp = this._store)[(typeof key === "number" && key < 0) ? RS_expr_temp.length + key : key] = x;\n        }\n        return this;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.clear = (function() {\n    var RS_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.delete = (function() {\n    var RS_anonfunc = function (x) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.has = (function() {\n    var RS_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, RS_set_keyfor(x));\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set_polyfill.prototype.values = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nif (typeof Set !== "function" || typeof Set.prototype.delete !== "function") {\n    RS_set_implementation = RS_set_polyfill;\n} else {\n    RS_set_implementation = Set;\n}\nfunction RS_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof RS_set) {\n        this.jsset = new RS_set_implementation;\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (RS_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i]);\n            }\n        } else if (typeof iterable[RS_iterator_symbol] === "function") {\n            iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                s.add(keys[(typeof j === "number" && j < 0) ? keys.length + j : j]);\n            }\n        }\n        return ans;\n    } else {\n        return new RS_set(iterable);\n    }\n};\nif (!RS_set.__argnames__) Object.defineProperties(RS_set, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_set.prototype.__name__ = "set";\nObject.defineProperties(RS_set.prototype, (function(){\n    var RS_d = {};\n    RS_d["length"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsset.size;\n        };\n        return RS_d;\n    }).call(this);\n    RS_d["size"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsset.size;\n        };\n        return RS_d;\n    }).call(this);\n    return RS_d;\n}).call(this));\nRS_set.prototype.__len__ = function () {\n    return this.jsset.size;\n};\nRS_set.prototype.has = RS_set.prototype.__contains__ = (function() {\n    var RS_anonfunc = function (x) {\n        return this.jsset.has(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.add = (function() {\n    var RS_anonfunc = function (x) {\n        this.jsset.add(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.clear = function () {\n    this.jsset.clear();\n};\nRS_set.prototype.copy = function () {\n    return RS_set(this);\n};\nRS_set.prototype.discard = (function() {\n    var RS_anonfunc = function (x) {\n        this.jsset.delete(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype[RS_iterator_symbol] = function () {\n    return this.jsset.values();\n};\nRS_set.prototype.difference = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new RS_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = false;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = true;\n                break;\n            }\n        }\n        if (!has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nRS_set.prototype.difference_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === "number" && j < 0) ? remove.length + j : j]);\n    }\n};\nRS_set.prototype.intersection = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new RS_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = true;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = false;\n                break;\n            }\n        }\n        if (has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nRS_set.prototype.intersection_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === "number" && j < 0) ? remove.length + j : j]);\n    }\n};\nRS_set.prototype.isdisjoint = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.issubset = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.issuperset = (function() {\n    var RS_anonfunc = function (other) {\n        var s, iterator, r, x;\n        s = this.jsset;\n        iterator = other.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!s.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.pop = function () {\n    var iterator, r;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    if (r.done) {\n        throw new KeyError("pop from an empty set");\n    }\n    this.jsset.delete(r.value);\n    return r.value;\n};\nRS_set.prototype.remove = (function() {\n    var RS_anonfunc = function (x) {\n        if (!this.jsset.delete(x)) {\n            throw new KeyError(x.toString());\n        }\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.symmetric_difference = (function() {\n    var RS_anonfunc = function (other) {\n        return this.union(other).difference(this.intersection(other));\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.symmetric_difference_update = (function() {\n    var RS_anonfunc = function (other) {\n        var common;\n        common = this.intersection(other);\n        this.update(other);\n        this.difference_update(common);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_set.prototype.union = function () {\n    var ans;\n    ans = RS_set(this);\n    ans.update.apply(ans, arguments);\n    return ans;\n};\nRS_set.prototype.update = function () {\n    var s, iterator, r;\n    s = this.jsset;\n    for (var i=0; i < arguments.length; i++) {\n        iterator = arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i][RS_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            s.add(r.value);\n            r = iterator.next();\n        }\n    }\n};\nRS_set.prototype.toString = RS_set.prototype.__repr__ = RS_set.prototype.__str__ = RS_set.prototype.inspect = function () {\n    return "{" + list(this).join(", ") + "}";\n};\nRS_set.prototype.__eq__ = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r;\n        if (!other instanceof this.constructor) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other[RS_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            if (!this.has(r.value)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nfunction RS_set_wrap(x) {\n    var ans;\n    ans = new RS_set;\n    ans.jsset = x;\n    return ans;\n};\nif (!RS_set_wrap.__argnames__) Object.defineProperties(RS_set_wrap, {\n    __argnames__ : {value: ["x"]}\n});\n\nvar set = RS_set, set_wrap = RS_set_wrap;\nvar RS_dict_implementation;\nfunction RS_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nRS_dict_polyfill.prototype.set = (function() {\n    var RS_anonfunc = function (x, value) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n        }\n        (RS_expr_temp = this._store)[(typeof key === "number" && key < 0) ? RS_expr_temp.length + key : key] = [x, value];\n        return this;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x", "value"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.clear = (function() {\n    var RS_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.delete = (function() {\n    var RS_anonfunc = function (x) {\n        var key;\n        key = RS_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.has = (function() {\n    var RS_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, RS_set_keyfor(x));\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.get = (function() {\n    var RS_anonfunc = function (x) {\n        try {\n            return (RS_expr_temp = this._store)[RS_bound_index(RS_set_keyfor(x), RS_expr_temp)][1];\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            if (RS_Exception instanceof TypeError) {\n                return undefined;\n            } else {\n                throw RS_Exception;\n            }\n        }\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.values = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]][1]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.keys = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]][0]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict_polyfill.prototype.entries = (function() {\n    var RS_anonfunc = function (x) {\n        var ans;\n        ans = {\'_keys\': Object.keys(this._store), \'_i\':-1, \'_s\':this._store};\n        ans[RS_iterator_symbol] = function () {\n            return this;\n        };\n        ans["next"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\'done\': true};\n            }\n            return {\'done\':false, \'value\':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nif (typeof Map !== "function" || typeof Map.prototype.delete !== "function") {\n    RS_dict_implementation = RS_dict_polyfill;\n} else {\n    RS_dict_implementation = Map;\n}\nfunction RS_dict() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true) ? undefined : arguments[0];\n    var kw = arguments[arguments.length-1];\n    if (kw === null || typeof kw !== "object" || kw [RS_kwargs_symbol] !== true) kw = {};\n    if (this instanceof RS_dict) {\n        this.jsmap = new RS_dict_implementation;\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        this.update(kw);\n        return this;\n    } else {\n        return RS_interpolate_kwargs_constructor.call(Object.create(RS_dict.prototype), false, RS_dict, [iterable].concat([RS_desugar_kwargs(kw)]));\n    }\n};\nif (!RS_dict.__handles_kwarg_interpolation__) Object.defineProperties(RS_dict, {\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_dict.prototype.__name__ = "dict";\nObject.defineProperties(RS_dict.prototype, (function(){\n    var RS_d = {};\n    RS_d["length"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsmap.size;\n        };\n        return RS_d;\n    }).call(this);\n    RS_d["size"] = (function(){\n        var RS_d = {};\n        RS_d["get"] = function () {\n            return this.jsmap.size;\n        };\n        return RS_d;\n    }).call(this);\n    return RS_d;\n}).call(this));\nRS_dict.prototype.__len__ = function () {\n    return this.jsmap.size;\n};\nRS_dict.prototype.has = RS_dict.prototype.__contains__ = (function() {\n    var RS_anonfunc = function (x) {\n        return this.jsmap.has(x);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["x"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.set = RS_dict.prototype.__setitem__ = (function() {\n    var RS_anonfunc = function (key, value) {\n        this.jsmap.set(key, value);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "value"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.__delitem__ = (function() {\n    var RS_anonfunc = function (key) {\n        this.jsmap.delete(key);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.clear = function () {\n    this.jsmap.clear();\n};\nRS_dict.prototype.copy = function () {\n    return RS_dict(this);\n};\nRS_dict.prototype.keys = function () {\n    return this.jsmap.keys();\n};\nRS_dict.prototype.values = function () {\n    return this.jsmap.values();\n};\nRS_dict.prototype.items = RS_dict.prototype.entries = function () {\n    return this.jsmap.entries();\n};\nRS_dict.prototype[RS_iterator_symbol] = function () {\n    return this.jsmap.keys();\n};\nRS_dict.prototype.__getitem__ = (function() {\n    var RS_anonfunc = function (key) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            throw new KeyError(key + "");\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.get = (function() {\n    var RS_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            return (defval === undefined) ? null : defval;\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "defval"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.set_default = (function() {\n    var RS_anonfunc = function (key, defval) {\n        var j;\n        j = this.jsmap;\n        if (!j.has(key)) {\n            j.set(key, defval);\n            return defval;\n        }\n        return j.get(key);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "defval"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.fromkeys = RS_dict.prototype.fromkeys = (function() {\n    var RS_anonfunc = function () {\n        var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true) ? undefined : arguments[0];\n        var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === "object" && arguments[arguments.length-1] [RS_kwargs_symbol] === true)) ? RS_anonfunc.__defaults__.value : arguments[1];\n        var RS_kwargs_obj = arguments[arguments.length-1];\n        if (RS_kwargs_obj === null || typeof RS_kwargs_obj !== "object" || RS_kwargs_obj [RS_kwargs_symbol] !== true) RS_kwargs_obj = {};\n        if (Object.prototype.hasOwnProperty.call(RS_kwargs_obj, "value")){\n            value = RS_kwargs_obj.value;\n        }\n        var ans, iterator, r;\n        ans = RS_dict();\n        iterator = iter(iterable);\n        r = iterator.next();\n        while (!r.done) {\n            ans.set(r.value, value);\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__defaults__) Object.defineProperties(RS_anonfunc, {\n        __defaults__ : {value: {value:null}},\n        __handles_kwarg_interpolation__ : {value: true},\n        __argnames__ : {value: ["iterable", "value"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.pop = (function() {\n    var RS_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            if (defval === undefined) {\n                throw new KeyError(key);\n            }\n            return defval;\n        }\n        this.jsmap.delete(key);\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["key", "defval"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.popitem = function () {\n    var r;\n    r = this.jsmap.entries().next();\n    if (r.done) {\n        throw new KeyError("dict is empty");\n    }\n    this.jsmap.delete(r.value[0]);\n    return r.value;\n};\nRS_dict.prototype.update = function () {\n    var m, iterable, iterator, result, keys;\n    if (arguments.length === 0) {\n        return;\n    }\n    m = this.jsmap;\n    iterable = arguments[0];\n    if (Array.isArray(iterable)) {\n        for (var i = 0; i < iterable.length; i++) {\n            m.set(iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i][0], iterable[(typeof i === "number" && i < 0) ? iterable.length + i : i][1]);\n        }\n    } else if (iterable instanceof RS_dict) {\n        iterator = iterable.items();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof Map === "function" && iterable instanceof Map) {\n        iterator = iterable.entries();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = iterable[RS_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else {\n        keys = Object.keys(iterable);\n        for (var j=0; j < keys.length; j++) {\n            if (keys[(typeof j === "number" && j < 0) ? keys.length + j : j] !== RS_iterator_symbol) {\n                m.set(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], iterable[RS_bound_index(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], iterable)]);\n            }\n        }\n    }\n    if (arguments.length > 1) {\n        RS_dict.prototype.update.call(this, arguments[1]);\n    }\n};\nRS_dict.prototype.toString = RS_dict.prototype.inspect = RS_dict.prototype.__str__ = RS_dict.prototype.__repr__ = function () {\n    var entries, iterator, r;\n    entries = [];\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        entries.push(RS_repr(r.value[0]) + ": " + RS_repr(r.value[1]));\n        r = iterator.next();\n    }\n    return "{" + entries.join(", ") + "}";\n};\nRS_dict.prototype.__eq__ = (function() {\n    var RS_anonfunc = function (other) {\n        var iterator, r, x;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other.items();\n        r = iterator.next();\n        while (!r.done) {\n            x = this.jsmap.get(r.value[0]);\n            if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nRS_dict.prototype.as_object = (function() {\n    var RS_anonfunc = function (other) {\n        var ans, iterator, r;\n        ans = {};\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            ans[RS_bound_index(r.value[0], ans)] = r.value[1];\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["other"]}\n    });\n    return RS_anonfunc;\n})();\nfunction RS_dict_wrap(x) {\n    var ans;\n    ans = new RS_dict;\n    ans.jsmap = x;\n    return ans;\n};\nif (!RS_dict_wrap.__argnames__) Object.defineProperties(RS_dict_wrap, {\n    __argnames__ : {value: ["x"]}\n});\n\nvar dict = RS_dict, dict_wrap = RS_dict_wrap;var NameError;\nNameError = ReferenceError;\nfunction Exception() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    Exception.prototype.__init__.apply(this, arguments);\n}\nRS_extends(Exception, Error);\nException.prototype.__init__ = function __init__(message) {\n    var self = this;\n    self.message = message;\n    self.stack = (new Error).stack;\n    self.name = self.constructor.name;\n};\nif (!Exception.prototype.__init__.__argnames__) Object.defineProperties(Exception.prototype.__init__, {\n    __argnames__ : {value: ["message"]}\n});\nException.__argnames__ = Exception.prototype.__init__.__argnames__;\nException.__handles_kwarg_interpolation__ = Exception.prototype.__init__.__handles_kwarg_interpolation__;\nException.prototype.__repr__ = function __repr__() {\n    var self = this;\n    return self.name + ": " + self.message;\n};\nException.prototype.__str__ = function __str__ () {\n    if(Error.prototype.__str__) return Error.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(Exception.prototype, "__bases__", {value: [Error]});\n\nfunction AttributeError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(AttributeError, Exception);\nAttributeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAttributeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AttributeError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction IndexError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(IndexError, Exception);\nIndexError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nIndexError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(IndexError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction KeyError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(KeyError, Exception);\nKeyError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nKeyError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(KeyError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction ValueError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(ValueError, Exception);\nValueError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nValueError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nValueError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ValueError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction UnicodeDecodeError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    UnicodeDecodeError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(UnicodeDecodeError, Exception);\nUnicodeDecodeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nUnicodeDecodeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nUnicodeDecodeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(UnicodeDecodeError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction AssertionError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    AssertionError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(AssertionError, Exception);\nAssertionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAssertionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nAssertionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AssertionError.prototype, "__bases__", {value: [Exception]});\n\n\nfunction ZeroDivisionError() {\n    if (this.RS_object_id === undefined) Object.defineProperty(this, "RS_object_id", {"value":++RS_object_counter});\n    ZeroDivisionError.prototype.__init__.apply(this, arguments);\n}\nRS_extends(ZeroDivisionError, Exception);\nZeroDivisionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nZeroDivisionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return "<" + __name__ + "." + this.constructor.name + " #" + this.RS_object_id + ">";\n};\nZeroDivisionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ZeroDivisionError.prototype, "__bases__", {value: [Exception]});\n\nvar RS_in, RS_desugar_kwargs, RS_exists;\nfunction RS_eslice(arr, step, start, end) {\n    var is_string;\n    if (typeof arr === "string" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split("");\n    }\n    if (step < 0) {\n        step = -step;\n        arr = arr.slice().reverse();\n        if (typeof start !== "undefined") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== "undefined") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === "undefined") {\n        start = 0;\n    }\n    if (typeof end === "undefined") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter((function() {\n        var RS_anonfunc = function (e, i) {\n            return i % step === 0;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["e", "i"]}\n        });\n        return RS_anonfunc;\n    })());\n    if (is_string) {\n        arr = arr.join("");\n    }\n    return arr;\n};\nif (!RS_eslice.__argnames__) Object.defineProperties(RS_eslice, {\n    __argnames__ : {value: ["arr", "step", "start", "end"]}\n});\n\nfunction RS_delslice(arr, step, start, end) {\n    var is_string, RS_unpack, indices;\n    if (typeof arr === "string" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split("");\n    }\n    if (step < 0) {\n        if (typeof start === "undefined") {\n            start = arr.length;\n        }\n        if (typeof end === "undefined") {\n            end = 0;\n        }\n        RS_unpack = [end, start, -step];\n        start = RS_unpack[0];\n        end = RS_unpack[1];\n        step = RS_unpack[2];\n    }\n    if (typeof start === "undefined") {\n        start = 0;\n    }\n    if (typeof end === "undefined") {\n        end = arr.length;\n    }\n    if (step === 1) {\n        arr.splice(start, end - start);\n    } else {\n        if (end > start) {\n            indices = [];\n            for (var i = start; i < end; i += step) {\n                indices.push(i);\n            }\n            for (var i = indices.length - 1; i >= 0; i--) {\n                arr.splice(indices[(typeof i === "number" && i < 0) ? indices.length + i : i], 1);\n            }\n        }\n    }\n    if (is_string) {\n        arr = arr.join("");\n    }\n    return arr;\n};\nif (!RS_delslice.__argnames__) Object.defineProperties(RS_delslice, {\n    __argnames__ : {value: ["arr", "step", "start", "end"]}\n});\n\nfunction RS_flatten(arr) {\n    var ans, value;\n    ans = RS_list_decorate([]);\n    for (var i=0; i < arr.length; i++) {\n        value = arr[(typeof i === "number" && i < 0) ? arr.length + i : i];\n        if (Array.isArray(value)) {\n            ans = ans.concat(RS_flatten(value));\n        } else {\n            ans.push(value);\n        }\n    }\n    return ans;\n};\nif (!RS_flatten.__argnames__) Object.defineProperties(RS_flatten, {\n    __argnames__ : {value: ["arr"]}\n});\n\nfunction RS_unpack_asarray(num, iterable) {\n    var ans, iterator, result;\n    if (RS_arraylike(iterable)) {\n        return iterable;\n    }\n    ans = [];\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done && ans.length < num) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    }\n    return ans;\n};\nif (!RS_unpack_asarray.__argnames__) Object.defineProperties(RS_unpack_asarray, {\n    __argnames__ : {value: ["num", "iterable"]}\n});\n\nfunction RS_extends(child, parent) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\nif (!RS_extends.__argnames__) Object.defineProperties(RS_extends, {\n    __argnames__ : {value: ["child", "parent"]}\n});\n\nRS_in = function () {\n    if (typeof Map === "function" && typeof Set === "function") {\n        return (function() {\n            var RS_anonfunc = function (val, arr) {\n                if (typeof arr === "string") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === "function") {\n                    return arr.__contains__(val);\n                }\n                if (arr instanceof Map || arr instanceof Set) {\n                    return arr.has(val);\n                }\n                if (RS_arraylike(arr)) {\n                    return RS_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["val", "arr"]}\n            });\n            return RS_anonfunc;\n        })();\n    }\n    return (function() {\n        var RS_anonfunc = function (val, arr) {\n            if (typeof arr === "string") {\n                return arr.indexOf(val) !== -1;\n            }\n            if (typeof arr.__contains__ === "function") {\n                return arr.__contains__(val);\n            }\n            if (RS_arraylike(arr)) {\n                return RS_list_contains.call(arr, val);\n            }\n            return Object.prototype.hasOwnProperty.call(arr, val);\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["val", "arr"]}\n        });\n        return RS_anonfunc;\n    })();\n}();\nfunction RS_Iterable(iterable) {\n    var iterator, ans, result;\n    if (RS_arraylike(iterable)) {\n        return iterable;\n    }\n    if (typeof iterable[RS_iterator_symbol] === "function") {\n        iterator = (typeof Map === "function" && iterable instanceof Map) ? iterable.keys() : iterable[RS_iterator_symbol]();\n        ans = RS_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n        return ans;\n    }\n    return Object.keys(iterable);\n};\nif (!RS_Iterable.__argnames__) Object.defineProperties(RS_Iterable, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nRS_desugar_kwargs = function () {\n    if (typeof Object.assign === "function") {\n        return function () {\n            var ans;\n            ans = Object.create(null);\n            ans[RS_kwargs_symbol] = true;\n            for (var i = 0; i < arguments.length; i++) {\n                Object.assign(ans, arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n            }\n            return ans;\n        };\n    }\n    return function () {\n        var ans, keys;\n        ans = Object.create(null);\n        ans[RS_kwargs_symbol] = true;\n        for (var i = 0; i < arguments.length; i++) {\n            keys = Object.keys(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n            for (var j = 0; j < keys.length; j++) {\n                ans[RS_bound_index(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], ans)] = (RS_expr_temp = arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i])[RS_bound_index(keys[(typeof j === "number" && j < 0) ? keys.length + j : j], RS_expr_temp)];\n            }\n        }\n        return ans;\n    };\n}();\nfunction RS_interpolate_kwargs(f, supplied_args) {\n    var has_prop, kwobj, args, prop;\n    if (!f.__argnames__) {\n        return f.apply(this, supplied_args);\n    }\n    has_prop = Object.prototype.hasOwnProperty;\n    kwobj = supplied_args.pop();\n    if (f.__handles_kwarg_interpolation__) {\n        args = new Array(Math.max(supplied_args.length, f.__argnames__.length) + 1);\n        args[args.length-1] = kwobj;\n        for (var i = 0; i < args.length - 1; i++) {\n            if (i < f.__argnames__.length) {\n                prop = (RS_expr_temp = f.__argnames__)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n                if (has_prop.call(kwobj, prop)) {\n                    args[(typeof i === "number" && i < 0) ? args.length + i : i] = kwobj[(typeof prop === "number" && prop < 0) ? kwobj.length + prop : prop];\n                    delete kwobj[prop];\n                } else if (i < supplied_args.length) {\n                    args[(typeof i === "number" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === "number" && i < 0) ? supplied_args.length + i : i];\n                }\n            } else {\n                args[(typeof i === "number" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === "number" && i < 0) ? supplied_args.length + i : i];\n            }\n        }\n        return f.apply(this, args);\n    }\n    for (var i = 0; i < f.__argnames__.length; i++) {\n        prop = (RS_expr_temp = f.__argnames__)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n        if (has_prop.call(kwobj, prop)) {\n            supplied_args[(typeof i === "number" && i < 0) ? supplied_args.length + i : i] = kwobj[(typeof prop === "number" && prop < 0) ? kwobj.length + prop : prop];\n        }\n    }\n    return f.apply(this, supplied_args);\n};\nif (!RS_interpolate_kwargs.__argnames__) Object.defineProperties(RS_interpolate_kwargs, {\n    __argnames__ : {value: ["f", "supplied_args"]}\n});\n\nfunction RS_interpolate_kwargs_constructor(apply, f, supplied_args) {\n    if (apply) {\n        f.apply(this, supplied_args);\n    } else {\n        RS_interpolate_kwargs.call(this, f, supplied_args);\n    }\n    return this;\n};\nif (!RS_interpolate_kwargs_constructor.__argnames__) Object.defineProperties(RS_interpolate_kwargs_constructor, {\n    __argnames__ : {value: ["apply", "f", "supplied_args"]}\n});\n\nfunction RS_getitem(obj, key) {\n    if (obj.__getitem__) {\n        return obj.__getitem__(key);\n    }\n    if (typeof key === "number" && key < 0) {\n        key += obj.length;\n    }\n    return obj[(typeof key === "number" && key < 0) ? obj.length + key : key];\n};\nif (!RS_getitem.__argnames__) Object.defineProperties(RS_getitem, {\n    __argnames__ : {value: ["obj", "key"]}\n});\n\nfunction RS_setitem(obj, key, val) {\n    if (obj.__setitem__) {\n        obj.__setitem__(key, val);\n    } else {\n        if (typeof key === "number" && key < 0) {\n            key += obj.length;\n        }\n        obj[(typeof key === "number" && key < 0) ? obj.length + key : key] = val;\n    }\n};\nif (!RS_setitem.__argnames__) Object.defineProperties(RS_setitem, {\n    __argnames__ : {value: ["obj", "key", "val"]}\n});\n\nfunction RS_delitem(obj, key) {\n    if (obj.__delitem__) {\n        obj.__delitem__(key);\n    } else if (typeof obj.splice === "function") {\n        obj.splice(key, 1);\n    } else {\n        if (typeof key === "number" && key < 0) {\n            key += obj.length;\n        }\n        delete obj[key];\n    }\n};\nif (!RS_delitem.__argnames__) Object.defineProperties(RS_delitem, {\n    __argnames__ : {value: ["obj", "key"]}\n});\n\nfunction RS_bound_index(idx, arr) {\n    if (typeof idx === "number" && idx < 0) {\n        idx += arr.length;\n    }\n    return idx;\n};\nif (!RS_bound_index.__argnames__) Object.defineProperties(RS_bound_index, {\n    __argnames__ : {value: ["idx", "arr"]}\n});\n\nfunction RS_splice(arr, val, start, end) {\n    start = start || 0;\n    if (start < 0) {\n        start += arr.length;\n    }\n    if (end === undefined) {\n        end = arr.length;\n    }\n    if (end < 0) {\n        end += arr.length;\n    }\n    Array.prototype.splice.apply(arr, [start, end - start].concat(val));\n};\nif (!RS_splice.__argnames__) Object.defineProperties(RS_splice, {\n    __argnames__ : {value: ["arr", "val", "start", "end"]}\n});\n\nRS_exists = (function(){\n    var RS_d = {};\n    RS_d["n"] = (function() {\n        var RS_anonfunc = function (expr) {\n            return expr !== undefined && expr !== null;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["d"] = (function() {\n        var RS_anonfunc = function (expr) {\n            if (expr === undefined || expr === null) {\n                return Object.create(null);\n            }\n            return expr;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["c"] = (function() {\n        var RS_anonfunc = function (expr) {\n            if (typeof expr === "function") {\n                return expr;\n            }\n            return function () {\n                return undefined;\n            };\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["g"] = (function() {\n        var RS_anonfunc = function (expr) {\n            if (expr === undefined || expr === null || typeof expr.__getitem__ !== "function") {\n                return (function(){\n                    var RS_d = {};\n                    RS_d["__getitem__"] = function () {\n                        return undefined;\n                    };\n                    return RS_d;\n                }).call(this);\n            }\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr"]}\n        });\n        return RS_anonfunc;\n    })();\n    RS_d["e"] = (function() {\n        var RS_anonfunc = function (expr, alt) {\n            return (expr === undefined || expr === null) ? alt : expr;\n        };\n        if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n            __argnames__ : {value: ["expr", "alt"]}\n        });\n        return RS_anonfunc;\n    })();\n    return RS_d;\n}).call(this);\nfunction RS_mixin() {\n    var seen, resolved_props, p, target, props, name;\n    seen = Object.create(null);\n    seen.__argnames__ = seen.__handles_kwarg_interpolation__ = seen.__init__ = seen.__annotations__ = seen.__doc__ = seen.__bind_methods__ = seen.__bases__ = seen.constructor = seen.__class__ = true;\n    resolved_props = {};\n    p = target = arguments[0].prototype;\n    while (p && p !== Object.prototype) {\n        props = Object.getOwnPropertyNames(p);\n        for (var i = 0; i < props.length; i++) {\n            seen[RS_bound_index(props[(typeof i === "number" && i < 0) ? props.length + i : i], seen)] = true;\n        }\n        p = Object.getPrototypeOf(p);\n    }\n    for (var c = 1; c < arguments.length; c++) {\n        p = arguments[(typeof c === "number" && c < 0) ? arguments.length + c : c].prototype;\n        while (p && p !== Object.prototype) {\n            props = Object.getOwnPropertyNames(p);\n            for (var i = 0; i < props.length; i++) {\n                name = props[(typeof i === "number" && i < 0) ? props.length + i : i];\n                if (seen[(typeof name === "number" && name < 0) ? seen.length + name : name]) {\n                    continue;\n                }\n                seen[(typeof name === "number" && name < 0) ? seen.length + name : name] = true;\n                resolved_props[(typeof name === "number" && name < 0) ? resolved_props.length + name : name] = Object.getOwnPropertyDescriptor(p, name);\n            }\n            p = Object.getPrototypeOf(p);\n        }\n    }\n    Object.defineProperties(target, resolved_props);\n};\n\nfunction RS_instanceof() {\n    var obj, bases, q, cls, p;\n    obj = arguments[0];\n    bases = "";\n    if (obj && obj.constructor && obj.constructor.prototype) {\n        bases = obj.constructor.prototype.__bases__ || "";\n    }\n    for (var i = 1; i < arguments.length; i++) {\n        q = arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i];\n        if (obj instanceof q) {\n            return true;\n        }\n        if ((q === Array || q === RS_list_constructor) && Array.isArray(obj)) {\n            return true;\n        }\n        if (q === RS_str && (typeof obj === "string" || obj instanceof String)) {\n            return true;\n        }\n        if (bases.length > 1) {\n            for (var c = 1; c < bases.length; c++) {\n                cls = bases[(typeof c === "number" && c < 0) ? bases.length + c : c];\n                while (cls) {\n                    if (q === cls) {\n                        return true;\n                    }\n                    p = Object.getPrototypeOf(cls.prototype);\n                    if (!p) {\n                        break;\n                    }\n                    cls = p.constructor;\n                }\n            }\n        }\n    }\n    return false;\n};\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce((function() {\n            var RS_anonfunc = function (prev, cur) {\n                return prev + cur;\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["prev", "cur"]}\n            });\n            return RS_anonfunc;\n        })(), start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n};\nif (!sum.__argnames__) Object.defineProperties(sum, {\n    __argnames__ : {value: ["iterable", "start"]}\n});\n\nfunction map() {\n    var iterators, func, args, ans;\n    iterators = new Array(arguments.length - 1);\n    func = arguments[0];\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[RS_bound_index(i - 1, iterators)] = iter(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {\'_func\':func, \'_iterators\':iterators, \'_args\':args};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    ans["next"] = function () {\n        var r;\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (RS_expr_temp = this._iterators)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {\'done\':true};\n            }\n            (RS_expr_temp = this._args)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i] = r.value;\n        }\n        return {\'done\':false, \'value\':this._func.apply(undefined, this._args)};\n    };\n    return ans;\n};\n\nfunction filter(func_or_none, iterable) {\n    var func, ans;\n    func = (func_or_none === null) ? RS_bool : func_or_none;\n    ans = {\'_func\':func, \'_iterator\':RS_iter(iterable)};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    ans["next"] = function () {\n        var r;\n        r = this._iterator.next();\n        while (!r.done) {\n            if (this._func(r.value)) {\n                return r;\n            }\n            r = this._iterator.next();\n        }\n        return {\'done\':true};\n    };\n    return ans;\n};\nif (!filter.__argnames__) Object.defineProperties(filter, {\n    __argnames__ : {value: ["func_or_none", "iterable"]}\n});\n\nfunction zip() {\n    var iterators, ans;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[(typeof i === "number" && i < 0) ? iterators.length + i : i] = iter(arguments[(typeof i === "number" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {\'_iterators\':iterators};\n    ans[RS_iterator_symbol] = function () {\n        return this;\n    };\n    ans["next"] = function () {\n        var args, r;\n        args = new Array(this._iterators.length);\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (RS_expr_temp = this._iterators)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {\'done\':true};\n            }\n            args[(typeof i === "number" && i < 0) ? args.length + i : i] = r.value;\n        }\n        return {\'done\':false, \'value\':args};\n    };\n    return ans;\n};\n\nfunction any(iterable) {\n    var i;\n    var RS_Iter0 = RS_Iterable(iterable);\n    for (var RS_Index0 = 0; RS_Index0 < RS_Iter0.length; RS_Index0++) {\n        i = RS_Iter0[RS_Index0];\n        if (i) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!any.__argnames__) Object.defineProperties(any, {\n    __argnames__ : {value: ["iterable"]}\n});\n\nfunction all(iterable) {\n    var i;\n    var RS_Iter1 = RS_Iterable(iterable);\n    for (var RS_Index1 = 0; RS_Index1 < RS_Iter1.length; RS_Index1++) {\n        i = RS_Iter1[RS_Index1];\n        if (!i) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!all.__argnames__) Object.defineProperties(all, {\n    __argnames__ : {value: ["iterable"]}\n});\nvar define_str_func, RS_unpack, RS_orig_split, RS_orig_replace;\nfunction RS_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = "{}";\n    if (as_array) {\n        b = "[]";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(RS_repr(x[(typeof i === "number" && i < 0) ? x.length + i : i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[(typeof k === "number" && k < 0) ? keys.length + k : k];\n            ans.push(JSON.stringify(key) + ":" + RS_repr(x[(typeof key === "number" && key < 0) ? x.length + key : key]));\n        }\n    }\n    return b[0] + ans.join(", ") + b[1];\n};\nif (!RS_repr_js_builtin.__argnames__) Object.defineProperties(RS_repr_js_builtin, {\n    __argnames__ : {value: ["x", "as_array"]}\n});\n\nfunction RS_html_element_to_string(elem) {\n    var attrs, val, attr, ans;\n    attrs = [];\n    var RS_Iter0 = RS_Iterable(elem.attributes);\n    for (var RS_Index0 = 0; RS_Index0 < RS_Iter0.length; RS_Index0++) {\n        attr = RS_Iter0[RS_Index0];\n        if (attr.specified) {\n            val = attr.value;\n            if (val.length > 10) {\n                val = val.slice(0, 15) + "...";\n            }\n            val = JSON.stringify(val);\n            attrs.push("" + RS_str.format("{}", attr.name) + "=" + RS_str.format("{}", val) + "");\n        }\n    }\n    attrs = (attrs.length) ? " " + attrs.join(" ") : "";\n    ans = "<" + RS_str.format("{}", elem.tagName) + "" + RS_str.format("{}", attrs) + ">";\n    return ans;\n};\nif (!RS_html_element_to_string.__argnames__) Object.defineProperties(RS_html_element_to_string, {\n    __argnames__ : {value: ["elem"]}\n});\n\nfunction RS_repr(x) {\n    var ans, name;\n    if (x === null) {\n        return "None";\n    }\n    if (x === undefined) {\n        return "undefined";\n    }\n    ans = x;\n    if (typeof x.__repr__ === "function") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? "True" : "False";\n    } else if (Array.isArray(x)) {\n        ans = RS_repr_js_builtin(x, true);\n    } else if (typeof x === "function") {\n        ans = x.toString();\n    } else if (typeof x === "object" && !x.toString) {\n        ans = RS_repr_js_builtin(x);\n    } else {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (RS_not_equals("Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".indexOf(name), -1)) {\n            return name + "([" + x.map((function() {\n                var RS_anonfunc = function (i) {\n                    return str.format("0x{:02x}", i);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["i"]}\n                });\n                return RS_anonfunc;\n            })()).join(", ") + "])";\n        }\n        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {\n            ans = RS_html_element_to_string(x);\n        } else {\n            ans = (typeof x.toString === "function") ? x.toString() : x;\n        }\n        if (ans === "[object Object]") {\n            return RS_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            {\n            } \n        }\n    }\n    return ans + "";\n};\nif (!RS_repr.__argnames__) Object.defineProperties(RS_repr, {\n    __argnames__ : {value: ["x"]}\n});\n\nfunction RS_str(x) {\n    var ans, name;\n    if (x === null) {\n        return "None";\n    }\n    if (x === undefined) {\n        return "undefined";\n    }\n    ans = x;\n    if (typeof x.__str__ === "function") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === "function") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? "True" : "False";\n    } else if (Array.isArray(x)) {\n        ans = RS_repr_js_builtin(x, true);\n    } else if (typeof x.toString === "function") {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (RS_not_equals("Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".indexOf(name), -1)) {\n            return name + "([" + x.map((function() {\n                var RS_anonfunc = function (i) {\n                    return str.format("0x{:02x}", i);\n                };\n                if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                    __argnames__ : {value: ["i"]}\n                });\n                return RS_anonfunc;\n            })()).join(", ") + "])";\n        }\n        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {\n            ans = RS_html_element_to_string(x);\n        } else {\n            ans = x.toString();\n        }\n        if (ans === "[object Object]") {\n            ans = RS_repr_js_builtin(x);\n        }\n    } else if (typeof x === "object" && !x.toString) {\n        ans = RS_repr_js_builtin(x);\n    }\n    return ans + "";\n};\nif (!RS_str.__argnames__) Object.defineProperties(RS_str, {\n    __argnames__ : {value: ["x"]}\n});\n\ndefine_str_func = (function() {\n    var RS_anonfunc = function (name, func) {\n        var f;\n        (RS_expr_temp = RS_str.prototype)[(typeof name === "number" && name < 0) ? RS_expr_temp.length + name : name] = func;\n        RS_str[(typeof name === "number" && name < 0) ? RS_str.length + name : name] = f = func.call.bind(func);\n        if (func.__argnames__) {\n            Object.defineProperty(f, "__argnames__", (function(){\n                var RS_d = {};\n                RS_d["value"] = [\'string\'].concat(func.__argnames__);\n                return RS_d;\n            }).call(this));\n        }\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["name", "func"]}\n    });\n    return RS_anonfunc;\n})();\nRS_unpack = [String.prototype.split.call.bind(String.prototype.split), String.prototype.replace.call.bind(String.prototype.replace)];\nRS_orig_split = RS_unpack[0];\nRS_orig_replace = RS_unpack[1];\ndefine_str_func("format", function () {\n    var template, args, kwargs, explicit, implicit, idx, split, ans, pos, in_brace, markup, ch;\n    template = this;\n    if (template === undefined) {\n        throw new TypeError("Template is required");\n    }\n    args = Array.prototype.slice.call(arguments);\n    kwargs = {};\n    if (args[args.length-1] && args[args.length-1][RS_kwargs_symbol] !== undefined) {\n        kwargs = args[args.length-1];\n        args = args.slice(0, -1);\n    }\n    explicit = implicit = false;\n    idx = 0;\n    split = RS_orig_split;\n    if (RS_str.format._template_resolve_pat === undefined) {\n        RS_str.format._template_resolve_pat = /[.\\[]/;\n    }\n    function resolve(arg, object) {\n        var RS_unpack, first, key, rest, ans;\n        if (!arg) {\n            return object;\n        }\n        RS_unpack = [arg[0], arg.slice(1)];\n        first = RS_unpack[0];\n        arg = RS_unpack[1];\n        key = split(arg, RS_str.format._template_resolve_pat, 1)[0];\n        rest = arg.slice(key.length);\n        ans = (first === "[") ? object[RS_bound_index(key.slice(0, -1), object)] : getattr(object, key);\n        if (ans === undefined) {\n            throw new KeyError((first === "[") ? key.slice(0, -1) : key);\n        }\n        return resolve(rest, ans);\n    };\n    if (!resolve.__argnames__) Object.defineProperties(resolve, {\n        __argnames__ : {value: ["arg", "object"]}\n    });\n\n    function resolve_format_spec(format_spec) {\n        if (RS_str.format._template_resolve_fs_pat === undefined) {\n            RS_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n        }\n        return format_spec.replace(RS_str.format._template_resolve_fs_pat, (function() {\n            var RS_anonfunc = function (match, key) {\n                if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                    return "";\n                }\n                return "" + kwargs[(typeof key === "number" && key < 0) ? kwargs.length + key : key];\n            };\n            if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n                __argnames__ : {value: ["match", "key"]}\n            });\n            return RS_anonfunc;\n        })());\n    };\n    if (!resolve_format_spec.__argnames__) Object.defineProperties(resolve_format_spec, {\n        __argnames__ : {value: ["format_spec"]}\n    });\n\n    function set_comma(ans, comma) {\n        var sep;\n        if (comma !== ",") {\n            sep = 1234;\n            sep = sep.toLocaleString(undefined, {useGrouping: true})[1];\n            ans = str.replace(ans, sep, comma);\n        }\n        return ans;\n    };\n    if (!set_comma.__argnames__) Object.defineProperties(set_comma, {\n        __argnames__ : {value: ["ans", "comma"]}\n    });\n\n    function safe_comma(value, comma) {\n        try {\n            return set_comma(value.toLocaleString(undefined, {useGrouping: true}), comma);\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            {\n                return value.toString(10);\n            } \n        }\n    };\n    if (!safe_comma.__argnames__) Object.defineProperties(safe_comma, {\n        __argnames__ : {value: ["value", "comma"]}\n    });\n\n    function safe_fixed(value, precision, comma) {\n        if (!comma) {\n            return value.toFixed(precision);\n        }\n        try {\n            return set_comma(value.toLocaleString(undefined, {useGrouping: true, minimumFractionDigits: precision, maximumFractionDigits: precision}), comma);\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            {\n                return value.toFixed(precision);\n            } \n        }\n    };\n    if (!safe_fixed.__argnames__) Object.defineProperties(safe_fixed, {\n        __argnames__ : {value: ["value", "precision", "comma"]}\n    });\n\n    function apply_formatting(value, format_spec) {\n        var RS_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, prec, exp, nval, is_positive, left, right;\n        if (format_spec.indexOf("{") !== -1) {\n            format_spec = resolve_format_spec(format_spec);\n        }\n        if (RS_str.format._template_format_pat === undefined) {\n            RS_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?([,_])?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n        }\n        try {\n            RS_unpack = format_spec.match(RS_str.format._template_format_pat).slice(1);\nRS_unpack = RS_unpack_asarray(9, RS_unpack);\n            fill = RS_unpack[0];\n            align = RS_unpack[1];\n            sign = RS_unpack[2];\n            fhash = RS_unpack[3];\n            zeropad = RS_unpack[4];\n            width = RS_unpack[5];\n            comma = RS_unpack[6];\n            precision = RS_unpack[7];\n            ftype = RS_unpack[8];\n        } catch (RS_Exception) {\n            RS_last_exception = RS_Exception;\n            if (RS_Exception instanceof TypeError) {\n                return value;\n            } else {\n                throw RS_Exception;\n            }\n        }\n        if (zeropad) {\n            fill = fill || "0";\n            align = align || "=";\n        } else {\n            fill = fill || " ";\n            align = align || ">";\n        }\n        is_numeric = Number(value) === value;\n        is_int = is_numeric && value % 1 === 0;\n        precision = parseInt(precision, 10);\n        lftype = (ftype || "").toLowerCase();\n        if (ftype === "n") {\n            is_numeric = true;\n            if (is_int) {\n                if (comma) {\n                    throw new ValueError("Cannot specify \',\' with \'n\'");\n                }\n                value = parseInt(value, 10).toLocaleString();\n            } else {\n                value = parseFloat(value).toLocaleString();\n            }\n        } else if ([\'b\', \'c\', \'d\', \'o\', \'x\'].indexOf(lftype) !== -1) {\n            value = parseInt(value, 10);\n            is_numeric = true;\n            if (!isNaN(value)) {\n                if (ftype === "b") {\n                    value = (value >>> 0).toString(2);\n                    if (fhash) {\n                        value = "0b" + value;\n                    }\n                } else if (ftype === "c") {\n                    if (value > 65535) {\n                        code = value - 65536;\n                        value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    } else {\n                        value = String.fromCharCode(value);\n                    }\n                } else if (ftype === "d") {\n                    if (comma) {\n                        value = safe_comma(value, comma);\n                    } else {\n                        value = value.toString(10);\n                    }\n                } else if (ftype === "o") {\n                    value = value.toString(8);\n                    if (fhash) {\n                        value = "0o" + value;\n                    }\n                } else if (lftype === "x") {\n                    value = value.toString(16);\n                    value = (ftype === "x") ? value.toLowerCase() : value.toUpperCase();\n                    if (fhash) {\n                        value = "0x" + value;\n                    }\n                }\n            }\n        } else if ([\'e\',\'f\',\'g\',\'%\'].indexOf(lftype) !== -1) {\n            is_numeric = true;\n            value = parseFloat(value);\n            prec = (isNaN(precision)) ? 6 : precision;\n            if (lftype === "e") {\n                value = value.toExponential(prec);\n                value = (ftype === "E") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === "f") {\n                value = safe_fixed(value, prec, comma);\n                value = (ftype === "F") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === "%") {\n                value *= 100;\n                value = safe_fixed(value, prec, comma) + "%";\n            } else if (lftype === "g") {\n                prec = max(1, prec);\n                exp = parseInt(split(value.toExponential(prec - 1).toLowerCase(), "e")[1], 10);\n                if (-4 <= exp && exp < prec) {\n                    value = safe_fixed(value, prec - 1 - exp, comma);\n                } else {\n                    value = value.toExponential(prec - 1);\n                }\n                value = value.replace(/0+$/g, "");\n                if (value[value.length-1] === ".") {\n                    value = value.slice(0, -1);\n                }\n                if (ftype === "G") {\n                    value = value.toUpperCase();\n                }\n            }\n        } else {\n            if (comma) {\n                value = parseInt(value, 10);\n                if (isNaN(value)) {\n                    throw new ValueError("Must use numbers with , or _");\n                }\n                value = safe_comma(value, comma);\n            }\n            value += "";\n            if (!isNaN(precision)) {\n                value = value.slice(0, precision);\n            }\n        }\n        value += "";\n        if (is_numeric && sign) {\n            nval = Number(value);\n            is_positive = !isNaN(nval) && nval >= 0;\n            if (is_positive && (sign === " " || sign === "+")) {\n                value = sign + value;\n            }\n        }\n        function repeat(char, num) {\n            return (new Array(num+1)).join(char);\n        };\n        if (!repeat.__argnames__) Object.defineProperties(repeat, {\n            __argnames__ : {value: ["char", "num"]}\n        });\n\n        if (is_numeric && width && width[0] === "0") {\n            width = width.slice(1);\n            RS_unpack = ["0", "="];\n            fill = RS_unpack[0];\n            align = RS_unpack[1];\n        }\n        width = parseInt(width || "-1", 10);\n        if (isNaN(width)) {\n            throw new ValueError("Invalid width specification: " + width);\n        }\n        if (fill && value.length < width) {\n            if (align === "<") {\n                value = value + repeat(fill, width - value.length);\n            } else if (align === ">") {\n                value = repeat(fill, width - value.length) + value;\n            } else if (align === "^") {\n                left = Math.floor((width - value.length) / 2);\n                right = width - left - value.length;\n                value = repeat(fill, left) + value + repeat(fill, right);\n            } else if (align === "=") {\n                if (RS_in(value[0], "+- ")) {\n                    value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                } else {\n                    value = repeat(fill, width - value.length) + value;\n                }\n            } else {\n                throw new ValueError("Unrecognized alignment: " + align);\n            }\n        }\n        return value;\n    };\n    if (!apply_formatting.__argnames__) Object.defineProperties(apply_formatting, {\n        __argnames__ : {value: ["value", "format_spec"]}\n    });\n\n    function parse_markup(markup) {\n        var key, transformer, format_spec, pos, state, ch;\n        key = transformer = format_spec = "";\n        pos = 0;\n        state = 0;\n        while (pos < markup.length) {\n            ch = markup[(typeof pos === "number" && pos < 0) ? markup.length + pos : pos];\n            if (state === 0) {\n                if (ch === "!") {\n                    state = 1;\n                } else if (ch === ":") {\n                    state = 2;\n                } else {\n                    key += ch;\n                }\n            } else if (state === 1) {\n                if (ch === ":") {\n                    state = 2;\n                } else {\n                    transformer += ch;\n                }\n            } else {\n                format_spec += ch;\n            }\n            pos += 1;\n        }\n        return [key, transformer, format_spec];\n    };\n    if (!parse_markup.__argnames__) Object.defineProperties(parse_markup, {\n        __argnames__ : {value: ["markup"]}\n    });\n\n    function render_markup(markup) {\n        var RS_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n        RS_unpack = parse_markup(markup);\nRS_unpack = RS_unpack_asarray(3, RS_unpack);\n        key = RS_unpack[0];\n        transformer = RS_unpack[1];\n        format_spec = RS_unpack[2];\n        if (transformer && [\'a\', \'r\', \'s\'].indexOf(transformer) === -1) {\n            throw new ValueError("Unknown conversion specifier: " + transformer);\n        }\n        lkey = key.length && split(key, /[.\\[]/, 1)[0];\n        if (lkey) {\n            explicit = true;\n            if (implicit) {\n                throw new ValueError("cannot switch from automatic field numbering to manual field specification");\n            }\n            nvalue = parseInt(lkey);\n            object = (isNaN(nvalue)) ? kwargs[(typeof lkey === "number" && lkey < 0) ? kwargs.length + lkey : lkey] : args[(typeof nvalue === "number" && nvalue < 0) ? args.length + nvalue : nvalue];\n            if (object === undefined) {\n                if (isNaN(nvalue)) {\n                    throw new KeyError(lkey);\n                }\n                throw new IndexError(lkey);\n            }\n            object = resolve(key.slice(lkey.length), object);\n        } else {\n            implicit = true;\n            if (explicit) {\n                throw new ValueError("cannot switch from manual field specification to automatic field numbering");\n            }\n            if (idx >= args.length) {\n                throw new IndexError("Not enough arguments to match template: " + template);\n            }\n            object = args[(typeof idx === "number" && idx < 0) ? args.length + idx : idx];\n            idx += 1;\n        }\n        if (typeof object === "function") {\n            object = object();\n        }\n        ans = "" + object;\n        if (format_spec) {\n            ans = apply_formatting(ans, format_spec);\n        }\n        return ans;\n    };\n    if (!render_markup.__argnames__) Object.defineProperties(render_markup, {\n        __argnames__ : {value: ["markup"]}\n    });\n\n    ans = "";\n    pos = 0;\n    in_brace = 0;\n    markup = "";\n    while (pos < template.length) {\n        ch = template[(typeof pos === "number" && pos < 0) ? template.length + pos : pos];\n        if (in_brace) {\n            if (ch === "{") {\n                in_brace += 1;\n                markup += "{";\n            } else if (ch === "}") {\n                in_brace -= 1;\n                if (in_brace > 0) {\n                    markup += "}";\n                } else {\n                    ans += render_markup(markup);\n                }\n            } else {\n                markup += ch;\n            }\n        } else {\n            if (ch === "{") {\n                if (template[RS_bound_index(pos + 1, template)] === "{") {\n                    pos += 1;\n                    ans += "{";\n                } else {\n                    in_brace = 1;\n                    markup = "";\n                }\n            } else {\n                ans += ch;\n                if (ch === "}" && template[RS_bound_index(pos + 1, template)] === "}") {\n                    pos += 1;\n                }\n            }\n        }\n        pos += 1;\n    }\n    if (in_brace) {\n        throw new ValueError("expected \'}\' before end of string");\n    }\n    return ans;\n});\ndefine_str_func("capitalize", function () {\n    var string;\n    string = this;\n    if (string) {\n        string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n    }\n    return string;\n});\ndefine_str_func("center", (function() {\n    var RS_anonfunc = function (width, fill) {\n        var left, right;\n        left = Math.floor((width - this.length) / 2);\n        right = width - left - this.length;\n        fill = fill || " ";\n        return new Array(left+1).join(fill) + this + new Array(right+1).join(fill);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width", "fill"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("count", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var string, RS_unpack, pos, step, ans;\n        string = this;\n        start = start || 0;\n        end = end || string.length;\n        if (start < 0 || end < 0) {\n            string = string.slice(start, end);\n            RS_unpack = [0, string.length];\n            start = RS_unpack[0];\n            end = RS_unpack[1];\n        }\n        pos = start;\n        step = needle.length;\n        if (!step) {\n            return 0;\n        }\n        ans = 0;\n        while (pos !== -1) {\n            pos = string.indexOf(needle, pos);\n            if (pos !== -1) {\n                ans += 1;\n                pos += step;\n            }\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("endswith", (function() {\n    var RS_anonfunc = function (suffixes, start, end) {\n        var string, q;\n        string = this;\n        start = start || 0;\n        if (typeof suffixes === "string") {\n            suffixes = [suffixes];\n        }\n        if (end !== undefined) {\n            string = string.slice(0, end);\n        }\n        for (var i = 0; i < suffixes.length; i++) {\n            q = suffixes[(typeof i === "number" && i < 0) ? suffixes.length + i : i];\n            if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["suffixes", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("startswith", (function() {\n    var RS_anonfunc = function (prefixes, start, end) {\n        var prefix;\n        start = start || 0;\n        if (typeof prefixes === "string") {\n            prefixes = [prefixes];\n        }\n        for (var i = 0; i < prefixes.length; i++) {\n            prefix = prefixes[(typeof i === "number" && i < 0) ? prefixes.length + i : i];\n            end = (end === undefined) ? this.length : end;\n            if (end - start >= prefix.length && prefix === this.slice(start, start + prefix.length)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["prefixes", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("find", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        while (start < 0) {\n            start += this.length;\n        }\n        ans = this.indexOf(needle, start);\n        if (end !== undefined && ans !== -1) {\n            while (end < 0) {\n                end += this.length;\n            }\n            if (ans >= end - needle.length) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rfind", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        while (end < 0) {\n            end += this.length;\n        }\n        ans = this.lastIndexOf(needle, end - 1);\n        if (start !== undefined && ans !== -1) {\n            while (start < 0) {\n                start += this.length;\n            }\n            if (ans < start) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("index", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = RS_str.prototype.find.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError("substring not found");\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rindex", (function() {\n    var RS_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = RS_str.prototype.rfind.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError("substring not found");\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["needle", "start", "end"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("islower", function () {\n    return this.length > 0 && this.toLowerCase() === this.toString();\n});\ndefine_str_func("isupper", function () {\n    return this.length > 0 && this.toUpperCase() === this.toString();\n});\ndefine_str_func("isspace", function () {\n    return this.length > 0 && /^\\s+$/.test(this);\n});\ndefine_str_func("join", (function() {\n    var RS_anonfunc = function (iterable) {\n        var ans, r;\n        if (Array.isArray(iterable)) {\n            return iterable.join(this);\n        }\n        ans = "";\n        r = iterable.next();\n        while (!r.done) {\n            if (ans) {\n                ans += this;\n            }\n            ans += r.value;\n            r = iterable.next();\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["iterable"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("ljust", (function() {\n    var RS_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || " ";\n            string += new Array(width - string.length + 1).join(fill);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width", "fill"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rjust", (function() {\n    var RS_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || " ";\n            string = new Array(width - string.length + 1).join(fill) + string;\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width", "fill"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("lower", function () {\n    return this.toLowerCase();\n});\ndefine_str_func("upper", function () {\n    return this.toUpperCase();\n});\ndefine_str_func("lstrip", (function() {\n    var RS_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = 0;\n        chars = chars || RS_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === "number" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos += 1;\n        }\n        if (pos) {\n            string = string.slice(pos);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["chars"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rstrip", (function() {\n    var RS_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = string.length - 1;\n        chars = chars || RS_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === "number" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos -= 1;\n        }\n        if (pos < string.length - 1) {\n            string = string.slice(0, pos + 1);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["chars"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("strip", (function() {\n    var RS_anonfunc = function (chars) {\n        return RS_str.prototype.lstrip.call(RS_str.prototype.rstrip.call(this, chars), chars);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["chars"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("partition", (function() {\n    var RS_anonfunc = function (sep) {\n        var idx;\n        idx = this.indexOf(sep);\n        if (idx === -1) {\n            return [this, "", ""];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rpartition", (function() {\n    var RS_anonfunc = function (sep) {\n        var idx;\n        idx = this.lastIndexOf(sep);\n        if (idx === -1) {\n            return ["", "", this];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("replace", (function() {\n    var RS_anonfunc = function (old, repl, count) {\n        var string, pos, idx;\n        string = this;\n        if (count === 1) {\n            return RS_orig_replace(string, old, repl);\n        }\n        if (count < 1) {\n            return string;\n        }\n        count = count || Number.MAX_VALUE;\n        pos = 0;\n        while (count > 0) {\n            count -= 1;\n            idx = string.indexOf(old, pos);\n            if (idx === -1) {\n                break;\n            }\n            pos = idx + repl.length;\n            string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["old", "repl", "count"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("split", (function() {\n    var RS_anonfunc = function (sep, maxsplit) {\n        var split, ans, extra, parts;\n        if (maxsplit === 0) {\n            return RS_list_decorate([ this ]);\n        }\n        split = RS_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = split(this, /(\\s+)/);\n                extra = "";\n                parts = [];\n                for (var i = 0; i < ans.length; i++) {\n                    if (parts.length >= maxsplit + 1) {\n                        extra += ans[(typeof i === "number" && i < 0) ? ans.length + i : i];\n                    } else if (i % 2 === 0) {\n                        parts.push(ans[(typeof i === "number" && i < 0) ? ans.length + i : i]);\n                    }\n                }\n                parts[parts.length-1] += extra;\n                ans = parts;\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === "") {\n                throw new ValueError("empty separator");\n            }\n            ans = split(this, sep);\n            if (maxsplit > 0 && ans.length > maxsplit) {\n                extra = ans.slice(maxsplit).join(sep);\n                ans = ans.slice(0, maxsplit);\n                ans.push(extra);\n            }\n        }\n        return RS_list_decorate(ans);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep", "maxsplit"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("rsplit", (function() {\n    var RS_anonfunc = function (sep, maxsplit) {\n        var split, ans, is_space, pos, current, spc, ch, end, idx;\n        if (!maxsplit) {\n            return RS_str.prototype.split.call(this, sep);\n        }\n        split = RS_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = [];\n                is_space = /\\s/;\n                pos = this.length - 1;\n                current = "";\n                while (pos > -1 && maxsplit > 0) {\n                    spc = false;\n                    ch = (RS_expr_temp = this)[(typeof pos === "number" && pos < 0) ? RS_expr_temp.length + pos : pos];\n                    while (pos > -1 && is_space.test(ch)) {\n                        spc = true;\n                        ch = this[--pos];\n                    }\n                    if (spc) {\n                        if (current) {\n                            ans.push(current);\n                            maxsplit -= 1;\n                        }\n                        current = ch;\n                    } else {\n                        current += ch;\n                    }\n                    pos -= 1;\n                }\n                ans.push(this.slice(0, pos + 1) + current);\n                ans.reverse();\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === "") {\n                throw new ValueError("empty separator");\n            }\n            ans = [];\n            pos = end = this.length;\n            while (pos > -1 && maxsplit > 0) {\n                maxsplit -= 1;\n                idx = this.lastIndexOf(sep, pos);\n                if (idx === -1) {\n                    break;\n                }\n                ans.push(this.slice(idx + sep.length, end));\n                pos = idx - 1;\n                end = idx;\n            }\n            ans.push(this.slice(0, end));\n            ans.reverse();\n        }\n        return RS_list_decorate(ans);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["sep", "maxsplit"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("splitlines", (function() {\n    var RS_anonfunc = function (keepends) {\n        var split, parts, ans;\n        split = RS_orig_split;\n        if (keepends) {\n            parts = split(this, /((?:\\r?\\n)|\\r)/);\n            ans = [];\n            for (var i = 0; i < parts.length; i++) {\n                if (i % 2 === 0) {\n                    ans.push(parts[(typeof i === "number" && i < 0) ? parts.length + i : i]);\n                } else {\n                    ans[ans.length-1] += parts[(typeof i === "number" && i < 0) ? parts.length + i : i];\n                }\n            }\n        } else {\n            ans = split(this, /(?:\\r?\\n)|\\r/);\n        }\n        return RS_list_decorate(ans);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["keepends"]}\n    });\n    return RS_anonfunc;\n})());\ndefine_str_func("swapcase", function () {\n    var ans, a, b;\n    ans = new Array(this.length);\n    for (var i = 0; i < ans.length; i++) {\n        a = (RS_expr_temp = this)[(typeof i === "number" && i < 0) ? RS_expr_temp.length + i : i];\n        b = a.toLowerCase();\n        if (a === b) {\n            b = a.toUpperCase();\n        }\n        ans[(typeof i === "number" && i < 0) ? ans.length + i : i] = b;\n    }\n    return ans.join("");\n});\ndefine_str_func("zfill", (function() {\n    var RS_anonfunc = function (width) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            string = new Array(width - string.length + 1).join("0") + string;\n        }\n        return string;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["width"]}\n    });\n    return RS_anonfunc;\n})());\nRS_str.uchrs = (function() {\n    var RS_anonfunc = function (string, with_positions) {\n        return (function(){\n            var RS_d = {};\n            RS_d["_string"] = string;\n            RS_d["_pos"] = 0;\n            RS_d[RS_iterator_symbol] = function () {\n                return this;\n            };\n            RS_d["next"] = function () {\n                var length, pos, value, ans, extra;\n                length = this._string.length;\n                if (this._pos >= length) {\n                    return (function(){\n                        var RS_d = {};\n                        RS_d["done"] = true;\n                        return RS_d;\n                    }).call(this);\n                }\n                pos = this._pos;\n                value = this._string.charCodeAt(this._pos++);\n                ans = "\\ufffd";\n                if (55296 <= value && value <= 56319) {\n                    if (this._pos < length) {\n                        extra = this._string.charCodeAt(this._pos++);\n                        if ((extra & 56320) === 56320) {\n                            ans = String.fromCharCode(value, extra);\n                        }\n                    }\n                } else if ((value & 56320) !== 56320) {\n                    ans = String.fromCharCode(value);\n                }\n                if (with_positions) {\n                    return (function(){\n                        var RS_d = {};\n                        RS_d["done"] = false;\n                        RS_d["value"] = RS_list_decorate([ pos, ans ]);\n                        return RS_d;\n                    }).call(this);\n                } else {\n                    return (function(){\n                        var RS_d = {};\n                        RS_d["done"] = false;\n                        RS_d["value"] = ans;\n                        return RS_d;\n                    }).call(this);\n                }\n            };\n            return RS_d;\n        }).call(this);\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["string", "with_positions"]}\n    });\n    return RS_anonfunc;\n})();\nRS_str.uslice = (function() {\n    var RS_anonfunc = function (string, start, end) {\n        var items, iterator, r;\n        items = [];\n        iterator = RS_str.uchrs(string);\n        r = iterator.next();\n        while (!r.done) {\n            items.push(r.value);\n            r = iterator.next();\n        }\n        return items.slice(start || 0, (end === undefined) ? items.length : end).join("");\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["string", "start", "end"]}\n    });\n    return RS_anonfunc;\n})();\nRS_str.ulen = (function() {\n    var RS_anonfunc = function (string) {\n        var iterator, r, ans;\n        iterator = RS_str.uchrs(string);\n        r = iterator.next();\n        ans = 0;\n        while (!r.done) {\n            r = iterator.next();\n            ans += 1;\n        }\n        return ans;\n    };\n    if (!RS_anonfunc.__argnames__) Object.defineProperties(RS_anonfunc, {\n        __argnames__ : {value: ["string"]}\n    });\n    return RS_anonfunc;\n})();\nRS_str.ascii_lowercase = "abcdefghijklmnopqrstuvwxyz";\nRS_str.ascii_uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";\nRS_str.ascii_letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";\nRS_str.digits = "0123456789";\nRS_str.punctuation = "!\\"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~";\nRS_str.printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\"#$%&\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f";\nRS_str.whitespace = " \\t\\n\\r\\u000b\\f";\ndefine_str_func = undefined;\nvar str = RS_str, repr = RS_repr;',"tools/web_repl.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\nvar vm = require('vm');\nvar embedded_compiler = require('tools/embedded_compiler.js');\n\nmodule.exports = function(compiler, baselib) {\n    var ctx = vm.createContext();\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    var find_completions = null;\n    var streaming_compiler = embedded_compiler(compiler, baselib, function(js) { return vm.runInContext(js, ctx); }, '__repl__');\n\n    return {\n        'in_block_mode': false,\n\n        'replace_print': function replace_print(write_line_func) {\n            ctx.print = function() {\n                var parts = [];\n                for (var i = 0; i < arguments.length; i++) \n                    parts.push(ctx.RS_str(arguments[i]));\n                write_line_func(parts.join(' '));\n            };\n        },\n\n        'is_input_complete': function is_input_complete(source) {\n            if (!source || !source.trim()) return false;\n            var lines = source.split('\\n');\n            var last_line = lines[lines.length - 1].trimRight();\n            if (this.in_block_mode) {\n                // In a block only exit after two blank lines\n                if (lines.length < 2) return false;\n                var second_last_line = lines[lines.length - 2].trimRight();\n                var block_ended = !!(!last_line && !second_last_line);\n                if (!block_ended) return false;\n                this.in_block_mode = false;\n                return true;\n            }\n\n            if (last_line && LINE_CONTINUATION_CHARS.indexOf(last_line.substr(last_line.length - 1)) > -1) {\n                this.in_block_mode = true;\n                return false;\n            }\n            try {\n                compiler.parse(source, {'filename': '<repl>', 'basedir': '__stdlib__'});\n            } catch(e) {\n                if (e.is_eof && e.line === lines.length && e.col > 0) {\n                    return false;\n                }\n                this.in_block_mode = false;\n                return true;\n            }\n            this.in_block_mode = false;\n            return true;\n        },\n\n        'compile': function web_repl_compile(code, opts) {\n            opts = opts || {};\n            opts.keep_docstrings = true;\n            opts.filename = '<input>';\n            return streaming_compiler.compile(code, opts);\n        },\n\n        'runjs': function runjs(code) {\n            var ans = vm.runInContext(code, ctx);\n            if (ans !== undefined || ans === null) {\n                ctx.RS_repl_val = ans;\n                var q = vm.runInContext('RS_repr(RS_repl_val)', ctx);\n                ans = (q === 'undefined') ? ans.toString() : q;\n            }\n            return ans;\n        },\n\n        'init_completions': function init_completions(completelib) {\n            find_completions = completelib(compiler);\n        },\n\n        'find_completions': function find_completions_(line) {\n            return find_completions(line, ctx);\n        },\n\n    };\n};\n\n","tools/embedded_compiler.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\nvar has_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nmodule.exports = function(compiler, baselib, runjs, name) {\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    runjs = runjs || eval;\n    runjs(print_ast(compiler.parse(''), true));\n    runjs('var __name__ = \"' + (name || '__embedded__') + '\";');\n\n    function print_ast(ast, keep_baselib, keep_docstrings, js_version) {\n        var output_options = {omit_baselib:!keep_baselib, write_name:false, private_scope:false, beautify:true, js_version: (js_version || 6), keep_docstrings:keep_docstrings};\n        if (keep_baselib) output_options.baselib_plain = baselib;\n        var output = new compiler.OutputStream(output_options);\n        ast.print(output);\n        return output.get();\n    }\n\n    return {\n        'toplevel': null,\n\n        'compile': function streaming_compile(code, opts) {\n            opts = opts || {};\n            var classes = (this.toplevel) ? this.toplevel.classes : undefined;\n            var scoped_flags = (this.toplevel) ? this.toplevel.scoped_flags: undefined;\n            this.toplevel = compiler.parse(code, {\n                'filename': opts.filename || '<embedded>',\n                'basedir': '__stdlib__',\n                'classes': classes,\n                'scoped_flags': scoped_flags,\n                'discard_asserts': opts.discard_asserts,\n            });\n            var ans = print_ast(this.toplevel, false, opts.keep_docstrings, opts.js_version);\n            if (classes) {\n                var exports = {};\n                var self = this;\n                this.toplevel.exports.forEach(function (name) { exports[name] = true; });\n                Object.getOwnPropertyNames(classes).forEach(function (name) {\n                    if (!has_prop(exports, name) && !has_prop(self.toplevel.classes, name))\n                        self.toplevel.classes[name] = classes[name];\n                });\n            }\n            scoped_flags = this.toplevel.scoped_flags;\n    \n            return ans;\n        },\n\n    };\n};\n\n","tools/utils.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\nvar comment_contents = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)[ \\t]*\\*\\//;\nvar colors = ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];\n\nfunction ansi(code) {\n    code = code || 0;\n    return String.fromCharCode(27) + '[' + code + 'm';\n}\n\nfunction path_exists(path) {\n    var fs = require('fs');\n    try {\n        fs.statSync(path);\n        return true;\n    } catch(e) {\n        if (e.code != 'ENOENT') throw e;\n    }\n}\n\nfunction colored(string, color, bold) {\n    var prefix = [];\n    if (bold) prefix.push(ansi(1));\n    if (color) prefix.push(ansi(colors.indexOf(color) + 31));\n    return prefix.join('') + string + ansi(0);\n}\n\nfunction supports_color(stdout) {\n    stdout = stdout || process.stdout;\n\tif (stdout && !stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn false;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n    return false;\n\n}\n\nfunction safe_colored(string) {\n    return string;\n}\n\nfunction repeat(str, num) {\n    return new Array( num + 1 ).join( str );\n}\n\nfunction generators_available() {\n    var gen;\n    try {\n        eval('gen = function *(){}'); // jshint ignore:line\n        return typeof gen === 'function' && gen.constructor.name == 'GeneratorFunction';\n    } catch(e) {\n        return false;\n    }\n}\n\nfunction wrap(lines, width) {\n\tvar ans = [];\n\tvar prev = '';\n\tlines.forEach(function (line) {\n\t\tline = prev + line;\n\t\tprev = '';\n\t\tif (line.length > width) {\n\t\t\tprev = line.substr(width);\n            if (prev) prev += ' ';\n\t\t\tline = line.substr(0, width - 1);\n\t\t\tif (line.substr(line.length - 1 !== ' ')) line += '-';\n\t\t} \n\t\tans.push(line);\n\t});\n\tif (prev) ans = ans.concat(wrap([prev]));\n\treturn ans;\n}\n\nfunction merge() {\n    // Simple merge of properties from all objects\n    var ans = {};\n    Array.prototype.slice.call(arguments).forEach(function (arg) {\n        Object.keys(arg).forEach(function(key) {\n            ans[key] = arg[key];\n        });\n    });\n    return ans;\n}\n\nfunction get_import_dirs(paths_string, ignore_env) {\n    var path = require('path');\n    var paths = [];\n    function merge(new_path) {\n        if (paths.indexOf(new_path) == -1) paths.push(new_path);\n    }\n    if (!ignore_env && process && process.env && process.env.RAPYDSCRIPT_IMPORT_PATH) {\n        process.env.RAPYDSCRIPT_IMPORT_PATH.split(path.delimiter).forEach(merge);\n    }\n    if (paths_string) paths_string.split(path.delimiter).forEach(merge);\n    return paths;\n}\n\nexports.comment_contents = comment_contents;\nexports.repeat = repeat;\nexports.wrap = wrap;\nexports.merge = merge;\nexports.colored = colored;\nexports.safe_colored = (supports_color()) ? colored : safe_colored;\nexports.generators_available = generators_available;\nexports.get_import_dirs = get_import_dirs;\nexports.path_exists = path_exists;\n","tools/completer.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\n\nmodule.exports = function(compiler, options) {\n    \"use strict\";\n    var all_keywords = compiler.ALL_KEYWORDS.split(' ');\n    var vm = require('vm');\n    options = options || {};\n    if (!options.enum_global) options.enum_global = \"var global = Function('return this')(); Object.getOwnPropertyNames(global);\";\n\n    function global_names(ctx) {\n        try {\n            var ans = vm.runInContext(options.enum_global, ctx);\n            ans = ans.concat(all_keywords);\n            ans.sort();\n            var seen = {};\n            ans.filter(function (item) { \n                if (Object.prototype.hasOwnProperty.call(seen, item)) return false;\n                seen[item] = true;\n                return true;\n            });\n            return ans;\n        } catch(e) {\n            console.log(e.stack || e.toString());\n        }\n        return [];\n    }\n\n    function object_names(obj, prefix) {\n        if (obj === null || obj === undefined) return [];\n        var groups = [], prefix_len = prefix.length, p;\n\n        function prefix_filter(name) { return (prefix_len) ? (name.substr(0, prefix_len) === prefix) : true; }\n\n        function add(o) {\n            var items = Object.getOwnPropertyNames(o).filter(prefix_filter);\n            if (items.length) groups.push(items);\n        }\n\n        if (typeof obj === 'object' || typeof obj === 'function') {\n            add(obj);\n            p = Object.getPrototypeOf(obj);\n        } else p = obj.constructor ? obj.constructor.prototype : null; \n\n        // Walk the prototype chain\n        try {\n            var sentinel = 5;\n            while (p !== null && sentinel > 0) {\n                add(p);\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n            }\n        } catch (e) {\n            // console.error(\"completion error walking prototype chain:\" + e);\n        }\n        if (!groups.length) return [];\n        var seen = {}, ans = [];\n        function uniq(name) {\n            if (Object.prototype.hasOwnProperty.call(seen, name)) return false;\n            seen[name] = true;\n            return true;\n        }\n        for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n            group.sort();\n            ans = ans.concat(group.filter(uniq));\n            ans.push('');  // group separator\n\n        }\n        while (ans.length && ans[ans.length - 1] === '') ans.pop();\n        return ans;\n    }\n\n    function prefix_matches(prefix, items) {\n        var len = prefix.length;\n        var ans = items.filter(function(item) { return item.substr(0, len) === prefix; });\n        ans.sort();\n        return ans;\n    }\n\n    function find_completions(line, ctx) {\n        var t;\n        try {\n            t = compiler.tokenizer(line, '<repl>');\n        } catch(e) { return []; }\n        var tokens = [], token;\n        while (true) {\n            try {\n                token = t();\n            } catch (e) { return []; }\n            if (token.type === 'eof') break;\n            if (token.type === 'punc' && '(){},;:'.indexOf(token.value) > -1)\n                tokens = [];\n            tokens.push(token);\n        }\n        if (!tokens.length) {\n            // New line or trailing space\n            return [global_names(ctx), ''];\n        }\n        var last_tok = tokens[tokens.length - 1];\n        if (last_tok.value === '.' || (last_tok.type === 'name' && compiler.IDENTIFIER_PAT.test(last_tok.value))) {\n            last_tok = last_tok.value;\n            if (last_tok === '.') {\n                tokens.push({'value':''});\n                last_tok = '';\n            }\n            if (tokens.length > 1 && tokens[tokens.length - 2].value === '.') {\n                // A compound expression\n                var prefix = '', result;\n                tokens.slice(0, tokens.length - 2).forEach(function (tok) { prefix += tok.value; });\n                if (prefix) {\n                    try {\n                        result = vm.runInContext(prefix, ctx, {'displayErrors':false});\n                    } catch(e) { return []; }\n                    return [object_names(result, last_tok), last_tok];\n                }\n            } else {\n                return [prefix_matches(last_tok, global_names(ctx)), last_tok];\n            }\n        }\n        return [];\n    }\n\n    return find_completions;\n};\n","__stdlib__/aes.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n\n# globals: crypto\n\n# Internal API {{{\n\ndef string_to_bytes_encoder(string):\n    return TextEncoder('utf-8').encode(string + '')\n\ndef string_to_bytes_slow(string):\n    escstr = encodeURIComponent(string)\n    binstr = escstr.replace(/%([0-9A-F]{2})/g, def(match, p1):\n        return String.fromCharCode('0x' + p1)\n    )\n    ua = Uint8Array(binstr.length)\n    for i, ch in enumerate(binstr):\n        ua[i] = ch.charCodeAt(0)\n    return ua\n\ndef as_hex(array, sep=''):\n    num = array.BYTES_PER_ELEMENT or 1\n    fmt = '{:0' + num * 2 + 'x}'\n    return [str.format(fmt, x) for x in array].join(sep)\n\ndef bytes_to_string_decoder(bytes, offset):\n    offset = offset or 0\n    if offset:\n        bytes = bytes.subarray(offset)\n    return TextDecoder('utf-8').decode(bytes)\n\ndef bytes_to_string_slow(bytes, offset):\n    ans = v'[]'\n    i = offset or 0\n    while i < bytes.length:\n        c = bytes[i]\n        if c < 128:\n            ans.push(String.fromCharCode(c))\n            i += 1\n        elif 191 < c < 224:\n            ans.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)))\n            i += 2\n        else:\n            ans.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)))\n            i += 3\n    return ans.join('')\n\nstring_to_bytes = string_to_bytes_encoder if jstype(TextEncoder) is 'function' else string_to_bytes_slow\nbytes_to_string = bytes_to_string_decoder if jstype(TextDecoder) is 'function' else bytes_to_string_slow\n\ndef increment_counter(c):\n    # c must be a Uint8Array of length 16\n    for v'var i = 15; i >= 12; i--':\n        if c[i] is 255:\n            c[i] = 0\n        else:\n            c[i] += 1\n            break\n\ndef convert_to_int32(bytes, output, offset, length):\n    offset = offset or 0\n    length = length or bytes.length\n    for v'var i = offset, j = 0; i < offset + length; i += 4, j++':\n        output[j] = (bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] <<  8) | bytes[i + 3]\n\ndef convert_to_int32_pad(bytes):\n    extra = bytes.length % 4\n    if extra:\n        t = Uint8Array(bytes.length + 4 - extra)\n        t.set(bytes)\n        bytes = t\n    ans = Uint32Array(bytes.length / 4)\n    convert_to_int32(bytes, ans)\n    return ans\n\nif not Uint8Array.prototype.fill:\n    Uint8Array.prototype.fill = Uint32Array.prototype.fill = def(val, start, end):\n        start = start or 0\n        if end is undefined:\n            end = this.length\n        if start < 0:\n            start += this.length\n        if end < 0:\n            end += this.length\n        for v'var i = start; i < end; i++':\n            this[i] = val\n\ndef from_64_to_32(num):\n  # convert 64-bit number to two BE Int32s\n  ans = Uint32Array(2)\n  ans[0] = (num / 0x100000000) | 0\n  ans[1] = num & 0xFFFFFFFF\n  return ans\n\n# Lookup tables for AES {{{\n# Number of rounds by keysize\nnumber_of_rounds = {16: 10, 24: 12, 32: 14}\n# Round constant words\nrcon = v'new Uint32Array([0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91])'\n\n# S-box and Inverse S-box (S is for Substitution)\nS = v'new Uint32Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16])'\nSi = v'new Uint32Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d])'\n\n# Transformations for encryption\nT1 = v'new Uint32Array([0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a])'\nT2 = v'new Uint32Array([0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616])'\nT3 = v'new Uint32Array([0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16])'\nT4 = v'new Uint32Array([0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c])'\n\n# Transformations for decryption\nT5 = v'new Uint32Array([0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742])'\nT6 = v'new Uint32Array([0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857])'\nT7 = v'new Uint32Array([0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8])'\nT8 = v'new Uint32Array([0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0])'\n\n# Transformations for decryption key expansion\nU1 = v'new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3])'\nU2 = v'new Uint32Array([0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697])'\nU3 = v'new Uint32Array([0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46])'\nU4 = v'new Uint32Array([0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d])'\n\n# }}}\n\nclass AES: # {{{\n\n    def __init__(self, key):\n        self.working_mem = [Uint32Array(4), Uint32Array(4)]\n        rounds = number_of_rounds[key.length]\n        if not rounds:\n            raise ValueError('invalid key size (must be length 16, 24 or 32)')\n\n        # encryption round keys\n        self._Ke = v'[]'\n\n        # decryption round keys\n        self._Kd = v'[]'\n\n        for v'var i = 0; i <= rounds; i++':\n            self._Ke.push(Uint32Array(4))\n            self._Kd.push(Uint32Array(4))\n\n        round_key_count = (rounds + 1) * 4\n        KC = key.length / 4\n\n        # convert the key into ints\n        tk = Uint32Array(KC)\n        convert_to_int32(key, tk)\n\n        # copy values into round key arrays\n        index = 0\n        for v'var i = 0; i < KC; i++':\n            index = i >> 2\n            self._Ke[index][i % 4] = tk[i]\n            self._Kd[rounds - index][i % 4] = tk[i]\n\n        # key expansion (fips-197 section 5.2)\n        rconpointer = 0\n        t = KC\n        while t < round_key_count:\n            tt = tk[KC - 1]\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n                      (S[(tt >>  8) & 0xFF] << 16) ^\n                      (S[ tt        & 0xFF] <<  8) ^\n                       S[(tt >> 24) & 0xFF]        ^\n                      (rcon[rconpointer] << 24))\n            rconpointer += 1\n\n            # key expansion (for non-256 bit)\n            if KC != 8:\n                for v'var i = 1; i < KC; i++':\n                    tk[i] ^= tk[i - 1]\n\n            # key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            else:\n                for v'var i = 1; i < (KC / 2); i++':\n                    tk[i] ^= tk[i - 1]\n                tt = tk[(KC / 2) - 1]\n\n                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n                              (S[(tt >>  8) & 0xFF] <<  8) ^\n                              (S[(tt >> 16) & 0xFF] << 16) ^\n                              (S[(tt >> 24) & 0xFF] << 24))\n\n                for v'var i = (KC / 2) + 1; i < KC; i++':\n                    tk[i] ^= tk[i - 1]\n\n            # copy values into round key arrays\n            i = 0\n            while i < KC and t < round_key_count:\n                r = t >> 2\n                c = t % 4\n                self._Ke[r][c] = tk[i]\n                self._Kd[rounds - r][c] = tk[v'i++']\n                t += 1\n\n        # inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for v'var r = 1; r < rounds; r++':\n            for v'var c = 0; c < 4; c++':\n                tt = self._Kd[r][c]\n                self._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n                                  U2[(tt >> 16) & 0xFF] ^\n                                  U3[(tt >>  8) & 0xFF] ^\n                                  U4[ tt        & 0xFF])\n\n    def _crypt(self, ciphertext, offset, encrypt):\n        if encrypt:\n            R1 = T1; R2 = T2; R3 = T3; R4 = T4\n            o1 = 1; o3 = 3\n            SB = S\n            K = self._Ke\n        else:\n            R1 = T5; R2 = T6; R3 = T7; R4 = T8\n            o1 = 3; o3 = 1\n            SB = Si\n            K = self._Kd\n        rounds = K.length - 1\n        a = self.working_mem[0]\n        t = self.working_mem[1]\n\n        # XOR plaintext with key\n        for v'var i = 0; i < 4; i++':\n            t[i] ^= K[0][i]\n\n        # apply round transforms\n        for v'var r = 1; r < rounds; r++':\n            for v'var i = 0; i < 4; i++':\n                a[i] = (R1[(t[i] >> 24) & 0xff] ^\n                        R2[(t[(i + o1) % 4] >> 16) & 0xff] ^\n                        R3[(t[(i +  2) % 4] >>  8) & 0xff] ^\n                        R4[ t[(i + o3) % 4]        & 0xff] ^\n                        K[r][i])\n            t.set(a)\n\n        # the last round is special\n        for v'var i = 0; i < 4; i++':\n            tt = K[rounds][i]\n            ciphertext[offset + 4 * i] = (SB[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff\n            ciphertext[offset + 4 * i + 1] = (SB[(t[(i + o1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff\n            ciphertext[offset + 4 * i + 2] = (SB[(t[(i +  2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff\n            ciphertext[offset + 4 * i + 3] = (SB[ t[(i + o3) % 4]        & 0xff] ^  tt       ) & 0xff\n\n    def encrypt(self, plaintext, ciphertext, offset):\n        convert_to_int32(plaintext, self.working_mem[1], offset, 16)\n        return self._crypt(ciphertext, offset, True)\n\n    def encrypt32(self, plaintext, ciphertext, offset):\n        self.working_mem[1].set(plaintext)\n        return self._crypt(ciphertext, offset, True)\n\n    def decrypt(self, ciphertext, plaintext, offset):\n        convert_to_int32(ciphertext, self.working_mem[1], offset, 16)\n        return self._crypt(plaintext, offset, False)\n\n    def decrypt32(self, ciphertext, plaintext, offset):\n        self.working_mem[1].set(ciphertext)\n        return self._crypt(plaintext, offset, False)\n# }}}\n\ndef random_bytes_insecure(sz):\n    ans = Uint8Array(sz)\n    for v'var i = 0; i < sz; i++':\n        ans[i] = Math.floor(Math.random() * 256)\n    return ans\n\ndef random_bytes_secure(sz):\n    ans = Uint8Array(sz)\n    crypto.getRandomValues(ans)\n    return ans\n\nrandom_bytes = random_bytes_secure if jstype(crypto) is not 'undefined' and jstype(crypto.getRandomValues) is 'function' else random_bytes_insecure\nif random_bytes is random_bytes_insecure:\n    try:\n        noderandom = require('crypto').randomBytes\n        random_bytes = def(sz):\n            return Uint8Array(noderandom(sz))\n    except:\n        print('WARNING: Using insecure RNG for AES')\n\nclass ModeOfOperation:  # {{{\n\n    def __init__(self, key):\n        self.key = key or generate_key(32)\n        self.aes = AES(self.key)\n\n    @property\n    def key_as_js(self):\n        return typed_array_as_js(self.key)\n\n    def tag_as_bytes(self, tag):\n        if isinstance(tag, Uint8Array):\n            return tag\n        if not tag:\n            return Uint8Array(0)\n        if jstype(tag) is 'string':\n            return string_to_bytes(tag)\n        raise TypeError('Invalid tag, must be a string or a Uint8Array')\n# }}}\n\nclass GaloisField:  # {{{\n\n    def __init__(self, sub_key):\n        k32 = Uint32Array(4)\n        convert_to_int32(sub_key, k32, 0)\n        self.m = self.generate_hash_table(k32)\n        self.wmem = Uint32Array(4)\n\n    def power(self, x, out):\n        lsb = x[3] & 1\n        for v'var i = 3; i > 0; --i':\n            out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31)\n        out[0] = x[0] >>> 1\n        if lsb:\n            out[0] ^= 0xE1000000\n\n    def multiply(self, x, y):\n        z_i = Uint32Array(4)\n        v_i = Uint32Array(y)\n        for v'var i = 0; i < 128; ++i':\n            x_i = x[(i / 32) | 0] & (1 << (31 - i % 32))\n            if x_i:\n                z_i[0] ^= v_i[0]\n                z_i[1] ^= v_i[1]\n                z_i[2] ^= v_i[2]\n                z_i[3] ^= v_i[3]\n            self.power(v_i, v_i)\n        return z_i\n\n    def generate_sub_hash_table(self, mid):\n        bits = mid.length\n        size = 1 << bits\n        half = size >>> 1\n        m = Array(size)\n        m[half] = Uint32Array(mid)\n        i = half >>> 1\n        while i > 0:\n            m[i] = Uint32Array(4)\n            self.power(m[2 * i], m[i])\n            i >>= 1\n        i = 2\n        while i < half:\n            for v'var j = 1; j < i; ++j':\n                m_i = m[i]\n                m_j = m[j]\n                m[i + j] = x = Uint32Array(4)\n                for v'var c = 0; c < 4; c++':\n                    x[c] = m_i[c] ^ m_j[c]\n            i *= 2\n        m[0] = Uint32Array(4)\n        for v'i = half + 1; i < size; ++i':\n            x = m[i ^ half]\n            m[i] = y = Uint32Array(4)\n            for v'var c = 0; c < 4; c++':\n                y[c] = mid[c] ^ x[c]\n        return m\n\n    def generate_hash_table(self, key_as_int32_array):\n        bits = key_as_int32_array.length\n        multiplier = 8 / bits\n        per_int = 4 * multiplier\n        size = 16 * multiplier\n        ans = Array(size)\n        for v'var i =0; i < size; ++i':\n            tmp = Uint32Array(4)\n            idx = (i/ per_int) | 0\n            shft = ((per_int - 1 - (i % per_int)) * bits)\n            tmp[idx] = (1 << (bits - 1)) << shft\n            ans[i] = self.generate_sub_hash_table(self.multiply(tmp, key_as_int32_array))\n        return ans\n\n    def table_multiply(self, x):\n        z = Uint32Array(4)\n        for v'var i = 0; i < 32; ++i':\n            idx = (i / 8) | 0\n            x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF\n            ah = self.m[i][x_i]\n            z[0] ^= ah[0]\n            z[1] ^= ah[1]\n            z[2] ^= ah[2]\n            z[3] ^= ah[3]\n        return z\n\n    def ghash(self, x, y):\n        # Corresponds to the XOR + mult_H operation from the paper\n        z = self.wmem\n        z[0] = y[0] ^ x[0]\n        z[1] = y[1] ^ x[1]\n        z[2] = y[2] ^ x[2]\n        z[3] = y[3] ^ x[3]\n        return self.table_multiply(z)\n\n# }}}\n\n# }}}\n\ndef generate_key(sz):\n    if not number_of_rounds[sz]:\n        raise ValueError('Invalid key size, must be: 16, 24 or 32')\n    return random_bytes(sz)\n\ndef generate_tag(sz):\n    return random_bytes(sz or 32)\n\ndef typed_array_as_js(x):\n    name = x.constructor.name or 'Uint8Array'\n    return '(new ' + name + '(' + JSON.stringify(Array.prototype.slice.call(x)) + '))'\n\nclass CBC(ModeOfOperation):  # {{{\n\n    def encrypt_bytes(self, bytes, tag_bytes, iv):\n        iv = first_iv = iv or random_bytes(16)\n        mlen = bytes.length + tag_bytes.length\n        padsz = (16 - (mlen % 16)) % 16\n        inputbytes = Uint8Array(mlen + padsz)\n        if tag_bytes.length:\n            inputbytes.set(tag_bytes)\n        inputbytes.set(bytes, tag_bytes.length)\n\n        offset = 0\n        outputbytes = Uint8Array(inputbytes.length)\n        for v'var block = 0; block < inputbytes.length; block += 16':\n            if block > 0:\n                iv, offset = outputbytes, block - 16\n            for v'var i = 0; i < 16; i++':\n                inputbytes[block + i] ^= iv[offset + i]\n            self.aes.encrypt(inputbytes, outputbytes, block)\n        return {'iv':first_iv, 'cipherbytes':outputbytes}\n\n    def encrypt(self, plaintext, tag):\n        return self.encrypt_bytes(string_to_bytes(plaintext), self.tag_as_bytes(tag))\n\n    def decrypt_bytes(self, inputbytes, tag_bytes, iv):\n        offset = 0\n        outputbytes = Uint8Array(inputbytes.length)\n        for v'var block = 0; block < inputbytes.length; block += 16':\n            self.aes.decrypt(inputbytes, outputbytes, block)\n            if block > 0:\n                iv, offset = inputbytes, block - 16\n            for v'var i = 0; i < 16; i++':\n                outputbytes[block + i] ^= iv[offset + i]\n        for v'var i = 0; i < tag_bytes.length; i++':\n            if tag_bytes[i] != outputbytes[i]:\n                raise ValueError('Corrupt message')\n        outputbytes = outputbytes.subarray(tag_bytes.length)\n        return outputbytes\n\n    def decrypt(self, output_from_encrypt, tag):\n        ans = self.decrypt_bytes(output_from_encrypt.cipherbytes, self.tag_as_bytes(tag), output_from_encrypt.iv)\n        return str.rstrip(bytes_to_string(ans), '\\0')\n# }}}\n\nclass CTR(ModeOfOperation):  # {{{\n\n    # Note that this mode of operation requires the pair of (counterbytes,\n    # secret key) to always be unique, for every block. Therefore, if you are\n    # using it for bi-directional messaging it is best to use a different\n    # secret key for each direction\n\n    def __init__(self, key, iv):\n        ModeOfOperation.__init__(self, key)\n        self.wmem = Uint8Array(16)\n        self.counter_block = Uint8Array(iv or 16)\n        if self.counter_block.length != 16:\n            raise ValueError('iv must be 16 bytes long')\n        self.counter_index = 16\n\n    def _crypt(self, bytes):\n        for v'var i = 0; i < bytes.length; i++, self.counter_index++':\n            if self.counter_index is 16:\n                self.counter_index = 0\n                self.aes.encrypt(self.counter_block, self.wmem, 0)\n                increment_counter(self.counter_block)\n            bytes[i] ^= self.wmem[self.counter_index]\n        self.counter_index = 16\n\n    def encrypt(self, plaintext, tag):\n        outbytes = string_to_bytes(plaintext)\n        counterbytes = Uint8Array(self.counter_block)\n        if tag:\n            tag_bytes = self.tag_as_bytes(tag)\n            t = Uint8Array(outbytes.length + tag_bytes.length)\n            t.set(tag_bytes)\n            t.set(outbytes, tag_bytes.length)\n            outbytes = t\n        self._crypt(outbytes)\n        return {'cipherbytes':outbytes, 'counterbytes':counterbytes}\n\n    def __enter__(self):\n        self.before_index = self.counter_index\n        self.before_counter = Uint8Array(self.counter_block)\n\n    def __exit__(self):\n        self.counter_index = self.before_index\n        self.counter_block = self.before_counter\n\n    def decrypt(self, output_from_encrypt, tag):\n        b = Uint8Array(output_from_encrypt.cipherbytes)\n        with self:\n            self.counter_block = output_from_encrypt.counterbytes\n            self.counter_index = 16\n            self._crypt(b)\n        offset = 0\n        if tag:\n            tag_bytes = self.tag_as_bytes(tag)\n            for v'var i = 0; i < tag_bytes.length; i++':\n                if tag_bytes[i] != b[i]:\n                    raise ValueError('Corrupted message')\n            offset = tag_bytes.length\n        return bytes_to_string(b, offset)\n# }}}\n\nclass GCM(ModeOfOperation):  # {{{\n\n    # Note that this mode of operation requires the pair of (iv,\n    # secret key) to always be unique, for every message. Therefore, if you are\n    # using it for bi-directional messaging it is best to use a different\n    # secret key for each direction (you could also use random_key,\n    # but that has a non-zero probability of repeating keys).\n    # See http://web.cs.ucdavis.edu/~rogaway/ocb/gcm.pdf\n\n    def __init__(self, key, random_iv=False):\n        ModeOfOperation.__init__(self, key)\n        self.random_iv = random_iv\n        if not random_iv:\n            self.current_iv = Uint8Array(12)\n\n        # Generate the hash subkey\n        H = Uint8Array(16)\n        self.aes.encrypt(Uint8Array(16), H, 0)\n        self.galois = GaloisField(H)\n\n        # Working memory\n        self.J0 = Uint32Array(4)\n        self.wmem = Uint32Array(4)\n        self.byte_block = Uint8Array(16)\n\n    def increment_iv(self):\n        c = self.current_iv\n        for v'var i = 11; i >=0; i--':\n            if c[i] is 255:\n                if i is 0:\n                    raise ValueError('The GCM IV space is exhausted, cannot encrypt anymore messages with this key as doing so would cause the IV to repeat')\n                c[i] = 0\n            else:\n                c[i] += 1\n                break\n\n    def _create_j0(self, iv):\n        J0 = self.J0\n        if iv.length is 12:\n            convert_to_int32(iv, J0)\n            J0[3] = 1\n        else:\n            J0.fill(0)\n            tmp = convert_to_int32_pad(iv)\n            while tmp.length:\n                J0 = self.galois.ghash(J0, tmp)\n                tmp = tmp.subarray(4)\n            tmp = Uint32Array(4)\n            tmp.set(from_64_to_32(iv.length * 8), 2)\n            J0 = self.galois.ghash(J0, tmp)\n        return J0\n\n    def _start(self, iv, additional_data):\n        J0 = self._create_j0(iv)\n        # Generate initial counter block\n        in_block = Uint32Array(J0)\n        in_block[3] = (in_block[3] + 1) & 0xFFFFFFFF  # increment counter\n\n        # Process additional_data\n        S = Uint32Array(4)\n        overflow = additional_data.length % 16\n        for v'var i = 0; i < additional_data.length - overflow; i += 16':\n            convert_to_int32(additional_data, self.wmem, i, 16)\n            S = self.galois.ghash(S, self.wmem)\n        if overflow:\n            self.byte_block.fill(0)\n            self.byte_block.set(additional_data.subarray(additional_data.length - overflow))\n            convert_to_int32(self.byte_block, self.wmem)\n            S = self.galois.ghash(S, self.wmem)\n        return J0, in_block, S\n\n    def _finish(self, iv, J0, adata_len, S, outbytes):\n        # Mix the lengths into S\n        lengths = Uint32Array(4)\n        lengths.set(from_64_to_32(adata_len * 8))\n        lengths.set(from_64_to_32(outbytes.length * 8), 2)\n        S = self.galois.ghash(S, lengths)\n\n        # Create the tag\n        self.aes.encrypt32(J0, self.byte_block, 0)\n        convert_to_int32(self.byte_block, self.wmem)\n        tag = Uint32Array(4)\n        for v'var i = 0; i < S.length; i++':\n            tag[i] = S[i] ^ self.wmem[i]\n        return {'iv':iv, 'cipherbytes':outbytes, 'tag':tag}\n\n    def _crypt(self, iv, bytes, additional_data, decrypt):\n        ghash = self.galois.ghash.bind(self.galois)\n        outbytes = Uint8Array(bytes.length)\n        J0, in_block, S = self._start(iv, additional_data)\n        bb = self.byte_block\n        enc = self.aes.encrypt32.bind(self.aes)\n        hash_bytes = bytes if decrypt else outbytes\n\n        # Create the ciphertext, encrypting block by block\n        for v'var i = 0, counter_index = 16; i < bytes.length; i++, counter_index++':\n            if counter_index is 16:\n                # Encrypt counter and increment it\n                enc(in_block, bb, 0)\n                in_block[3] = (in_block[3] + 1) & 0xFFFFFFFF  # increment counter\n                counter_index = 0\n            # Output is XOR of encrypted counter with input\n            outbytes[i] = bytes[i] ^ bb[counter_index]\n            if counter_index is 15:\n                # We have completed a block, update the hash\n                convert_to_int32(hash_bytes, self.wmem, i - 15, 16)\n                S = ghash(S, self.wmem)\n\n        # Check if we have a last partial block\n        overflow = outbytes.length % 16\n        if overflow:\n            # partial output block\n            bb.fill(0)\n            bb.set(hash_bytes.subarray(hash_bytes.length - overflow))\n            convert_to_int32(bb, self.wmem)\n            S = ghash(S, self.wmem)\n\n        return self._finish(iv, J0, additional_data.length, S, outbytes)\n\n    def encrypt(self, plaintext, tag):\n        if self.random_iv:\n            iv = random_bytes(12)\n        else:\n            self.increment_iv()\n            iv = self.current_iv\n        return self._crypt(iv, string_to_bytes(plaintext), self.tag_as_bytes(tag), False)\n\n    def decrypt(self, output_from_encrypt, tag):\n        if output_from_encrypt.tag.length != 4:\n            raise ValueError('Corrupted message')\n        ans = self._crypt(output_from_encrypt.iv, output_from_encrypt.cipherbytes, self.tag_as_bytes(tag), True)\n        if ans.tag != output_from_encrypt.tag:\n            raise ValueError('Corrupted message')\n        return bytes_to_string(ans.cipherbytes)\n# }}}\n","__stdlib__/elementmaker.pyj":"# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\nhtml_elements = {\n    'a', 'abbr', 'acronym', 'address', 'area',\n    'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',\n    'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',\n    'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',\n    'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',\n    'figcaption', 'figure', 'footer', 'font', 'form', 'header', 'h1',\n    'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'iframe', 'img', 'input', 'ins',\n    'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',\n    'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',\n    'p', 'pre', 'progress', 'q', 's', 'samp', 'script', 'section', 'select',\n    'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong', 'style',\n    'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',\n    'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video'\n}\n\nmathml_elements = {\n    'maction', 'math', 'merror', 'mfrac', 'mi',\n    'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom',\n    'mprescripts', 'mroot', 'mrow', 'mspace', 'msqrt', 'mstyle', 'msub',\n    'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder',\n    'munderover', 'none'\n}\n\nsvg_elements = {\n    'a', 'animate', 'animateColor', 'animateMotion',\n    'animateTransform', 'clipPath', 'circle', 'defs', 'desc', 'ellipse',\n    'font-face', 'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',\n    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',\n    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',\n    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use'\n}\n\nhtml5_tags = html_elements.union(mathml_elements).union(svg_elements)\n\ndef _makeelement(tag, *args, **kwargs):\n    ans = this.createElement(tag)\n\n    for attr in kwargs:\n        vattr = str.replace(str.rstrip(attr, '_'), '_', '-')\n        val = kwargs[attr]\n        if callable(val):\n            if str.startswith(attr, 'on'):\n                attr = attr[2:]\n            ans.addEventListener(attr, val)\n        elif val is True:\n            ans.setAttribute(vattr, vattr)\n        elif jstype(val) is 'string':\n            ans.setAttribute(vattr, val)\n\n    for arg in args:\n        if jstype(arg) is 'string':\n            arg = this.createTextNode(arg)\n        ans.appendChild(arg)\n    return ans\n\ndef maker_for_document(document):\n    # Create an elementmaker to be used with the specified document\n    E = _makeelement.bind(document)\n    Object.defineProperties(E, {\n        tag: {\n            'value':_makeelement.bind(document, tag)\n        } for tag in html5_tags\n    })\n    return E\n\nif jstype(document) is 'undefined':\n    E = maker_for_document({\n        'createTextNode': def(value): return value;,\n        'createElement': def(name):\n            return  {\n                'name':name,\n                'children':[],\n                'attributes':{},\n                'setAttribute': def(name, val): this.attributes[name] = val;,\n                'appendChild': def(child): this.children.push(child);,\n            }\n    })\nelse:\n    E = maker_for_document(document)\n","__stdlib__/encodings.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n\ndef base64encode(bytes, altchars, pad_char):\n    # Convert an array of bytes into a base-64 encoded string\n    l = bytes.length\n    remainder = l % 3\n    main_length = l - remainder\n    encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + (altchars or '+/')\n    pad_char = '=' if pad_char is undefined else pad_char\n    ans = v'[]'\n    for v'var i = 0; i < main_length; i += 3':\n        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]\n        ans.push(encodings[(chunk & 16515072) >> 18], encodings[(chunk & 258048) >> 12], encodings[(chunk & 4032) >> 6], encodings[chunk & 63])\n    if remainder is 1:\n        chunk = bytes[main_length]\n        ans.push(encodings[(chunk & 252) >> 2], encodings[(chunk & 3) << 4], pad_char, pad_char)\n    elif remainder is 2:\n        chunk = (bytes[main_length] << 8) | bytes[main_length + 1]\n        ans.push(encodings[(chunk & 64512) >> 10], encodings[(chunk & 1008) >> 4], encodings[(chunk & 15) << 2], pad_char)\n    return ans.join('')\n\ndef base64decode(string):\n    # convert the output of base64encode back into an array of bytes\n    # (Uint8Array) only works with the standard altchars and pad_char\n    if jstype(window) is not 'undefined':\n        chars = window.atob(string)\n    else:\n        chars = new Buffer(string, 'base64').toString('binary')  # noqa: undef\n    ans = Uint8Array(chars.length)\n    for i in range(ans.length):\n        ans[i] = chars.charCodeAt(i)\n    return ans\n\ndef urlsafe_b64encode(bytes, pad_char):\n    return base64encode(bytes, '-_', pad_char)\n\ndef urlsafe_b64decode(string):\n    string = String.prototype.replace.call(string, /[_-]/g, def(m): return '+' if m is '-' else '/';)\n    return base64decode(string)\n\ndef hexlify(bytes):\n    ans = v'[]'\n    for v'var i = 0; i < bytes.length; i++':\n        x = bytes[i].toString(16)\n        if x.length is 1:\n            x = '0' + x\n        ans.push(x)\n    return ans.join('')\n\ndef unhexlify(string):\n    num = string.length // 2\n    if num * 2 is not string.length:\n        raise ValueError('string length is not a multiple of two')\n    ans = Uint8Array(num)\n    for v'var i = 0; i < num; i++':\n        x = parseInt(string[i*2:i*2+2], 16)\n        if isNaN(x):\n            raise ValueError('string is not hex-encoded')\n        ans[i] = x\n    return ans\n\nutf8_decoder_table = v'''[\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf\n  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df\n  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef\n  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff\n  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2\n  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4\n  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6\n  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8\n]'''\n\ndef _from_code_point(x):\n    if x <= 0xFFFF:\n        return String.fromCharCode(x)\n    x -= 0x10000\n    return String.fromCharCode((x >> 10) + 0xD800, (x % 0x400) + 0xDC00)\n\ndef utf8_decode(bytes, errors, replacement):\n    # Convert an array of UTF-8 encoded bytes into a string\n    state = 0\n    ans = v'[]'\n\n    for v'var i = 0, l = bytes.length; i < l; i++':  # noqa\n        byte = bytes[i]\n        typ = utf8_decoder_table[byte]\n        codep = (byte & 0x3f) | (codep << 6) if state is not 0 else (0xff >> typ) & (byte)\n        state = utf8_decoder_table[256 + state*16 + typ]\n        if state is 0:\n            ans.push(_from_code_point(codep))\n        elif state is 1:\n            if not errors or errors is 'strict':\n                raise UnicodeDecodeError(str.format('The byte 0x{:02x} at position {} is not valid UTF-8', byte, i))\n            elif errors is 'replace':\n                ans.push(replacement or '?')\n    return ans.join('')\n\ndef utf8_encode_js(string):\n    # Encode a string as an array of UTF-8 bytes\n    escstr = encodeURIComponent(string)\n    ans = v'[]'\n    for v'var i = 0; i < escstr.length; i++':\n        ch = escstr[i]\n        if ch is '%':\n            ans.push(parseInt(escstr[i+1:i+3], 16))\n            i += 2\n        else:\n            ans.push(ch.charCodeAt(0))\n    return Uint8Array(ans)\n\nif jstype(TextEncoder) is 'function':\n    _u8enc = TextEncoder('utf-8')\n    utf8_encode = _u8enc.encode.bind(_u8enc)\n    _u8enc = undefined\nelse:\n    utf8_encode = utf8_encode_js\n\ndef utf8_encode_native(string):\n    return _u8enc.encode(string)\n","__stdlib__/gettext.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\n# noqa: eol-semicolon\n\n# The Plural-Forms parser {{{\n# From: https://github.com/SlexAxton/Jed/blob/master/jed.js licensed under the WTFPL\n\nJed = {}\n\nvr'''\n  Jed.PF = {};\n\n  Jed.PF.parse = function ( p ) {\n    var plural_str = Jed.PF.extractPluralExpr( p );\n    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);\n  };\n\n  Jed.PF.compile = function ( p ) {\n    // Handle trues and falses as 0 and 1\n    function imply( val ) {\n      return (val === true ? 1 : val ? val : 0);\n    }\n\n    var ast = Jed.PF.parse( p );\n    return function ( n ) {\n      return imply( Jed.PF.interpreter( ast )( n ) );\n    };\n  };\n\n  Jed.PF.interpreter = function ( ast ) {\n    return function ( n ) {\n      var res;\n      switch ( ast.type ) {\n        case 'GROUP':\n          return Jed.PF.interpreter( ast.expr )( n );\n        case 'TERNARY':\n          if ( Jed.PF.interpreter( ast.expr )( n ) ) {\n            return Jed.PF.interpreter( ast.truthy )( n );\n          }\n          return Jed.PF.interpreter( ast.falsey )( n );\n        case 'OR':\n          return Jed.PF.interpreter( ast.left )( n ) || Jed.PF.interpreter( ast.right )( n );\n        case 'AND':\n          return Jed.PF.interpreter( ast.left )( n ) && Jed.PF.interpreter( ast.right )( n );\n        case 'LT':\n          return Jed.PF.interpreter( ast.left )( n ) < Jed.PF.interpreter( ast.right )( n );\n        case 'GT':\n          return Jed.PF.interpreter( ast.left )( n ) > Jed.PF.interpreter( ast.right )( n );\n        case 'LTE':\n          return Jed.PF.interpreter( ast.left )( n ) <= Jed.PF.interpreter( ast.right )( n );\n        case 'GTE':\n          return Jed.PF.interpreter( ast.left )( n ) >= Jed.PF.interpreter( ast.right )( n );\n        case 'EQ':\n          return Jed.PF.interpreter( ast.left )( n ) == Jed.PF.interpreter( ast.right )( n );\n        case 'NEQ':\n          return Jed.PF.interpreter( ast.left )( n ) != Jed.PF.interpreter( ast.right )( n );\n        case 'MOD':\n          return Jed.PF.interpreter( ast.left )( n ) % Jed.PF.interpreter( ast.right )( n );\n        case 'VAR':\n          return n;\n        case 'NUM':\n          return ast.val;\n        default:\n          throw new Error(\"Invalid Token found.\");\n      }\n    };\n  };\n\n  Jed.PF.extractPluralExpr = function ( p ) {\n    // trim first\n    p = p.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n    if (! /;\\s*$/.test(p)) {\n      p = p.concat(';');\n    }\n\n    var nplurals_re = /nplurals\\=(\\d+);/,\n        plural_re = /plural\\=(.*);/,\n        nplurals_matches = p.match( nplurals_re ),\n        res = {},\n        plural_matches;\n\n    // Find the nplurals number\n    if ( nplurals_matches.length > 1 ) {\n      res.nplurals = nplurals_matches[1];\n    }\n    else {\n      throw new Error('nplurals not found in plural_forms string: ' + p );\n    }\n\n    // remove that data to get to the formula\n    p = p.replace( nplurals_re, \"\" );\n    plural_matches = p.match( plural_re );\n\n    if (!( plural_matches && plural_matches.length > 1 ) ) {\n      throw new Error('`plural` expression not found: ' + p);\n    }\n    return plural_matches[ 1 ];\n  };\n\n  /* Jison generated parser */\n  Jed.PF.parser = (function(){\n\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"e\":4,\"EOF\":5,\"?\":6,\":\":7,\"||\":8,\"&&\":9,\"<\":10,\"<=\":11,\">\":12,\">=\":13,\"!=\":14,\"==\":15,\"%\":16,\"(\":17,\")\":18,\"n\":19,\"NUMBER\":20,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",6:\"?\",7:\":\",8:\"||\",9:\"&&\",10:\"<\",11:\"<=\",12:\">\",13:\">=\",14:\"!=\",15:\"==\",16:\"%\",17:\"(\",18:\")\",19:\"n\",20:\"NUMBER\"},\nproductions_: [0,[3,2],[4,5],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,1],[4,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: return { type : 'GROUP', expr: $$[$0-1] };\ncase 2:this.$ = { type: 'TERNARY', expr: $$[$0-4], truthy : $$[$0-2], falsey: $$[$0] };\nbreak;\ncase 3:this.$ = { type: \"OR\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 4:this.$ = { type: \"AND\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 5:this.$ = { type: 'LT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 6:this.$ = { type: 'LTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 7:this.$ = { type: 'GT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 8:this.$ = { type: 'GTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 9:this.$ = { type: 'NEQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 10:this.$ = { type: 'EQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 11:this.$ = { type: 'MOD', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 12:this.$ = { type: 'GROUP', expr: $$[$0-1] };\nbreak;\ncase 13:this.$ = { type: 'VAR' };\nbreak;\ncase 14:this.$ = { type: 'NUM', val: Number(yytext) };\nbreak;\n}\n},\ntable: [{3:1,4:2,17:[1,3],19:[1,4],20:[1,5]},{1:[3]},{5:[1,6],6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{4:17,17:[1,3],19:[1,4],20:[1,5]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13],18:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14],18:[2,14]},{1:[2,1]},{4:18,17:[1,3],19:[1,4],20:[1,5]},{4:19,17:[1,3],19:[1,4],20:[1,5]},{4:20,17:[1,3],19:[1,4],20:[1,5]},{4:21,17:[1,3],19:[1,4],20:[1,5]},{4:22,17:[1,3],19:[1,4],20:[1,5]},{4:23,17:[1,3],19:[1,4],20:[1,5]},{4:24,17:[1,3],19:[1,4],20:[1,5]},{4:25,17:[1,3],19:[1,4],20:[1,5]},{4:26,17:[1,3],19:[1,4],20:[1,5]},{4:27,17:[1,3],19:[1,4],20:[1,5]},{6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[1,28]},{6:[1,7],7:[1,29],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{5:[2,3],6:[2,3],7:[2,3],8:[2,3],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[2,5],11:[2,5],12:[2,5],13:[2,5],14:[2,5],15:[2,5],16:[1,16],18:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[1,16],18:[2,6]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[1,16],18:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[1,16],18:[2,8]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[1,16],18:[2,9]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[1,16],18:[2,10]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11],18:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12],18:[2,12]},{4:30,17:[1,3],19:[1,4],20:[1,5]},{5:[2,2],6:[1,7],7:[2,2],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,2]}],\ndefaultActions: {6:[2,1]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected, errStr;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || symbol === undefined)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state === 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};/* Jison generated lexer */\nvar lexer = (function(){\n\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            match = this._input.match(this.rules[rules[i]]);\n            if (match) {\n                lines = match[0].match(/\\n.*/g);\n                if (lines) this.yylineno += lines.length;\n                this.yylloc = {first_line: this.yylloc.last_line,\n                               last_line: this.yylineno+1,\n                               first_column: this.yylloc.last_column,\n                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length};\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this._more = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);\n                if (token) return token;\n                else return;\n            }\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 20\nbreak;\ncase 2:return 19\nbreak;\ncase 3:return 8\nbreak;\ncase 4:return 9\nbreak;\ncase 5:return 6\nbreak;\ncase 6:return 7\nbreak;\ncase 7:return 11\nbreak;\ncase 8:return 13\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 12\nbreak;\ncase 11:return 14\nbreak;\ncase 12:return 15\nbreak;\ncase 13:return 16\nbreak;\ncase 14:return 17\nbreak;\ncase 15:return 18\nbreak;\ncase 16:return 5\nbreak;\ncase 17:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^\\s+/,/^[0-9]+(\\.[0-9]+)?\\b/,/^n\\b/,/^\\|\\|/,/^&&/,/^\\?/,/^:/,/^<=/,/^>=/,/^</,/^>/,/^!=/,/^==/,/^%/,/^\\(/,/^\\)/,/^$/,/^./];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],\"inclusive\":true}};return lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\n'''\nplural_forms_parser = Jed.PF\n# }}}\n\ndef _get_plural_forms_function(plural_forms_string):\n    return plural_forms_parser.compile(plural_forms_string or \"nplurals=2; plural=(n != 1);\")\n\n_gettext = def(text): return text\n\n_ngettext = def(text, plural, n): return text if n is 1 else plural\n\ndef gettext(text):\n    return _gettext(text)\n\ndef ngettext(text, plural, n):\n    return _ngettext(text, plural, n)\n\ndef install(translation_data):\n    t = new Translations(translation_data)\n    t.install()\n    for func in register_callback.install_callbacks:\n        try:\n            func(t)\n        except:\n            pass\n    return t\n\nhas_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty)\n\ndef register_callback(func):\n    # Register callbacks that will be called when new translation data is\n    # installed\n    register_callback.install_callbacks.push(func)\nregister_callback.install_callbacks = v'[]'\n\nempty_translation_data = {'entries': {}}\n\nclass Translations:\n\n    def __init__(self, translation_data):\n        translation_data = translation_data or empty_translation_data\n        func = _get_plural_forms_function(translation_data.plural_forms)\n        self.translations = [[translation_data, func]]\n        self.language = translation_data['language']\n\n    def add_fallback(self, fallback):\n        fallback = fallback or empty_translation_data\n        func = _get_plural_forms_function(fallback.plural_forms)\n        self.translations.push([fallback, func])\n\n    def gettext(self, text):\n        for t in self.translations:\n            m = t[0].entries\n            if has_prop(m, text):\n                return m[text][0]\n        return text\n\n    def ngettext(self, text, plural, n):\n        for t in self.translations:\n            m = t[0].entries\n            if has_prop(m, text):\n                idx = t[1](n)\n                return m[text][idx] or (text if n is 1 else plural)\n        return text if n is 1 else plural\n\n    def install(self):\n        nonlocal _gettext, _ngettext\n        _gettext = def ():\n            return self.gettext.apply(self, arguments)\n        _ngettext = def ():\n            return self.ngettext.apply(self, arguments)\n","__stdlib__/math.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'math' library\n\n# NOTE: this is only meant to aid those porting lots of Python code into RapydScript,\n# if you're writing a new RapydScript application, in most cases you probably want to\n# use JavaScript's Math module directly instead\n\n\npi = Math.PI\ne = Math.E\n\n########################################\n# Number-theoretic and representation functions\n########################################\ndef ceil(x):\n    return Math.ceil(x)\ndef copysign(x, y):\n    x = Math.abs(x)\n    if y < 0:\n        return -x\n    else:\n        return x\ndef fabs(x):\n    return Math.abs(x)\ndef factorial(x):\n    if Math.abs(int(x)) is not x:\n        raise ValueError(\"factorial() only accepts integral values\")\n    factorial.cache = []\n    r = def(n):\n        if n is 0 or n is 1:\n            return 1\n        if not factorial.cache[n]:\n            factorial.cache[n] = r(n-1) * n\n        return factorial.cache[n]\n    return r(x)\ndef floor(x):\n    return Math.floor(x)\ndef fmod(x, y):\n    # javascript's % operator isn't consistent with C fmod implementation, this function is\n    while y <= x:\n        x -= y\n    return x\ndef fsum(iterable):\n    # like Python's fsum, this method is much more resilient to rounding errors than regular sum\n    partials = []   # sorted, non-overlapping partial sums\n    for x in iterable:\n        i = 0\n        for y in partials:\n            if Math.abs(x) < Math.abs(y):\n                x, y = y, x\n            hi = x + y\n            lo = y - (hi - x)\n            if lo:\n                partials[i] = lo\n                i += 1\n            x = hi\n        #partials[i:] = [x]\n        partials.splice(i, partials.length-i, x)\n    return sum(partials)\ndef isinf(x):\n    return not isFinite(x)\ndef isnan(x):\n    return isNaN(x)\ndef modf(x):\n    m = fmod(x, 1)\n    return m, x-m\ndef trunc(x):\n    return x | 0\n\n########################################\n# Power and logarithmic functions\n########################################\ndef exp(x):\n    return Math.exp(x)\ndef expm1(x):\n    # NOTE: Math.expm1() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1\n    #return Math.expm1(x)\n    if Math.abs(x) < 1e-5:\n        return x + 0.5*x*x\n    else:\n        return Math.exp(x) - 1\ndef log(x, base=e):\n    return Math.log(x)/Math.log(base)\ndef log1p(x):\n    # NOTE: Math.log1p() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p\n    # this version has been taken from http://phpjs.org/functions/log1p/\n    # admittedly it's not as accurate as MDN version, as you can see from math.log1p(1) result\n    ret = 0\n    n = 50\n    if x <= -1:\n        return Number.NEGATIVE_INFINITY\n    if x < 0 or x > 1:\n        return Math.log(1 + x)\n    for i in range(1, n):\n        if i % 2 is 0:\n            ret -= Math.pow(x, i) / i\n        else:\n            ret += Math.pow(x, i) / i\n    return ret\ndef log10(x):\n    # NOTE: Math.log10() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\n    # I didn't find a more accurate algorithm so I'm using the basic implementation\n    return Math.log(x)/Math.LN10\ndef pow(x, y):\n    if x < 0 and int(y) is not y:\n        raise ValueError('math domain error')\n    if isnan(y) and x is 1:\n        return 1\n    return Math.pow(x, y)\ndef sqrt(x):\n    return Math.sqrt(x)\n\n########################################\n# Trigonometric functions\n########################################\ndef acos(x):        return Math.acos(x)\ndef asin(x):        return Math.asin(x)\ndef atan(x):        return Math.atan(x)\ndef atan2(y, x):    return Math.atan2(y, x)\ndef cos(x):         return Math.cos(x)\ndef sin(x):         return Math.sin(x)\ndef hypot(x, y):    return Math.sqrt(x*x + y*y)\ndef tan(x):         return Math.tan(x)\n\n########################################\n# Angular conversion\n########################################\ndef degrees(x):     return x*180/pi\ndef radians(x):     return x*pi/180\n\n########################################\n# Hyperbolic functions\n########################################\ndef acosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\n    return Math.log(x + Math.sqrt(x*x - 1))\ndef asinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\n    return Math.log(x + Math.sqrt(x*x + 1))\ndef atanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\n    return 0.5 * Math.log((1 + x) / (1 - x))\ndef cosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\n    return (Math.exp(x) + Math.exp(-x)) / 2\ndef sinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\n    return (Math.exp(x) - Math.exp(-x)) / 2\ndef tanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\n    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))\n\n\n\n#import stdlib\n#print(math.ceil(4.2))\n#print(math.floor(4.2))\n#print(math.fabs(-6))\n#print(math.copysign(-5, 7))\n#print(math.factorial(4))\n#print(math.fmod(-1e100, 1e100))\n#\n#d = [0.9999999, 1, 2, 3]\n#print(sum(d), math.fsum(d))\n#print(math.isinf(5), math.isinf(Infinity))\n#print(math.modf(5.5))\n#print(math.trunc(2.6), math.trunc(-2.6))\n#print(math.exp(1e-5), math.expm1(1e-5))\n#print(math.log(10), math.log(10, 1000))\n#print(math.log1p(1e-15), math.log1p(1))\n#print(math.log10(1000), math.log(1000, 10))\n#print(math.pow(1, 0), math.pow(1, NaN), math.pow(0, 0), math.pow(NaN, 0), math.pow(4,3), math.pow(100, -2))\n#print(math.hypot(3,4))\n#print(math.acosh(2), math.asinh(1), math.atanh(0.5), math.cosh(1), math.cosh(-1), math.sinh(1), math.tanh(1))\n","__stdlib__/operator.pyj":"add = __add__ = def(x, y): return x + y\nsub = __sub__ = def(x, y): return x - y\nmul = __mul__ = def(x, y): return x * y\ndiv = __div__ = def(x, y): return x / y\n\nlt = __lt__ = def(x, y): return x < y\nle = __le__ = def(x, y): return x <= y\neq = __eq__ = def(x, y): return x is y\nne = __ne__ = def(x, y): return x is not y\nge = __ge__ = def(x, y): return x >= y\ngt = __gt__ = def(x, y): return x > y\n","__stdlib__/pythonize.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n# globals: RS_str\n\ndef strings():\n    string_funcs = set((\n        'capitalize strip lstrip rstrip islower isupper isspace lower upper swapcase'\n        ' center count endswith startswith find rfind index rindex format join ljust rjust'\n        ' partition rpartition replace split rsplit splitlines zfill').split(' '))\n\n    if not arguments.length:\n        exclude = {'split', 'replace'}\n    elif arguments[0]:\n        exclude = Array.prototype.slice.call(arguments)\n    else:\n        exclude = None\n    if exclude:\n        string_funcs = string_funcs.difference(set(exclude))\n    for name in string_funcs:\n        String.prototype[name] = RS_str.prototype[name]\n","__stdlib__/random.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'random' library\n\n# JavaScript's Math.random() does not allow seeding its random generator, to bypass that, this module implements its own\n# version that can be seeded. I decided on RC4 algorithm for this.\n\n# please don't mess with this from the outside\n\nRS_seed_state = {\n    'key': [],\n    'key_i': 0,\n    'key_j': 0\n}\n\nRS_get_random_byte = def():\n    RS_seed_state.key_i = (RS_seed_state.key_i + 1) % 256\n    RS_seed_state.key_j = (RS_seed_state.key_j + RS_seed_state.key[RS_seed_state.key_i]) % 256\n    RS_seed_state.key[RS_seed_state.key_i], RS_seed_state.key[RS_seed_state.key_j] = \\\n            RS_seed_state.key[RS_seed_state.key_j], RS_seed_state.key[RS_seed_state.key_i]\n    return RS_seed_state.key[(RS_seed_state.key[RS_seed_state.key_i] + \\\n            RS_seed_state.key[RS_seed_state.key_j]) % 256]\n\ndef seed(x=Date().getTime()):\n    RS_seed_state.key_i = RS_seed_state.key_j = 0\n    if jstype(x) is 'number':\n        x = x.toString()\n    elif jstype(x) is not 'string':\n        raise TypeError(\"unhashable type: '\" + jstype(x) + \"'\")\n    for i in range(256):\n        RS_seed_state.key[i] = i\n    j = 0\n    for i in range(256):\n        j = (j + RS_seed_state.key[i] + x.charCodeAt(i % x.length)) % 256\n        RS_seed_state.key[i], RS_seed_state.key[j] = RS_seed_state.key[j], RS_seed_state.key[i]\nseed()\n\ndef random():\n    n = 0\n    m = 1\n    for i in range(8):\n        n += RS_get_random_byte() * m\n        m *= 256\n    return v'n / 0x10000000000000000'\n\n# unlike the python version, this DOES build a range object, feel free to reimplement\ndef randrange():\n    return choice(range.apply(this, arguments))\n\ndef randint(a, b):\n    return int(random()*(b-a+1) + a)\n\ndef uniform(a, b):\n    return random()*(b-a) + a\n\ndef choice(seq):\n    if seq.length > 0:\n        return seq[Math.floor(random()*seq.length)]\n    else:\n        raise IndexError()\n\n# uses Fisher-Yates algorithm to shuffle an array\ndef shuffle(x, random_f=random):\n    for i in range(x.length):\n        j = Math.floor(random_f() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x\n\n# similar to shuffle, but only shuffles a subset and creates a copy\ndef sample(population, k):\n    x = population.slice()\n    for i in range(population.length-1, population.length-k-1, -1):\n        j = Math.floor(random() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x.slice(population.length-k)\n\n\n#import stdlib\n#a = range(50)\n#random.seed(5)\n#print(random.choice(a))\n#print(random.shuffle(a))\n#print(random.randrange(10))\n#print(random.randint(1,5))\n#print(random.uniform(1,5))\n#print(random.sample(range(20),5))\n","__stdlib__/re.pyj":'# vim:fileencoding=utf-8\n# License: BSD\n# Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n# Copyright: 2013, Alexander Tsepkov\n\n# globals: RS_iterator_symbol, RS_list_decorate\n\n# basic implementation of Python\'s \'re\' library\n\nfrom __python__ import bound_methods\n\n# Alias DB from http://www.unicode.org/Public/8.0.0/ucd/NameAliases.txt {{{\n_ALIAS_MAP = {"null":0,"nul":0,"start of heading":1,"soh":1,"start of text":2,"stx":2,"end of text":3,"etx":3,"end of transmission":4,"eot":4,"enquiry":5,"enq":5,"acknowledge":6,"ack":6,"alert":7,"bel":7,"backspace":8,"bs":8,"character tabulation":9,"horizontal tabulation":9,"ht":9,"tab":9,"line feed":10,"new line":10,"end of line":10,"lf":10,"nl":10,"eol":10,"line tabulation":11,"vertical tabulation":11,"vt":11,"form feed":12,"ff":12,"carriage return":13,"cr":13,"shift out":14,"locking-shift one":14,"so":14,"shift in":15,"locking-shift zero":15,"si":15,"data link escape":16,"dle":16,"device control one":17,"dc1":17,"device control two":18,"dc2":18,"device control three":19,"dc3":19,"device control four":20,"dc4":20,"negative acknowledge":21,"nak":21,"synchronous idle":22,"syn":22,"end of transmission block":23,"etb":23,"cancel":24,"can":24,"end of medium":25,"eom":25,"substitute":26,"sub":26,"escape":27,"esc":27,"information separator four":28,"file separator":28,"fs":28,"information separator three":29,"group separator":29,"gs":29,"information separator two":30,"record separator":30,"rs":30,"information separator one":31,"unit separator":31,"us":31,"sp":32,"delete":127,"del":127,"padding character":128,"pad":128,"high octet preset":129,"hop":129,"break permitted here":130,"bph":130,"no break here":131,"nbh":131,"index":132,"ind":132,"next line":133,"nel":133,"start of selected area":134,"ssa":134,"end of selected area":135,"esa":135,"character tabulation set":136,"horizontal tabulation set":136,"hts":136,"character tabulation with justification":137,"horizontal tabulation with justification":137,"htj":137,"line tabulation set":138,"vertical tabulation set":138,"vts":138,"partial line forward":139,"partial line down":139,"pld":139,"partial line backward":140,"partial line up":140,"plu":140,"reverse line feed":141,"reverse index":141,"ri":141,"single shift two":142,"single-shift-2":142,"ss2":142,"single shift three":143,"single-shift-3":143,"ss3":143,"device control string":144,"dcs":144,"private use one":145,"private use-1":145,"pu1":145,"private use two":146,"private use-2":146,"pu2":146,"set transmit state":147,"sts":147,"cancel character":148,"cch":148,"message waiting":149,"mw":149,"start of guarded area":150,"start of protected area":150,"spa":150,"end of guarded area":151,"end of protected area":151,"epa":151,"start of string":152,"sos":152,"single graphic character introducer":153,"sgc":153,"single character introducer":154,"sci":154,"control sequence introducer":155,"csi":155,"string terminator":156,"st":156,"operating system command":157,"osc":157,"privacy message":158,"pm":158,"application program command":159,"apc":159,"nbsp":160,"shy":173,"latin capital letter gha":418,"latin small letter gha":419,"cgj":847,"alm":1564,"syriac sublinear colon skewed left":1801,"kannada letter llla":3294,"lao letter fo fon":3741,"lao letter fo fay":3743,"lao letter ro":3747,"lao letter lo":3749,"tibetan mark bka- shog gi mgo rgyan":4048,"fvs1":6155,"fvs2":6156,"fvs3":6157,"mvs":6158,"zwsp":8203,"zwnj":8204,"zwj":8205,"lrm":8206,"rlm":8207,"lre":8234,"rle":8235,"pdf":8236,"lro":8237,"rlo":8238,"nnbsp":8239,"mmsp":8287,"wj":8288,"lri":8294,"rli":8295,"fsi":8296,"pdi":8297,"weierstrass elliptic function":8472,"micr on us symbol":9288,"micr dash symbol":9289,"leftwards triangle-headed arrow with double vertical stroke":11130,"rightwards triangle-headed arrow with double vertical stroke":11132,"yi syllable iteration mark":40981,"presentation form for vertical right white lenticular bracket":65048,"vs1":65024,"vs2":65025,"vs3":65026,"vs4":65027,"vs5":65028,"vs6":65029,"vs7":65030,"vs8":65031,"vs9":65032,"vs10":65033,"vs11":65034,"vs12":65035,"vs13":65036,"vs14":65037,"vs15":65038,"vs16":65039,"byte order mark":65279,"bom":65279,"zwnbsp":65279,"cuneiform sign nu11 tenu":74452,"cuneiform sign nu11 over nu11 bur over bur":74453,"byzantine musical symbol fthora skliron chroma vasis":118981,"vs17":917760,"vs18":917761,"vs19":917762,"vs20":917763,"vs21":917764,"vs22":917765,"vs23":917766,"vs24":917767,"vs25":917768,"vs26":917769,"vs27":917770,"vs28":917771,"vs29":917772,"vs30":917773,"vs31":917774,"vs32":917775,"vs33":917776,"vs34":917777,"vs35":917778,"vs36":917779,"vs37":917780,"vs38":917781,"vs39":917782,"vs40":917783,"vs41":917784,"vs42":917785,"vs43":917786,"vs44":917787,"vs45":917788,"vs46":917789,"vs47":917790,"vs48":917791,"vs49":917792,"vs50":917793,"vs51":917794,"vs52":917795,"vs53":917796,"vs54":917797,"vs55":917798,"vs56":917799,"vs57":917800,"vs58":917801,"vs59":917802,"vs60":917803,"vs61":917804,"vs62":917805,"vs63":917806,"vs64":917807,"vs65":917808,"vs66":917809,"vs67":917810,"vs68":917811,"vs69":917812,"vs70":917813,"vs71":917814,"vs72":917815,"vs73":917816,"vs74":917817,"vs75":917818,"vs76":917819,"vs77":917820,"vs78":917821,"vs79":917822,"vs80":917823,"vs81":917824,"vs82":917825,"vs83":917826,"vs84":917827,"vs85":917828,"vs86":917829,"vs87":917830,"vs88":917831,"vs89":917832,"vs90":917833,"vs91":917834,"vs92":917835,"vs93":917836,"vs94":917837,"vs95":917838,"vs96":917839,"vs97":917840,"vs98":917841,"vs99":917842,"vs100":917843,"vs101":917844,"vs102":917845,"vs103":917846,"vs104":917847,"vs105":917848,"vs106":917849,"vs107":917850,"vs108":917851,"vs109":917852,"vs110":917853,"vs111":917854,"vs112":917855,"vs113":917856,"vs114":917857,"vs115":917858,"vs116":917859,"vs117":917860,"vs118":917861,"vs119":917862,"vs120":917863,"vs121":917864,"vs122":917865,"vs123":917866,"vs124":917867,"vs125":917868,"vs126":917869,"vs127":917870,"vs128":917871,"vs129":917872,"vs130":917873,"vs131":917874,"vs132":917875,"vs133":917876,"vs134":917877,"vs135":917878,"vs136":917879,"vs137":917880,"vs138":917881,"vs139":917882,"vs140":917883,"vs141":917884,"vs142":917885,"vs143":917886,"vs144":917887,"vs145":917888,"vs146":917889,"vs147":917890,"vs148":917891,"vs149":917892,"vs150":917893,"vs151":917894,"vs152":917895,"vs153":917896,"vs154":917897,"vs155":917898,"vs156":917899,"vs157":917900,"vs158":917901,"vs159":917902,"vs160":917903,"vs161":917904,"vs162":917905,"vs163":917906,"vs164":917907,"vs165":917908,"vs166":917909,"vs167":917910,"vs168":917911,"vs169":917912,"vs170":917913,"vs171":917914,"vs172":917915,"vs173":917916,"vs174":917917,"vs175":917918,"vs176":917919,"vs177":917920,"vs178":917921,"vs179":917922,"vs180":917923,"vs181":917924,"vs182":917925,"vs183":917926,"vs184":917927,"vs185":917928,"vs186":917929,"vs187":917930,"vs188":917931,"vs189":917932,"vs190":917933,"vs191":917934,"vs192":917935,"vs193":917936,"vs194":917937,"vs195":917938,"vs196":917939,"vs197":917940,"vs198":917941,"vs199":917942,"vs200":917943,"vs201":917944,"vs202":917945,"vs203":917946,"vs204":917947,"vs205":917948,"vs206":917949,"vs207":917950,"vs208":917951,"vs209":917952,"vs210":917953,"vs211":917954,"vs212":917955,"vs213":917956,"vs214":917957,"vs215":917958,"vs216":917959,"vs217":917960,"vs218":917961,"vs219":917962,"vs220":917963,"vs221":917964,"vs222":917965,"vs223":917966,"vs224":917967,"vs225":917968,"vs226":917969,"vs227":917970,"vs228":917971,"vs229":917972,"vs230":917973,"vs231":917974,"vs232":917975,"vs233":917976,"vs234":917977,"vs235":917978,"vs236":917979,"vs237":917980,"vs238":917981,"vs239":917982,"vs240":917983,"vs241":917984,"vs242":917985,"vs243":917986,"vs244":917987,"vs245":917988,"vs246":917989,"vs247":917990,"vs248":917991,"vs249":917992,"vs250":917993,"vs251":917994,"vs252":917995,"vs253":917996,"vs254":917997,"vs255":917998,"vs256":917999}\n# }}}\n\n_ASCII_CONTROL_CHARS = {\'a\':7, \'b\':8, \'f\': 12, \'n\': 10, \'r\': 13, \'t\': 9, \'v\': 11}\n_HEX_PAT = /^[a-fA-F0-9]/\n_NUM_PAT =  /^[0-9]/\n_GROUP_PAT = /<([^>]+)>/\n_NAME_PAT = /^[a-zA-Z ]/\n\nI = IGNORECASE = 2\nL = LOCALE = 4\nM = MULTILINE = 8\nD = DOTALL = 16\nU = UNICODE = 32\nX = VERBOSE = 64\nDEBUG = 128\nA = ASCII = 256\n\nsupports_unicode = RegExp.prototype.unicode is not undefined\n\n_RE_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n_re_cache_map = {}\n_re_cache_items = v\'[]\'\n\nerror = SyntaxError  # This is the error JS throws for invalid regexps\nhas_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty)\n\ndef _expand(groups, repl, group_name_map):\n    i = 0\n\n    def next():\n        nonlocal i\n        return v\'repl[i++]\'\n\n    def peek():\n        return repl[i]\n\n    def read_digits(count, pat, base, maxval, prefix):\n        ans = prefix or \'\'\n        greedy = count is Number.MAX_VALUE\n        while count > 0:\n            count -= 1\n            if not pat.test(peek()):\n                if greedy:\n                    break\n                return ans\n            ans += next()\n        nval = parseInt(ans, base)\n        if nval > maxval:\n            return ans\n        return nval\n\n    def read_escape_sequence():\n        nonlocal i\n        q = next()\n        if not q or q is \'\\\\\':\n            return \'\\\\\'\n        if \'"\\\'\'.indexOf(q) is not -1:\n            return q\n        if _ASCII_CONTROL_CHARS[q]:\n            return String.fromCharCode(_ASCII_CONTROL_CHARS[q])\n        if \'0\' <= q <= \'9\':\n            ans = read_digits(Number.MAX_VALUE, _NUM_PAT, 10, Number.MAX_VALUE, q)\n            if jstype(ans) is \'number\':\n                return groups[ans] or \'\'\n            return \'\\\\\' + ans\n        if q is \'g\':\n            m = _GROUP_PAT.exec(repl[i:])\n            if m is not None:\n                i += m[0].length\n                gn = m[1]\n                if isNaN(parseInt(gn, 10)):\n                    if not has_prop(group_name_map, gn):\n                        return \'\'\n                    gn = group_name_map[gn][-1]\n                return groups[gn] or \'\'\n        if q is \'x\':\n            code = read_digits(2, _HEX_PAT, 16, 0x10FFFF)\n            if jstype(code) is \'number\':\n                return String.fromCharCode(code)\n            return \'\\\\x\' + code\n        if q is \'u\':\n            code = read_digits(4, _HEX_PAT, 16, 0x10FFFF)\n            if jstype(code) is \'number\':\n                return String.fromCharCode(code)\n            return \'\\\\u\' + code\n        if q is \'U\':\n            code = read_digits(8, _HEX_PAT, 16, 0x10FFFF)\n            if jstype(code) is \'number\':\n                if code <= 0xFFFF:\n                    return String.fromCharCode(code)\n                code -= 0x10000\n                return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n            return \'\\\\U\' + code\n        if q is \'N\' and peek() is \'{\':\n            next()\n            name = \'\'\n            while _NAME_PAT.test(peek()):\n                name += next()\n            if peek() is not \'}\':\n                return \'\\\\N{\' + name\n            next()\n            key = (name or \'\').toLowerCase()\n            if not name or not has_prop(_ALIAS_MAP, key):\n                return \'\\\\N{\' + name + \'}\'\n            code = _ALIAS_MAP[key]\n            if code <= 0xFFFF:\n                return String.fromCharCode(code)\n            code -= 0x10000\n            return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n\n        return \'\\\\\' + q\n\n    ans = ch = \'\'\n    while True:\n        ch = next()\n        if ch is \'\\\\\':\n            ans += read_escape_sequence()\n        elif not ch:\n            break\n        else:\n            ans += ch\n    return ans\n\ndef transform_regex(source, flags):\n    pos = 0\n    previous_backslash = in_class = False\n    ans = \'\'\n    group_map = {}\n    flags = flags or 0\n    group_count = 0\n\n    while pos < source.length:\n        ch = v\'source[pos++]\'\n        if previous_backslash:\n            ans += \'\\\\\' + ch\n            previous_backslash = False\n            continue\n\n        if in_class:\n            if ch is \']\':\n                in_class = False\n            ans += ch\n            continue\n\n        if ch is \'\\\\\':\n            previous_backslash = True\n            continue\n\n        if ch is \'[\':\n            in_class = True\n            if source[pos] is \']\':  # in python the empty set is not allowed, instead []] is the same as [\\]]\n                pos += 1\n                ch = r\'[\\]\'\n        elif ch is \'(\':\n            if source[pos] is \'?\':\n                extension = source[pos + 1]\n                if extension is \'#\':\n                    close = source.indexOf(\')\', pos + 1)\n                    if close is -1:\n                        raise ValueError(\'Expecting a closing )\')\n                    pos = close + 1\n                    continue\n                if \'aiLmsux\'.indexOf(extension) is not -1:\n                    flag_map = {\'a\':ASCII, \'i\':IGNORECASE, \'L\':LOCALE, \'m\':MULTILINE, \'s\':DOTALL, \'u\':UNICODE, \'x\':VERBOSE}\n                    close = source.indexOf(\')\', pos + 1)\n                    if close is -1:\n                        raise SyntaxError(\'Expecting a closing )\')\n                    flgs = source[pos+1:close]\n                    for v\'var i = 0; i < flgs.length; i++\':\n                        q = flgs[i]  # noqa:undef\n                        if not has_prop(flag_map, q):\n                            raise SyntaxError(\'Invalid flag: \' + q)\n                        flags |= flag_map[q]\n                    pos = close + 1\n                    continue\n                if extension is \'<\':\n                    raise SyntaxError(\'Look behind assertions are not supported in JavaScript\')\n                if extension is \'(\':\n                    raise SyntaxError(\'Group existence assertions are not supported in JavaScript\')\n                if extension is \'P\':\n                    pos += 2\n                    q = source[pos]\n                    if q is \'<\':\n                        close = source.indexOf(\'>\', pos)\n                        if close is -1:\n                            raise SyntaxError(\'Named group not closed, expecting >\')\n                        name = source[pos+1:close]\n                        if not has_prop(group_map, name):\n                            group_map[name] = v\'[]\'\n                        group_map[name].push(v\'++group_count\')\n                        pos = close + 1\n                    elif q is \'=\':\n                        close = source.indexOf(\')\', pos)\n                        if close is -1:\n                            raise SyntaxError(\'Named group back-reference not closed, expecting a )\')\n                        name = source[pos+1:close]\n                        if not isNaN(parseInt(name, 10)):\n                            ans += \'\\\\\' + name\n                        else:\n                            if not has_prop(group_map, name):\n                                raise SyntaxError(\'Invalid back-reference. The named group: \' + name + \' has not yet been defined.\')\n                            ans += \'\\\\\' + group_map[name][-1]\n                        pos = close + 1\n                        continue\n                    else:\n                        raise SyntaxError(\'Expecting < or = after (?P\')\n            else:\n                group_count += 1\n        elif ch is \'.\' and (flags & DOTALL):\n            ans += r\'[\\s\\S]\'  # JavaScript has no DOTALL\n            continue\n\n        ans += ch\n\n    return ans, flags, group_map\n\nclass MatchObject:\n\n    def __init__(self, regex, match, pos, endpos):\n        self.re = regex\n        self.string = match.input\n        self._start_pos = match.index\n        self._groups = match\n        self.pos, self.endpos = pos, endpos\n\n    def _compute_extents(self):\n        # compute start/end for each group\n        match = self._groups\n        self._start = v\'Array(match.length)\'\n        self._end = v\'Array(match.length)\'\n        self._start[0] = self._start_pos\n        self._end[0] = self._start_pos + match[0].length\n        offset = self._start_pos\n        extent = match[0]\n        loc = 0\n        for v\'var i = 1; i < match.length; i++\':\n            g = match[i]\n            loc = extent.indexOf(g, loc)\n            if loc is -1:\n                self._start[i] = self._start[i-1]\n                self._end[i] = self._end[i-1]\n            else:\n                self._start[i] = offset + loc\n                loc += g.length\n                self._end[i] = offset + loc # noqa:undef\n\n    def groups(self, defval=None):\n        ans = v\'[]\'\n        for v\'var i = 1; i < self._groups.length; i++\':\n            val = self._groups[i]  # noqa:undef\n            if val is undefined:\n                val = defval\n            ans.push(val)\n        return ans\n\n    def _group_number(self, g):\n        if jstype(g) is \'number\':\n            return g\n        if has_prop(self.re.group_name_map, g):\n            return self.re.group_name_map[g][-1]\n        return g\n\n    def _group_val(self, q, defval):\n        val = undefined\n        if jstype(q) is \'number\' and -1 < q < self._groups.length:\n            val = self._groups[q]\n        else:\n            if has_prop(self.re.group_name_map, q):\n                val = self._groups[self.re.group_name_map[q][-1]]\n        if val is undefined:\n            val = defval\n        return val\n\n    def group(self):\n        if arguments.length is 0:\n            return self._groups[0]\n        ans = v\'[]\'\n        for v\'var i = 0; i < arguments.length; i++\':\n            q = arguments[i]  # noqa:undef\n            ans.push(self._group_val(q, None))\n        return ans[0] if ans.length is 1 else ans\n\n    def start(self, g):\n        if self._start is undefined:\n            self._compute_extents()\n        val = self._start[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def end(self, g):\n        if self._end is undefined:\n            self._compute_extents()\n        val = self._end[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def span(self, g):\n        return [self.start(g), self.end(g)]\n\n    def expand(self, repl):\n        return _expand(repl, this._groups, this.re.group_name_map)\n\n    def groupdict(self, defval=None):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v"var i = 0; i < names.length; i++":\n            name = names[i]  # noqa:undef\n            if has_prop(gnm, name):\n                val = self._groups[gnm[name][-1]]\n                if val is undefined:\n                    val = defval\n                ans[name] = val\n        return ans\n\n    def captures(self, group_name):\n        ans = []\n        if not has_prop(self.re.group_name_map, group_name):\n            return ans\n        groups = self.re.group_name_map[group_name]\n        for v\'var i = 0; i < groups.length; i++\':\n            val = self._groups[groups[i]]  # noqa:undef\n            if val is not undefined:\n                ans.push(val)\n        return ans\n\n    def capturesdict(self):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v\'var i = 0; i < names.length; i++\':\n            name = names[i]  # noqa:undef\n            ans[name] = self.captures(name)\n        return ans\n\nclass RegexObject:\n\n    def __init__(self, pattern, flags):\n        self.pattern = pattern.source if isinstance(pattern, RegExp) else pattern\n        self.js_pattern, self.flags, self.group_name_map = transform_regex(self.pattern, flags)\n\n        modifiers = \'\'\n        if self.flags & IGNORECASE: modifiers += \'i\'\n        if self.flags & MULTILINE: modifiers += \'m\'\n        if not (self.flags & ASCII) and supports_unicode:\n            modifiers += \'u\'\n        self._modifiers = modifiers + \'g\'\n        self._pattern = RegExp(self.js_pattern, self._modifiers)\n\n    def _do_search(self, pat, string, pos, endpos):\n        pat.lastIndex = 0\n        if endpos is not None:\n            string = string[:endpos]\n        while True:\n            n = pat.exec(string)\n            if n is None:\n                return None\n            if n.index >= pos:\n                return MatchObject(self, n, pos, endpos)\n\n    def search(self, string, pos=0, endpos=None):\n        return self._do_search(self._pattern, string, pos, endpos)\n\n    def match(self, string, pos=0, endpos=None):\n        return self._do_search(RegExp(\'^\' + self.js_pattern, self._modifiers), string, pos, endpos)\n\n    def split(self, string, maxsplit=0):\n        self._pattern.lastIndex = 0\n        return string.split(self._pattern, maxsplit or undefined)\n\n    def findall(self, string):\n        self._pattern.lastIndex = 0\n        return RS_list_decorate(string.match(self._pattern) or v\'[]\')\n\n    def finditer(self, string):\n        # We have to copy pat since lastIndex is mutable\n        pat = RegExp(this._pattern.source, this._modifiers)  # noqa: unused-local\n        ans = v"{\'_string\':string, \'_r\':pat, \'_self\':self}"\n        ans[RS_iterator_symbol] = def():\n            return this\n        ans[\'next\'] = def():\n            m = this._r.exec(this._string)\n            if m is None:\n                return v"{\'done\':true}"\n            return v"{\'done\':false, \'value\':new MatchObject(this._self, m, 0, null)}"\n        return ans\n\n    def subn(self, repl, string, count=0):\n        expand = _expand\n        if jstype(repl) is \'function\':\n            expand = def(m, repl, gnm): return \'\' + repl(MatchObject(self, m, 0, None))\n        this._pattern.lastIndex = 0\n        num = 0\n        matches = v\'[]\'\n\n        while count < 1 or num < count:\n            m = this._pattern.exec(string)\n            if m is None:\n                break\n            matches.push(m)\n            num += 1\n\n        for v\'var i = matches.length - 1; i > -1; i--\':\n            m = matches[i]  # noqa:undef\n            start = m.index\n            end = start + m[0].length\n            string = string[:start] + expand(m, repl, self.group_name_map) + string[end:]\n        return string, matches.length\n\n    def sub(self, repl, string, count=0):\n        return self.subn(repl, string, count)[0]\n\ndef _get_from_cache(pattern, flags):\n    if isinstance(pattern, RegExp):\n        pattern = pattern.source\n    key = JSON.stringify(v\'[pattern, flags]\')\n    if has_prop(_re_cache_map, key):\n        return _re_cache_map[key]\n    if _re_cache_items.length >= 100:\n        v\'delete _re_cache_map[_re_cache_items.shift()]\'\n    ans = RegexObject(pattern, flags)\n    _re_cache_map[key] = ans\n    _re_cache_items.push(key)\n    return ans\n\ndef compile(pattern, flags=0):\n    return _get_from_cache(pattern, flags)\n\ndef search(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).search(string)\n\ndef match(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).match(string)\n\ndef split(pattern, string, maxsplit=0, flags=0):\n    return _get_from_cache(pattern, flags).split(string)\n\ndef findall(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).finditer(string)\n\ndef sub(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).sub(repl, string, count)\n\ndef subn(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).subn(repl, string, count)\n\ndef escape(string):\n    return string.replace(_RE_ESCAPE, \'\\\\$&\')\n\ndef purge():\n    nonlocal _re_cache_map, _re_cache_items\n    _re_cache_map = {}\n    _re_cache_items = v\'[]\'\n',"__stdlib__/traceback.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n# globals: RS_str, RS_last_exception\n\ndef _get_internal_traceback(err):\n    if isinstance(err, Exception) and err.stack:\n        lines = RS_str.splitlines(err.stack)\n        for i, line in enumerate(lines):\n            line = RS_str.strip(line)\n            # These two conditions work on desktop Chrome and Firefox to identify the correct\n            # line in the traceback.\n            if line.startsWith('at new ' + err.name) or line.startsWith(err.name + '@'):\n                return err.__repr__() + '\\n' +  lines.slice(i+1).join('\\n')\n    return err and err.stack\n\ndef format_exception(exc, limit):\n    if not isinstance(exc, Error):\n        if exc and exc.toString:\n            return [exc.toString()]\n        return []\n    tb = _get_internal_traceback(exc)\n    if tb:\n        lines = RS_str.splitlines(tb)\n        e = lines[0]\n        lines = [l for l in lines[1:]]\n        if limit:\n            lines = lines[:limit+1] if limit > 0 else lines[limit:]\n        lines.reverse()\n        lines.push(e)\n        lines.insert(0, 'Traceback (most recent call last):')\n        return [l+'\\n' for l in lines]\n    return [exc.toString()]\n\ndef format_exc(limit):\n    return format_exception(RS_last_exception, limit).join('')\n\ndef print_exc(limit):\n    print(format_exc(limit))\n\ndef format_stack(limit):\n    stack = Error().stack\n    if not stack:\n        return []\n    lines = str.splitlines(stack)[2:]\n    lines.reverse()\n    if limit:\n        lines = lines[:limit+1] if limit > 0 else lines[limit:]\n    return [l + '\\n' for l in lines]\n\ndef print_stack(limit):\n    print(format_stack(limit).join(''))\n","__stdlib__/uuid.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2017, Kovid Goyal <kovid at kovidgoyal.net>\n# globals: crypto\nfrom __python__ import hash_literals\n\nfrom encodings import hexlify, urlsafe_b64decode, urlsafe_b64encode\n\nRFC_4122 = 1\n\nif jstype(crypto) is 'object' and crypto.getRandomValues:\n    random_bytes = def (num):\n        ans = Uint8Array(num or 16)\n        crypto.getRandomValues(ans)\n        return ans\nelse:\n    random_bytes = def (num):\n        ans = Uint8Array(num or 16)\n        for i in range(ans.length):\n            ans[i] = Math.floor(Math.random() * 256)\n        return ans\n\n\ndef uuid4_bytes():\n    data = random_bytes()\n    data[6] = 0b01000000 | (data[6] & 0b1111)\n    data[8] = (((data[8] >> 4) & 0b11 | 0b1000) << 4) | (data[8] & 0b1111)\n    return data\n\n\ndef as_str():\n    h = this.hex\n    return h[:8] + '-' + h[8:12] + '-' + h[12:16] + '-' + h[16:20] + '-' + h[20:]\n\n\ndef uuid4():\n    b = uuid4_bytes()\n    return {\n        'hex': hexlify(b),\n        'bytes': b,\n        'variant': RFC_4122,\n        'version': 4,\n        '__str__': as_str,\n        'toString': as_str,\n    }\n\n\ndef num_to_string(numbers, alphabet, pad_to_length):\n    ans = v'[]'\n    alphabet_len = alphabet.length\n    numbers = Array.prototype.slice.call(numbers)\n    for v'var i = 0; i < numbers.length - 1; i++':\n        x = divmod(numbers[i], alphabet_len)\n        numbers[i] = x[0]\n        numbers[i+1] += x[1]\n    for v'var i = 0; i < numbers.length; i++':\n        number = numbers[i]\n        while number:\n            x = divmod(number, alphabet_len)\n            number = x[0]\n            ans.push(alphabet[x[1]])\n    if pad_to_length and pad_to_length > ans.length:\n        ans.push(alphabet[0].repeat(pad_to_length - ans.length))\n    return ans.join('')\n\n\ndef short_uuid():\n    # A totally random uuid encoded using only URL and filename safe characters\n    return urlsafe_b64encode(random_bytes(), '')\n\n\ndef short_uuid4():\n    # A uuid4 encoded using only URL and filename safe characters\n    return urlsafe_b64encode(uuid4_bytes(), '')\n\n\ndef decode_short_uuid(val):\n    return urlsafe_b64decode(val + '==')\n"};var namespace={},jsSHA={};var write_cache={};var builtin_modules={crypto:{createHash:function create_hash(){var ans=new jsSHA.jsSHA("SHA-1","TEXT");ans.digest=function hex_digest(){return ans.getHash("HEX")};return ans}},vm:{createContext:function create_context(ctx){var iframe=document.createElement("iframe");iframe.style.display="none";document.body.appendChild(iframe);var win=iframe.contentWindow;if(!ctx)ctx={};if(!ctx.sha1sum)ctx.sha1sum=sha1sum;if(!ctx.require)ctx.require=require;Object.keys(ctx).forEach(function(k){win[k]=ctx[k]});return win},runInContext:function run_in_context(code,ctx){return ctx.eval(code)},runInThisContext:eval},path:{join:function path_join(){return Array.prototype.slice.call(arguments).join("/")},dirname:function path_dirname(path){return path.split("/").slice(0,-1).join("/")}},inspect:function inspect(x){return x.toString()},fs:{readFileSync:function readfile(name){var data=namespace.file_data[name];if(data)return data;data=write_cache[name];if(data)return data;var err=Error();err.code="ENOENT";throw err},writeFileSync:function writefile(name,data){write_cache[name]=data}}};function require(name){return builtin_modules[name]||{}}(function(){(function(G){function x(b,a,d){var c=0,e=[],h=0,l=!1,f=[],g=[],q=!1;d=d||{};var r=d.encoding||"UTF8";var k=d.numRounds||1;if(k!==parseInt(k,10)||1>k)throw Error("numRounds must a integer >= 1");if("SHA-1"===b){var n=512;var y=z;var m=H;var p=160;var t=function(c){return c.slice()}}else throw Error("Chosen SHA variant is not supported");var v=A(a,r);var u=w(b);this.setHMACKey=function(e,a,d){if(!0===l)throw Error("HMAC key already set");if(!0===q)throw Error("Cannot set HMAC key after calling update");r=(d||{}).encoding||"UTF8";a=A(a,r)(e);e=a.binLen;a=a.value;var h=n>>>3;d=h/4-1;if(h<e/8){for(a=m(a,e,0,w(b),p);a.length<=d;)a.push(0);a[d]&=4294967040}else if(h>e/8){for(;a.length<=d;)a.push(0);a[d]&=4294967040}for(e=0;e<=d;e+=1)f[e]=a[e]^909522486,g[e]=a[e]^1549556828;u=y(f,u);c=n;l=!0};this.update=function(a){var d,b=0,l=n>>>5;var f=v(a,e,h);a=f.binLen;var g=f.value;f=a>>>5;for(d=0;d<f;d+=l)b+n<=a&&(u=y(g.slice(d,d+l),u),b+=n);c+=b;e=g.slice(b>>>5);h=a%n;q=!0};this.getHash=function(a,d){if(!0===l)throw Error("Cannot call getHash after setting HMAC key");var f=B(d);switch(a){case"HEX":a=function(a){return C(a,p,f)};break;case"B64":a=function(a){return D(a,p,f)};break;case"BYTES":a=function(a){return E(a,p)};break;case"ARRAYBUFFER":try{d=new ArrayBuffer(0)}catch(I){throw Error("ARRAYBUFFER not supported by this environment")}a=function(a){return F(a,p)};break;default:throw Error("format must be HEX, B64, BYTES, or ARRAYBUFFER")}var g=m(e.slice(),h,c,t(u),p);for(d=1;d<k;d+=1)g=m(g,p,0,w(b),p);return a(g)};this.getHMAC=function(a,d){if(!1===l)throw Error("Cannot call getHMAC without first setting HMAC key");var f=B(d);switch(a){case"HEX":a=function(a){return C(a,p,f)};break;case"B64":a=function(a){return D(a,p,f)};break;case"BYTES":a=function(a){return E(a,p)};break;case"ARRAYBUFFER":try{a=new ArrayBuffer(0)}catch(I){throw Error("ARRAYBUFFER not supported by this environment")}a=function(a){return F(a,p)};break;default:throw Error("outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER")}d=m(e.slice(),h,c,t(u),p);var k=y(g,w(b));k=m(d,p,n,k,p);return a(k)}}function C(b,a,d){var c="";a/=8;var e;for(e=0;e<a;e+=1){var h=b[e>>>2]>>>8*(3+e%4*-1);c+="0123456789abcdef".charAt(h>>>4&15)+"0123456789abcdef".charAt(h&15)}return d.outputUpper?c.toUpperCase():c}function D(b,a,d){var c="",e=a/8,h;for(h=0;h<e;h+=3){var l=h+1<e?b[h+1>>>2]:0;var f=h+2<e?b[h+2>>>2]:0;f=(b[h>>>2]>>>8*(3+h%4*-1)&255)<<16|(l>>>8*(3+(h+1)%4*-1)&255)<<8|f>>>8*(3+(h+2)%4*-1)&255;for(l=0;4>l;l+=1)8*h+6*l<=a?c+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f>>>6*(3-l)&63):c+=d.b64Pad}return c}function E(b,a){var d="";a/=8;var c;for(c=0;c<a;c+=1){var e=b[c>>>2]>>>8*(3+c%4*-1)&255;d+=String.fromCharCode(e)}return d}function F(b,a){a/=8;var d,c=new ArrayBuffer(a);var e=new Uint8Array(c);for(d=0;d<a;d+=1)e[d]=b[d>>>2]>>>8*(3+d%4*-1)&255;return c}function B(b){var a={outputUpper:!1,b64Pad:"=",shakeLen:-1};b=b||{};a.outputUpper=b.outputUpper||!1;!0===b.hasOwnProperty("b64Pad")&&(a.b64Pad=b.b64Pad);b.hasOwnProperty("shakeLen");if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function A(b,a){switch(a){case"UTF8":case"UTF16BE":case"UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE")}switch(b){case"HEX":b=function(a,c,e){var d=a.length,b,f;if(d%2)throw Error("String of HEX type must be in byte increments");c=c||[0];e=e||0;var g=e>>>3;for(b=0;b<d;b+=2){var q=parseInt(a.substr(b,2),16);if(isNaN(q))throw Error("String of HEX type contains invalid characters");var r=(b>>>1)+g;for(f=r>>>2;c.length<=f;)c.push(0);c[f]|=q<<8*(3+r%4*-1)}return{value:c,binLen:4*d+e}};break;case"TEXT":b=function(d,c,e){var b=0,l,f,g;c=c||[0];e=e||0;var q=e>>>3;if("UTF8"===a){var r=3;for(l=0;l<d.length;l+=1){var k=d.charCodeAt(l);var n=[];128>k?n.push(k):2048>k?(n.push(192|k>>>6),n.push(128|k&63)):55296>k||57344<=k?n.push(224|k>>>12,128|k>>>6&63,128|k&63):(l+=1,k=65536+((k&1023)<<10|d.charCodeAt(l)&1023),n.push(240|k>>>18,128|k>>>12&63,128|k>>>6&63,128|k&63));for(f=0;f<n.length;f+=1){var m=b+q;for(g=m>>>2;c.length<=g;)c.push(0);c[g]|=n[f]<<8*(r+m%4*-1);b+=1}}}else if("UTF16BE"===a||"UTF16LE"===a)for(r=2,n="UTF16LE"===a&&!0||"UTF16LE"!==a&&!1,l=0;l<d.length;l+=1){k=d.charCodeAt(l);!0===n&&(f=k&255,k=f<<8|k>>>8);m=b+q;for(g=m>>>2;c.length<=g;)c.push(0);c[g]|=k<<8*(r+m%4*-1);b+=2}return{value:c,binLen:8*b+e}};break;case"B64":b=function(a,c,e){var d=0,b,f;if(-1===a.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");var g=a.indexOf("=");a=a.replace(/\=/g,"");if(-1!==g&&g<a.length)throw Error("Invalid '=' found in base-64 string");c=c||[0];e=e||0;var q=e>>>3;for(g=0;g<a.length;g+=4){var m=a.substr(g,4);for(b=f=0;b<m.length;b+=1){var k="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(m[b]);f|=k<<18-6*b}for(b=0;b<m.length-1;b+=1){var n=d+q;for(k=n>>>2;c.length<=k;)c.push(0);c[k]|=(f>>>16-8*b&255)<<8*(3+n%4*-1);d+=1}}return{value:c,binLen:8*d+e}};break;case"BYTES":b=function(a,c,b){var d;c=c||[0];b=b||0;var e=b>>>3;for(d=0;d<a.length;d+=1){var f=a.charCodeAt(d);var g=d+e;var m=g>>>2;c.length<=m&&c.push(0);c[m]|=f<<8*(3+g%4*-1)}return{value:c,binLen:8*a.length+b}};break;case"ARRAYBUFFER":try{b=new ArrayBuffer(0)}catch(d){throw Error("ARRAYBUFFER not supported by this environment")}b=function(a,c,b){var d;c=c||[0];b=b||0;var e=b>>>3;var f=new Uint8Array(a);for(d=0;d<a.byteLength;d+=1){var g=d+e;var m=g>>>2;c.length<=m&&c.push(0);c[m]|=f[d]<<8*(3+g%4*-1)}return{value:c,binLen:8*a.byteLength+b}};break;default:throw Error("format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER")}return b}function m(b,a){return b<<a|b>>>32-a}function t(b,a){var d=(b&65535)+(a&65535);return((b>>>16)+(a>>>16)+(d>>>16)&65535)<<16|d&65535}function v(b,a,d,c,e){var h=(b&65535)+(a&65535)+(d&65535)+(c&65535)+(e&65535);return((b>>>16)+(a>>>16)+(d>>>16)+(c>>>16)+(e>>>16)+(h>>>16)&65535)<<16|h&65535}function w(b){if("SHA-1"===b)b=[1732584193,4023233417,2562383102,271733878,3285377520];else throw Error("No SHA variants supported");return b}function z(b,a){var d=[],c;var e=a[0];var h=a[1];var l=a[2];var f=a[3];var g=a[4];for(c=0;80>c;c+=1){d[c]=16>c?b[c]:m(d[c-3]^d[c-8]^d[c-14]^d[c-16],1);var q=20>c?v(m(e,5),h&l^~h&f,g,1518500249,d[c]):40>c?v(m(e,5),h^l^f,g,1859775393,d[c]):60>c?v(m(e,5),h&l^h&f^l&f,g,2400959708,d[c]):v(m(e,5),h^l^f,g,3395469782,d[c]);g=f;f=l;l=m(h,30);h=e;e=q}a[0]=t(e,a[0]);a[1]=t(h,a[1]);a[2]=t(l,a[2]);a[3]=t(f,a[3]);a[4]=t(g,a[4]);return a}function H(b,a,d,c){var e;for(e=(a+65>>>9<<4)+15;b.length<=e;)b.push(0);b[a>>>5]|=128<<24-a%32;a+=d;b[e]=a&4294967295;b[e-1]=a/4294967296|0;a=b.length;for(e=0;e<a;e+=16)c=z(b.slice(e,e+16),c);return c}"undefined"!==typeof exports?("undefined"!==typeof module&&module.exports&&(module.exports=x),exports=x):G.jsSHA=x})(this)}).call(jsSHA);var exports=namespace;var vm=require("vm");var native_require=require;function normalize_array(parts,allowAboveRoot){var res=[];for(var i=0;i<parts.length;i++){var p=parts[i];if(!p||p===".")continue;if(p===".."){if(res.length&&res[res.length-1]!==".."){res.pop()}else if(allowAboveRoot){res.push("..")}}else{res.push(p)}}return res}function normalize(path){var is_abs=path&&path[0]==="/";var trailing_slash=path&&path[path.length-1]==="/";path=normalize_array(path.split("/"),!is_abs).join("/");if(!path&&!is_abs){path="."}if(path&&trailing_slash){path+="/"}return(is_abs?"/":"")+path}function dirname(path){var idx=path.lastIndexOf("/");if(idx!=-1)path=path.slice(0,idx);else path="";return path}function basename(path){var idx=path.lastIndexOf("/");if(idx!=-1)path=path.slice(idx+1);return path}var cache={};function load(filepath){var cached=cache[filepath];if(cached)return cached.exports;var module={id:filepath,exports:{}};cache[filepath]=module;var content=data[filepath];if(Array.isArray(content))content=data[content[0]];if(!content)throw"Failed to load: "+JSON.stringify(filepath);if(filepath.slice(-5)==".json"){module.exports=JSON.parse(content);return module.exports}var base=dirname(filepath);function mrequire(x){return vrequire(x,base)}content=content.replace(/^\#\!.*/,"");var wrapped="(function(exports, require, module, __filename, __dirname, create_rapydscript_compiler) { ";wrapped+=content+"\n;})";try{vm.runInThisContext(wrapped,{filename:filepath})(module.exports,mrequire,module,filepath,dirname(filepath),create_compiler)}catch(e){console.error(e);delete cache[filepath];throw e}return module.exports}function has(x,y){return Object.prototype.hasOwnProperty.call(x,y)}function try_files(candidate){if(has(data,candidate))return candidate;if(has(data,candidate+".js"))return candidate+".js";if(has(data,candidate+".json"))return candidate+".json";return null}function find_in_modules_dir(name,base){var candidate=normalize(base+(base?"/":"")+"node_modules/"+name);var q=try_files(candidate);if(q)return q;var pj=candidate+"/package.json";if(has(data,pj)){var ans=normalize(candidate+"/"+JSON.parse(data[pj]).main);if(has(data,ans))return ans}var index=candidate+"/index.js";if(has(data,index))return index;var p=dirname(base);if(p)return find_in_modules_dir(name,p);return null}function find_module(name,base){if(name[0]=="/")throw"Cannot find absolute module: "+name;if(name.slice(0,2)=="./"||name.slice(0,3)=="../"){var candidate=normalize((base?base+"/":base)+name);return try_files(candidate)}var q=try_files(name);if(q)return q;return find_in_modules_dir(name,base)}function vrequire(name,base){var exports={};var modpath="";base=base||"";if(!name)throw new Error("Cannot load a module from an empty name");modpath=find_module(name,base);if(!modpath&&name&&"./".indexOf(name[0])===-1){try{return native_require(name)}catch(e){}}if(!modpath)throw new Error("Failed to find module: "+JSON.stringify(name)+" with base: "+JSON.stringify(base));return load(modpath)}var UglifyJS=null,regenerator=null;var crypto=null,fs=require("fs");function uglify(x){if(!UglifyJS)UglifyJS=vrequire("uglify-js");ans=UglifyJS.minify(x);if(ans.error)throw ans.error;return ans.code}function regenerate(code,beautify){var orig=fs.readFileSync;fs.readFileSync=function(name){if(!has(data,name)){throw{message:"Failed to readfile from data: "+name}}return data[name]};if(!regenerator)regenerator=vrequire("regenerator");var ans;if(code){try{ans=regenerator.compile(code).code}catch(e){console.error("regenerator failed for code: "+code+"with error stack:\n"+e.stack);throw e}if(!beautify)ans=uglify(ans)}else{ans=regenerator.compile("",{includeRuntime:true}).code;start=ans.indexOf("!");end=ans.lastIndexOf("})(");end=ans.lastIndexOf("})(",end-1);ans=ans.slice(start+1,end);if(!beautify){var extra="})()";ans=uglify(ans+extra).slice(0,extra.length)}}fs.readFileSync=orig;return ans}if(typeof this!="object"||typeof this.sha1sum!=="function"){var sha1sum=function(data){if(!crypto)crypto=require("crypto");var h=crypto.createHash("sha1");h.update(data);return h.digest("hex")}}else var sha1sum=this.sha1sum;function create_compiler(){var compilerjs=data["compiler.js"];var module={id:"compiler",exports:{}};var wrapped="(function(module, exports, readfile, writefile, sha1sum, regenerate) {"+data["compiler.js"]+";\n})";vm.runInThisContext(wrapped,{filename:"compiler.js"})(module,module.exports,fs.readFileSync,fs.writeFileSync,sha1sum,regenerate);return module.exports}var RapydScript=null;function compile(code,filename,options){if(!RapydScript)RapydScript=create_compiler();options=options||{};var ast=RapydScript.parse(code,{filename:filename||"<eval>",basedir:options.basedir||dirname(filename||""),libdir:options.libdir});var out_ops={beautify:options.beautify===undefined?true:options.beautify,private_scope:!options.bare,omit_baselib:!!options.omit_baselib,js_version:options.js_version||5};if(!out_ops.omit_baselib)out_ops.baselib_plain=data["baselib-plain-"+(out_ops.beautify?"pretty":"ugly")+".js"];var out=new RapydScript.OutputStream(out_ops);ast.print(out);return out.get()}function create_embedded_compiler(runjs){var c=vrequire("tools/embedded_compiler.js");return c(create_compiler(),data["baselib-plain-pretty.js"],runjs)}function web_repl(){var repl=vrequire("tools/web_repl.js");return repl(create_compiler(),data["baselib-plain-pretty.js"])}function init_repl(options){var repl=vrequire("tools/repl.js");options.baselib=data["baselib-plain-pretty.js"];return repl(options)}function gettext_parse(catalog,code,filename){g=vrequire("tools/gettext.js");g.gettext(catalog,code,filename)}function gettext_output(catalog,options,write){g=vrequire("tools/gettext.js");g.write_output(catalog,options,write)}function msgfmt(data,options){m=vrequire("tools/msgfmt.js");return m.build(data,options)}function completer(compiler,options){m=vrequire("tools/completer.js");return m(compiler,options)}if(typeof exports==="object"){exports.compile=compile;exports.create_embedded_compiler=create_embedded_compiler;exports.web_repl=web_repl;exports.init_repl=init_repl;exports.gettext_parse=gettext_parse;exports.gettext_output=gettext_output;exports.msgfmt=msgfmt;exports.rs_version=rs_version;exports.file_data=data;exports.completer=completer;if(typeof rs_commit_sha==="string")exports.rs_commit_sha=rs_commit_sha}external_namespace.RapydScript=namespace})(this);(function(){"use strict";var reservedWords={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"};var ecma5AndLessKeywords="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";var keywords={5:ecma5AndLessKeywords,6:ecma5AndLessKeywords+" const class extends export import super"};var nonASCIIidentifierStartChars="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞮꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";var nonASCIIidentifierChars="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣔ-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";var nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]");var nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;var astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];var astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];function isInAstralSet(code,set){var pos=65536;for(var i=0;i<set.length;i+=2){pos+=set[i];if(pos>code)return false;pos+=set[i+1];if(pos>=code)return true}}function isIdentifierStart(code,astral){if(code<65)return code===36;if(code<91)return true;if(code<97)return code===95;if(code<123)return true;if(code<=65535)return code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code));if(astral===false)return false;return isInAstralSet(code,astralIdentifierStartCodes)}function isIdentifierChar(code,astral){if(code<48)return code===36;if(code<58)return true;if(code<65)return false;if(code<91)return true;if(code<97)return code===95;if(code<123)return true;if(code<=65535)return code>=170&&nonASCIIidentifier.test(String.fromCharCode(code));if(astral===false)return false;return isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes)}var TokenType=function TokenType(label,conf){if(conf===void 0)conf={};this.label=label;this.keyword=conf.keyword;this.beforeExpr=!!conf.beforeExpr;this.startsExpr=!!conf.startsExpr;this.isLoop=!!conf.isLoop;this.isAssign=!!conf.isAssign;this.prefix=!!conf.prefix;this.postfix=!!conf.postfix;this.binop=conf.binop||null;this.updateContext=null};function binop(name,prec){return new TokenType(name,{beforeExpr:true,binop:prec})}var beforeExpr={beforeExpr:true};var startsExpr={startsExpr:true};var keywordTypes={};function kw(name,options){if(options===void 0)options={};options.keyword=name;return keywordTypes[name]=new TokenType(name,options)}var tt={num:new TokenType("num",startsExpr),regexp:new TokenType("regexp",startsExpr),string:new TokenType("string",startsExpr),name:new TokenType("name",startsExpr),eof:new TokenType("eof"),bracketL:new TokenType("[",{beforeExpr:true,startsExpr:true}),bracketR:new TokenType("]"),braceL:new TokenType("{",{beforeExpr:true,startsExpr:true}),braceR:new TokenType("}"),parenL:new TokenType("(",{beforeExpr:true,startsExpr:true}),parenR:new TokenType(")"),comma:new TokenType(",",beforeExpr),semi:new TokenType(";",beforeExpr),colon:new TokenType(":",beforeExpr),dot:new TokenType("."),question:new TokenType("?",beforeExpr),arrow:new TokenType("=>",beforeExpr),template:new TokenType("template"),ellipsis:new TokenType("...",beforeExpr),backQuote:new TokenType("`",startsExpr),dollarBraceL:new TokenType("${",{beforeExpr:true,startsExpr:true}),eq:new TokenType("=",{beforeExpr:true,isAssign:true}),assign:new TokenType("_=",{beforeExpr:true,isAssign:true}),incDec:new TokenType("++/--",{prefix:true,postfix:true,startsExpr:true}),prefix:new TokenType("prefix",{beforeExpr:true,prefix:true,startsExpr:true}),logicalOR:binop("||",1),logicalAND:binop("&&",2),bitwiseOR:binop("|",3),bitwiseXOR:binop("^",4),bitwiseAND:binop("&",5),equality:binop("==/!=",6),relational:binop("</>",7),bitShift:binop("<</>>",8),plusMin:new TokenType("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:binop("%",10),star:binop("*",10),slash:binop("/",10),starstar:new TokenType("**",{beforeExpr:true}),_break:kw("break"),_case:kw("case",beforeExpr),_catch:kw("catch"),_continue:kw("continue"),_debugger:kw("debugger"),_default:kw("default",beforeExpr),_do:kw("do",{isLoop:true,beforeExpr:true}),_else:kw("else",beforeExpr),_finally:kw("finally"),_for:kw("for",{isLoop:true}),_function:kw("function",startsExpr),_if:kw("if"),_return:kw("return",beforeExpr),_switch:kw("switch"),_throw:kw("throw",beforeExpr),_try:kw("try"),_var:kw("var"),_const:kw("const"),_while:kw("while",{isLoop:true}),_with:kw("with"),_new:kw("new",{beforeExpr:true,startsExpr:true}),_this:kw("this",startsExpr),_super:kw("super",startsExpr),_class:kw("class"),_extends:kw("extends",beforeExpr),_export:kw("export"),_import:kw("import"),_null:kw("null",startsExpr),_true:kw("true",startsExpr),_false:kw("false",startsExpr),_in:kw("in",{beforeExpr:true,binop:7}),_instanceof:kw("instanceof",{beforeExpr:true,binop:7}),_typeof:kw("typeof",{beforeExpr:true,prefix:true,startsExpr:true}),_void:kw("void",{beforeExpr:true,prefix:true,startsExpr:true}),_delete:kw("delete",{beforeExpr:true,prefix:true,startsExpr:true})};var lineBreak=/\r\n?|\n|\u2028|\u2029/;var lineBreakG=new RegExp(lineBreak.source,"g");function isNewLine(code){return code===10||code===13||code===8232||code===8233}var nonASCIIwhitespace=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;var skipWhiteSpace=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;function isArray(obj){return Object.prototype.toString.call(obj)==="[object Array]"}function has(obj,propName){return Object.prototype.hasOwnProperty.call(obj,propName)}var Position=function Position(line,col){this.line=line;this.column=col};Position.prototype.offset=function offset(n){return new Position(this.line,this.column+n)};var SourceLocation=function SourceLocation(p,start,end){this.start=start;this.end=end;if(p.sourceFile!==null)this.source=p.sourceFile};function getLineInfo(input,offset){for(var line=1,cur=0;;){lineBreakG.lastIndex=cur;var match=lineBreakG.exec(input);if(match&&match.index<offset){++line;cur=match.index+match[0].length}else{return new Position(line,offset-cur)}}}var defaultOptions={ecmaVersion:7,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:false,allowImportExportEverywhere:false,allowHashBang:false,locations:false,onToken:null,onComment:null,ranges:false,program:null,sourceFile:null,directSourceFile:null,preserveParens:false,plugins:{}};function getOptions(opts){var options={};for(var opt in defaultOptions)options[opt]=opts&&has(opts,opt)?opts[opt]:defaultOptions[opt];if(options.ecmaVersion>=2015)options.ecmaVersion-=2009;if(options.allowReserved==null)options.allowReserved=options.ecmaVersion<5;if(isArray(options.onToken)){var tokens=options.onToken;options.onToken=function(token){return tokens.push(token)}}if(isArray(options.onComment))options.onComment=pushComment(options,options.onComment);return options}function pushComment(options,array){return function(block,text,start,end,startLoc,endLoc){var comment={type:block?"Block":"Line",value:text,start:start,end:end};if(options.locations)comment.loc=new SourceLocation(this,startLoc,endLoc);if(options.ranges)comment.range=[start,end];array.push(comment)}}var plugins={};function keywordRegexp(words){return new RegExp("^("+words.replace(/ /g,"|")+")$")}var Parser=function Parser(options,input,startPos){this.options=options=getOptions(options);this.sourceFile=options.sourceFile;this.keywords=keywordRegexp(keywords[options.ecmaVersion>=6?6:5]);var reserved="";if(!options.allowReserved){for(var v=options.ecmaVersion;;v--)if(reserved=reservedWords[v])break;if(options.sourceType=="module")reserved+=" await"}this.reservedWords=keywordRegexp(reserved);var reservedStrict=(reserved?reserved+" ":"")+reservedWords.strict;this.reservedWordsStrict=keywordRegexp(reservedStrict);this.reservedWordsStrictBind=keywordRegexp(reservedStrict+" "+reservedWords.strictBind);this.input=String(input);this.containsEsc=false;this.loadPlugins(options.plugins);if(startPos){this.pos=startPos;this.lineStart=this.input.lastIndexOf("\n",startPos-1)+1;this.curLine=this.input.slice(0,this.lineStart).split(lineBreak).length}else{this.pos=this.lineStart=0;this.curLine=1}this.type=tt.eof;this.value=null;this.start=this.end=this.pos;this.startLoc=this.endLoc=this.curPosition();this.lastTokEndLoc=this.lastTokStartLoc=null;this.lastTokStart=this.lastTokEnd=this.pos;this.context=this.initialContext();this.exprAllowed=true;this.strict=this.inModule=options.sourceType==="module";this.potentialArrowAt=-1;this.inFunction=this.inGenerator=this.inAsync=false;this.yieldPos=this.awaitPos=0;this.labels=[];if(this.pos===0&&options.allowHashBang&&this.input.slice(0,2)==="#!")this.skipLineComment(2)};Parser.prototype.isKeyword=function isKeyword(word){return this.keywords.test(word)};Parser.prototype.isReservedWord=function isReservedWord(word){return this.reservedWords.test(word)};Parser.prototype.extend=function extend(name,f){this[name]=f(this[name])};Parser.prototype.loadPlugins=function loadPlugins(pluginConfigs){var this$1=this;for(var name in pluginConfigs){var plugin=plugins[name];if(!plugin)throw new Error("Plugin '"+name+"' not found");plugin(this$1,pluginConfigs[name])}};Parser.prototype.parse=function parse(){var node=this.options.program||this.startNode();this.nextToken();return this.parseTopLevel(node)};var pp=Parser.prototype;pp.isUseStrict=function(stmt){return this.options.ecmaVersion>=5&&stmt.type==="ExpressionStatement"&&stmt.expression.type==="Literal"&&stmt.expression.raw.slice(1,-1)==="use strict"};pp.eat=function(type){if(this.type===type){this.next();return true}else{return false}};pp.isContextual=function(name){return this.type===tt.name&&this.value===name};pp.eatContextual=function(name){return this.value===name&&this.eat(tt.name)};pp.expectContextual=function(name){if(!this.eatContextual(name))this.unexpected()};pp.canInsertSemicolon=function(){return this.type===tt.eof||this.type===tt.braceR||lineBreak.test(this.input.slice(this.lastTokEnd,this.start))};pp.insertSemicolon=function(){if(this.canInsertSemicolon()){if(this.options.onInsertedSemicolon)this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc);return true}};pp.semicolon=function(){if(!this.eat(tt.semi)&&!this.insertSemicolon())this.unexpected()};pp.afterTrailingComma=function(tokType,notNext){if(this.type==tokType){if(this.options.onTrailingComma)this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc);if(!notNext)this.next();return true}};pp.expect=function(type){this.eat(type)||this.unexpected()};pp.unexpected=function(pos){this.raise(pos!=null?pos:this.start,"Unexpected token")};var DestructuringErrors=function DestructuringErrors(){this.shorthandAssign=0;this.trailingComma=0};pp.checkPatternErrors=function(refDestructuringErrors,andThrow){var trailing=refDestructuringErrors&&refDestructuringErrors.trailingComma;if(!andThrow)return!!trailing;if(trailing)this.raise(trailing,"Comma is not permitted after the rest element")};pp.checkExpressionErrors=function(refDestructuringErrors,andThrow){var pos=refDestructuringErrors&&refDestructuringErrors.shorthandAssign;if(!andThrow)return!!pos;if(pos)this.raise(pos,"Shorthand property assignments are valid only in destructuring patterns")};pp.checkYieldAwaitInDefaultParams=function(){if(this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos))this.raise(this.yieldPos,"Yield expression cannot be a default value");if(this.awaitPos)this.raise(this.awaitPos,"Await expression cannot be a default value")};var pp$1=Parser.prototype;pp$1.parseTopLevel=function(node){var this$1=this;var first=true,exports={};if(!node.body)node.body=[];while(this.type!==tt.eof){var stmt=this$1.parseStatement(true,true,exports);node.body.push(stmt);if(first){if(this$1.isUseStrict(stmt))this$1.setStrict(true);first=false}}this.next();if(this.options.ecmaVersion>=6){node.sourceType=this.options.sourceType}return this.finishNode(node,"Program")};var loopLabel={kind:"loop"};var switchLabel={kind:"switch"};pp$1.isLet=function(){if(this.type!==tt.name||this.options.ecmaVersion<6||this.value!="let")return false;skipWhiteSpace.lastIndex=this.pos;var skip=skipWhiteSpace.exec(this.input);var next=this.pos+skip[0].length,nextCh=this.input.charCodeAt(next);if(nextCh===91||nextCh==123)return true;if(isIdentifierStart(nextCh,true)){for(var pos=next+1;isIdentifierChar(this.input.charCodeAt(pos),true);++pos){}var ident=this.input.slice(next,pos);if(!this.isKeyword(ident))return true}return false};pp$1.isAsyncFunction=function(){if(this.type!==tt.name||this.options.ecmaVersion<8||this.value!="async")return false;skipWhiteSpace.lastIndex=this.pos;var skip=skipWhiteSpace.exec(this.input);var next=this.pos+skip[0].length;return!lineBreak.test(this.input.slice(this.pos,next))&&this.input.slice(next,next+8)==="function"&&(next+8==this.input.length||!isIdentifierChar(this.input.charAt(next+8)))};pp$1.parseStatement=function(declaration,topLevel,exports){var starttype=this.type,node=this.startNode(),kind;if(this.isLet()){starttype=tt._var;kind="let"}switch(starttype){case tt._break:case tt._continue:return this.parseBreakContinueStatement(node,starttype.keyword);case tt._debugger:return this.parseDebuggerStatement(node);case tt._do:return this.parseDoStatement(node);case tt._for:return this.parseForStatement(node);case tt._function:if(!declaration&&this.options.ecmaVersion>=6)this.unexpected();return this.parseFunctionStatement(node,false);case tt._class:if(!declaration)this.unexpected();return this.parseClass(node,true);case tt._if:return this.parseIfStatement(node);case tt._return:return this.parseReturnStatement(node);case tt._switch:return this.parseSwitchStatement(node);case tt._throw:return this.parseThrowStatement(node);case tt._try:return this.parseTryStatement(node);case tt._const:case tt._var:kind=kind||this.value;if(!declaration&&kind!="var")this.unexpected();return this.parseVarStatement(node,kind);case tt._while:return this.parseWhileStatement(node);case tt._with:return this.parseWithStatement(node);case tt.braceL:return this.parseBlock();case tt.semi:return this.parseEmptyStatement(node);case tt._export:case tt._import:if(!this.options.allowImportExportEverywhere){if(!topLevel)this.raise(this.start,"'import' and 'export' may only appear at the top level");if(!this.inModule)this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")}return starttype===tt._import?this.parseImport(node):this.parseExport(node,exports);default:if(this.isAsyncFunction()&&declaration){this.next();return this.parseFunctionStatement(node,true)}var maybeName=this.value,expr=this.parseExpression();if(starttype===tt.name&&expr.type==="Identifier"&&this.eat(tt.colon))return this.parseLabeledStatement(node,maybeName,expr);else return this.parseExpressionStatement(node,expr)}};pp$1.parseBreakContinueStatement=function(node,keyword){var this$1=this;var isBreak=keyword=="break";this.next();if(this.eat(tt.semi)||this.insertSemicolon())node.label=null;else if(this.type!==tt.name)this.unexpected();else{node.label=this.parseIdent();this.semicolon()}for(var i=0;i<this.labels.length;++i){var lab=this$1.labels[i];if(node.label==null||lab.name===node.label.name){if(lab.kind!=null&&(isBreak||lab.kind==="loop"))break;if(node.label&&isBreak)break}}if(i===this.labels.length)this.raise(node.start,"Unsyntactic "+keyword);return this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")};pp$1.parseDebuggerStatement=function(node){this.next();this.semicolon();return this.finishNode(node,"DebuggerStatement")};pp$1.parseDoStatement=function(node){this.next();this.labels.push(loopLabel);node.body=this.parseStatement(false);this.labels.pop();this.expect(tt._while);node.test=this.parseParenExpression();if(this.options.ecmaVersion>=6)this.eat(tt.semi);else this.semicolon();return this.finishNode(node,"DoWhileStatement")};pp$1.parseForStatement=function(node){this.next();this.labels.push(loopLabel);this.expect(tt.parenL);if(this.type===tt.semi)return this.parseFor(node,null);var isLet=this.isLet();if(this.type===tt._var||this.type===tt._const||isLet){var init$1=this.startNode(),kind=isLet?"let":this.value;this.next();this.parseVar(init$1,true,kind);this.finishNode(init$1,"VariableDeclaration");if((this.type===tt._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&init$1.declarations.length===1&&!(kind!=="var"&&init$1.declarations[0].init))return this.parseForIn(node,init$1);return this.parseFor(node,init$1)}var refDestructuringErrors=new DestructuringErrors;var init=this.parseExpression(true,refDestructuringErrors);if(this.type===tt._in||this.options.ecmaVersion>=6&&this.isContextual("of")){this.checkPatternErrors(refDestructuringErrors,true);this.toAssignable(init);this.checkLVal(init);return this.parseForIn(node,init)}else{this.checkExpressionErrors(refDestructuringErrors,true)}return this.parseFor(node,init)};pp$1.parseFunctionStatement=function(node,isAsync){this.next();return this.parseFunction(node,true,false,isAsync)};pp$1.isFunction=function(){return this.type===tt._function||this.isAsyncFunction()};pp$1.parseIfStatement=function(node){this.next();node.test=this.parseParenExpression();node.consequent=this.parseStatement(!this.strict&&this.isFunction());node.alternate=this.eat(tt._else)?this.parseStatement(!this.strict&&this.isFunction()):null;return this.finishNode(node,"IfStatement")};pp$1.parseReturnStatement=function(node){if(!this.inFunction&&!this.options.allowReturnOutsideFunction)this.raise(this.start,"'return' outside of function");this.next();if(this.eat(tt.semi)||this.insertSemicolon())node.argument=null;else{node.argument=this.parseExpression();this.semicolon()}return this.finishNode(node,"ReturnStatement")};pp$1.parseSwitchStatement=function(node){var this$1=this;this.next();node.discriminant=this.parseParenExpression();node.cases=[];this.expect(tt.braceL);this.labels.push(switchLabel);for(var cur,sawDefault=false;this.type!=tt.braceR;){if(this$1.type===tt._case||this$1.type===tt._default){var isCase=this$1.type===tt._case;if(cur)this$1.finishNode(cur,"SwitchCase");node.cases.push(cur=this$1.startNode());cur.consequent=[];this$1.next();if(isCase){cur.test=this$1.parseExpression()}else{if(sawDefault)this$1.raiseRecoverable(this$1.lastTokStart,"Multiple default clauses");sawDefault=true;cur.test=null}this$1.expect(tt.colon)}else{if(!cur)this$1.unexpected();cur.consequent.push(this$1.parseStatement(true))}}if(cur)this.finishNode(cur,"SwitchCase");this.next();this.labels.pop();return this.finishNode(node,"SwitchStatement")};pp$1.parseThrowStatement=function(node){this.next();if(lineBreak.test(this.input.slice(this.lastTokEnd,this.start)))this.raise(this.lastTokEnd,"Illegal newline after throw");node.argument=this.parseExpression();this.semicolon();return this.finishNode(node,"ThrowStatement")};var empty=[];pp$1.parseTryStatement=function(node){this.next();node.block=this.parseBlock();node.handler=null;if(this.type===tt._catch){var clause=this.startNode();this.next();this.expect(tt.parenL);clause.param=this.parseBindingAtom();this.checkLVal(clause.param,true);this.expect(tt.parenR);clause.body=this.parseBlock();node.handler=this.finishNode(clause,"CatchClause")}node.finalizer=this.eat(tt._finally)?this.parseBlock():null;if(!node.handler&&!node.finalizer)this.raise(node.start,"Missing catch or finally clause");return this.finishNode(node,"TryStatement")};pp$1.parseVarStatement=function(node,kind){this.next();this.parseVar(node,false,kind);this.semicolon();return this.finishNode(node,"VariableDeclaration")};pp$1.parseWhileStatement=function(node){this.next();node.test=this.parseParenExpression();this.labels.push(loopLabel);node.body=this.parseStatement(false);this.labels.pop();return this.finishNode(node,"WhileStatement")};pp$1.parseWithStatement=function(node){if(this.strict)this.raise(this.start,"'with' in strict mode");this.next();node.object=this.parseParenExpression();node.body=this.parseStatement(false);return this.finishNode(node,"WithStatement")};pp$1.parseEmptyStatement=function(node){this.next();return this.finishNode(node,"EmptyStatement")};pp$1.parseLabeledStatement=function(node,maybeName,expr){var this$1=this;for(var i=0;i<this.labels.length;++i)if(this$1.labels[i].name===maybeName)this$1.raise(expr.start,"Label '"+maybeName+"' is already declared");var kind=this.type.isLoop?"loop":this.type===tt._switch?"switch":null;for(var i$1=this.labels.length-1;i$1>=0;i$1--){var label=this$1.labels[i$1];if(label.statementStart==node.start){label.statementStart=this$1.start;label.kind=kind}else break}this.labels.push({name:maybeName,kind:kind,statementStart:this.start});node.body=this.parseStatement(true);this.labels.pop();node.label=expr;return this.finishNode(node,"LabeledStatement")};pp$1.parseExpressionStatement=function(node,expr){node.expression=expr;this.semicolon();return this.finishNode(node,"ExpressionStatement")};pp$1.parseBlock=function(allowStrict){var this$1=this;var node=this.startNode(),first=true,oldStrict;node.body=[];this.expect(tt.braceL);while(!this.eat(tt.braceR)){var stmt=this$1.parseStatement(true);node.body.push(stmt);if(first&&allowStrict&&this$1.isUseStrict(stmt)){oldStrict=this$1.strict;this$1.setStrict(this$1.strict=true)}first=false}if(oldStrict===false)this.setStrict(false);return this.finishNode(node,"BlockStatement")};pp$1.parseFor=function(node,init){node.init=init;this.expect(tt.semi);node.test=this.type===tt.semi?null:this.parseExpression();this.expect(tt.semi);node.update=this.type===tt.parenR?null:this.parseExpression();this.expect(tt.parenR);node.body=this.parseStatement(false);this.labels.pop();return this.finishNode(node,"ForStatement")};pp$1.parseForIn=function(node,init){var type=this.type===tt._in?"ForInStatement":"ForOfStatement";this.next();node.left=init;node.right=this.parseExpression();this.expect(tt.parenR);node.body=this.parseStatement(false);this.labels.pop();return this.finishNode(node,type)};pp$1.parseVar=function(node,isFor,kind){var this$1=this;node.declarations=[];node.kind=kind;for(;;){var decl=this$1.startNode();this$1.parseVarId(decl);if(this$1.eat(tt.eq)){decl.init=this$1.parseMaybeAssign(isFor)}else if(kind==="const"&&!(this$1.type===tt._in||this$1.options.ecmaVersion>=6&&this$1.isContextual("of"))){this$1.unexpected()}else if(decl.id.type!="Identifier"&&!(isFor&&(this$1.type===tt._in||this$1.isContextual("of")))){this$1.raise(this$1.lastTokEnd,"Complex binding patterns require an initialization value")}else{decl.init=null}node.declarations.push(this$1.finishNode(decl,"VariableDeclarator"));if(!this$1.eat(tt.comma))break}return node};pp$1.parseVarId=function(decl){decl.id=this.parseBindingAtom();this.checkLVal(decl.id,true)};pp$1.parseFunction=function(node,isStatement,allowExpressionBody,isAsync){this.initFunction(node);if(this.options.ecmaVersion>=6&&!isAsync)node.generator=this.eat(tt.star);if(this.options.ecmaVersion>=8)node.async=!!isAsync;if(isStatement)node.id=this.parseIdent();var oldInGen=this.inGenerator,oldInAsync=this.inAsync,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos;this.inGenerator=node.generator;this.inAsync=node.async;this.yieldPos=0;this.awaitPos=0;if(!isStatement&&this.type===tt.name)node.id=this.parseIdent();this.parseFunctionParams(node);this.parseFunctionBody(node,allowExpressionBody);this.inGenerator=oldInGen;this.inAsync=oldInAsync;this.yieldPos=oldYieldPos;this.awaitPos=oldAwaitPos;return this.finishNode(node,isStatement?"FunctionDeclaration":"FunctionExpression")};pp$1.parseFunctionParams=function(node){this.expect(tt.parenL);node.params=this.parseBindingList(tt.parenR,false,this.options.ecmaVersion>=8,true);this.checkYieldAwaitInDefaultParams()};pp$1.parseClass=function(node,isStatement){var this$1=this;this.next();this.parseClassId(node,isStatement);this.parseClassSuper(node);var classBody=this.startNode();var hadConstructor=false;classBody.body=[];this.expect(tt.braceL);while(!this.eat(tt.braceR)){if(this$1.eat(tt.semi))continue;var method=this$1.startNode();var isGenerator=this$1.eat(tt.star);var isAsync=false;var isMaybeStatic=this$1.type===tt.name&&this$1.value==="static";this$1.parsePropertyName(method);method.static=isMaybeStatic&&this$1.type!==tt.parenL;if(method.static){if(isGenerator)this$1.unexpected();isGenerator=this$1.eat(tt.star);this$1.parsePropertyName(method)}if(this$1.options.ecmaVersion>=8&&!isGenerator&&!method.computed&&method.key.type==="Identifier"&&method.key.name==="async"&&this$1.type!==tt.parenL&&!this$1.canInsertSemicolon()){isAsync=true;this$1.parsePropertyName(method)}method.kind="method";var isGetSet=false;if(!method.computed){var key=method.key;if(!isGenerator&&!isAsync&&key.type==="Identifier"&&this$1.type!==tt.parenL&&(key.name==="get"||key.name==="set")){isGetSet=true;method.kind=key.name;key=this$1.parsePropertyName(method)}if(!method.static&&(key.type==="Identifier"&&key.name==="constructor"||key.type==="Literal"&&key.value==="constructor")){if(hadConstructor)this$1.raise(key.start,"Duplicate constructor in the same class");if(isGetSet)this$1.raise(key.start,"Constructor can't have get/set modifier");if(isGenerator)this$1.raise(key.start,"Constructor can't be a generator");if(isAsync)this$1.raise(key.start,"Constructor can't be an async method");method.kind="constructor";hadConstructor=true}}this$1.parseClassMethod(classBody,method,isGenerator,isAsync);if(isGetSet){var paramCount=method.kind==="get"?0:1;if(method.value.params.length!==paramCount){var start=method.value.start;if(method.kind==="get")this$1.raiseRecoverable(start,"getter should have no params");else this$1.raiseRecoverable(start,"setter should have exactly one param")}else{if(method.kind==="set"&&method.value.params[0].type==="RestElement")this$1.raiseRecoverable(method.value.params[0].start,"Setter cannot use rest params")}}}node.body=this.finishNode(classBody,"ClassBody");return this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")};pp$1.parseClassMethod=function(classBody,method,isGenerator,isAsync){method.value=this.parseMethod(isGenerator,isAsync);classBody.body.push(this.finishNode(method,"MethodDefinition"))};pp$1.parseClassId=function(node,isStatement){node.id=this.type===tt.name?this.parseIdent():isStatement?this.unexpected():null};pp$1.parseClassSuper=function(node){node.superClass=this.eat(tt._extends)?this.parseExprSubscripts():null};pp$1.parseExport=function(node,exports){var this$1=this;this.next();if(this.eat(tt.star)){this.expectContextual("from");node.source=this.type===tt.string?this.parseExprAtom():this.unexpected();this.semicolon();return this.finishNode(node,"ExportAllDeclaration")}if(this.eat(tt._default)){this.checkExport(exports,"default",this.lastTokStart);var parens=this.type==tt.parenL;var expr=this.parseMaybeAssign();var needsSemi=true;if(!parens&&(expr.type=="FunctionExpression"||expr.type=="ClassExpression")){needsSemi=false;if(expr.id){expr.type=expr.type=="FunctionExpression"?"FunctionDeclaration":"ClassDeclaration"}}node.declaration=expr;if(needsSemi)this.semicolon();return this.finishNode(node,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement()){node.declaration=this.parseStatement(true);if(node.declaration.type==="VariableDeclaration")this.checkVariableExport(exports,node.declaration.declarations);else this.checkExport(exports,node.declaration.id.name,node.declaration.id.start);node.specifiers=[];node.source=null}else{node.declaration=null;node.specifiers=this.parseExportSpecifiers(exports);if(this.eatContextual("from")){node.source=this.type===tt.string?this.parseExprAtom():this.unexpected()}else{for(var i=0;i<node.specifiers.length;i++){if(this$1.keywords.test(node.specifiers[i].local.name)||this$1.reservedWords.test(node.specifiers[i].local.name)){this$1.unexpected(node.specifiers[i].local.start)}}node.source=null}this.semicolon()}return this.finishNode(node,"ExportNamedDeclaration")};pp$1.checkExport=function(exports,name,pos){if(!exports)return;if(Object.prototype.hasOwnProperty.call(exports,name))this.raiseRecoverable(pos,"Duplicate export '"+name+"'");exports[name]=true};pp$1.checkPatternExport=function(exports,pat){var this$1=this;var type=pat.type;if(type=="Identifier")this.checkExport(exports,pat.name,pat.start);else if(type=="ObjectPattern")for(var i=0;i<pat.properties.length;++i)this$1.checkPatternExport(exports,pat.properties[i].value);else if(type=="ArrayPattern")for(var i$1=0;i$1<pat.elements.length;++i$1){var elt=pat.elements[i$1];if(elt)this$1.checkPatternExport(exports,elt)}else if(type=="AssignmentPattern")this.checkPatternExport(exports,pat.left);else if(type=="ParenthesizedExpression")this.checkPatternExport(exports,pat.expression)};pp$1.checkVariableExport=function(exports,decls){var this$1=this;if(!exports)return;for(var i=0;i<decls.length;i++)this$1.checkPatternExport(exports,decls[i].id)};pp$1.shouldParseExportStatement=function(){return this.type.keyword||this.isLet()||this.isAsyncFunction()};pp$1.parseExportSpecifiers=function(exports){var this$1=this;var nodes=[],first=true;this.expect(tt.braceL);while(!this.eat(tt.braceR)){if(!first){this$1.expect(tt.comma);if(this$1.afterTrailingComma(tt.braceR))break}else first=false;var node=this$1.startNode();node.local=this$1.parseIdent(this$1.type===tt._default);node.exported=this$1.eatContextual("as")?this$1.parseIdent(true):node.local;this$1.checkExport(exports,node.exported.name,node.exported.start);nodes.push(this$1.finishNode(node,"ExportSpecifier"))}return nodes};pp$1.parseImport=function(node){this.next();if(this.type===tt.string){node.specifiers=empty;node.source=this.parseExprAtom()}else{node.specifiers=this.parseImportSpecifiers();this.expectContextual("from");node.source=this.type===tt.string?this.parseExprAtom():this.unexpected()}this.semicolon();return this.finishNode(node,"ImportDeclaration")};pp$1.parseImportSpecifiers=function(){var this$1=this;var nodes=[],first=true;if(this.type===tt.name){var node=this.startNode();node.local=this.parseIdent();this.checkLVal(node.local,true);nodes.push(this.finishNode(node,"ImportDefaultSpecifier"));if(!this.eat(tt.comma))return nodes}if(this.type===tt.star){var node$1=this.startNode();this.next();this.expectContextual("as");node$1.local=this.parseIdent();this.checkLVal(node$1.local,true);nodes.push(this.finishNode(node$1,"ImportNamespaceSpecifier"));return nodes}this.expect(tt.braceL);while(!this.eat(tt.braceR)){if(!first){this$1.expect(tt.comma);if(this$1.afterTrailingComma(tt.braceR))break}else first=false;var node$2=this$1.startNode();node$2.imported=this$1.parseIdent(true);if(this$1.eatContextual("as")){node$2.local=this$1.parseIdent()}else{node$2.local=node$2.imported;if(this$1.isKeyword(node$2.local.name))this$1.unexpected(node$2.local.start);if(this$1.reservedWordsStrict.test(node$2.local.name))this$1.raiseRecoverable(node$2.local.start,"The keyword '"+node$2.local.name+"' is reserved")}this$1.checkLVal(node$2.local,true);nodes.push(this$1.finishNode(node$2,"ImportSpecifier"))}return nodes};var pp$2=Parser.prototype;pp$2.toAssignable=function(node,isBinding){var this$1=this;if(this.options.ecmaVersion>=6&&node){switch(node.type){case"Identifier":if(this.inAsync&&node.name==="await")this.raise(node.start,"Can not use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":break;case"ObjectExpression":node.type="ObjectPattern";for(var i=0;i<node.properties.length;i++){var prop=node.properties[i];if(prop.kind!=="init")this$1.raise(prop.key.start,"Object pattern can't contain getter or setter");this$1.toAssignable(prop.value,isBinding)}break;case"ArrayExpression":node.type="ArrayPattern";this.toAssignableList(node.elements,isBinding);break;case"AssignmentExpression":if(node.operator==="="){node.type="AssignmentPattern";delete node.operator;this.toAssignable(node.left,isBinding)}else{this.raise(node.left.end,"Only '=' operator can be used for specifying default value.");break}case"AssignmentPattern":break;case"ParenthesizedExpression":node.expression=this.toAssignable(node.expression,isBinding);break;case"MemberExpression":if(!isBinding)break;default:this.raise(node.start,"Assigning to rvalue")}}return node};pp$2.toAssignableList=function(exprList,isBinding){var this$1=this;var end=exprList.length;if(end){var last=exprList[end-1];if(last&&last.type=="RestElement"){--end}else if(last&&last.type=="SpreadElement"){last.type="RestElement";var arg=last.argument;this.toAssignable(arg,isBinding);if(arg.type!=="Identifier"&&arg.type!=="MemberExpression"&&arg.type!=="ArrayPattern")this.unexpected(arg.start);--end}if(isBinding&&last&&last.type==="RestElement"&&last.argument.type!=="Identifier")this.unexpected(last.argument.start)}for(var i=0;i<end;i++){var elt=exprList[i];if(elt)this$1.toAssignable(elt,isBinding)}return exprList};pp$2.parseSpread=function(refDestructuringErrors){var node=this.startNode();this.next();node.argument=this.parseMaybeAssign(false,refDestructuringErrors);return this.finishNode(node,"SpreadElement")};pp$2.parseRest=function(allowNonIdent){var node=this.startNode();this.next();if(allowNonIdent)node.argument=this.type===tt.name?this.parseIdent():this.unexpected();else node.argument=this.type===tt.name||this.type===tt.bracketL?this.parseBindingAtom():this.unexpected();return this.finishNode(node,"RestElement")};pp$2.parseBindingAtom=function(){if(this.options.ecmaVersion<6)return this.parseIdent();switch(this.type){case tt.name:return this.parseIdent();case tt.bracketL:var node=this.startNode();this.next();node.elements=this.parseBindingList(tt.bracketR,true,true);return this.finishNode(node,"ArrayPattern");case tt.braceL:return this.parseObj(true);default:this.unexpected()}};pp$2.parseBindingList=function(close,allowEmpty,allowTrailingComma,allowNonIdent){var this$1=this;var elts=[],first=true;while(!this.eat(close)){if(first)first=false;else this$1.expect(tt.comma);if(allowEmpty&&this$1.type===tt.comma){elts.push(null)}else if(allowTrailingComma&&this$1.afterTrailingComma(close)){break}else if(this$1.type===tt.ellipsis){var rest=this$1.parseRest(allowNonIdent);this$1.parseBindingListItem(rest);elts.push(rest);if(this$1.type===tt.comma)this$1.raise(this$1.start,"Comma is not permitted after the rest element");this$1.expect(close);break}else{var elem=this$1.parseMaybeDefault(this$1.start,this$1.startLoc);this$1.parseBindingListItem(elem);elts.push(elem)}}return elts};pp$2.parseBindingListItem=function(param){return param};pp$2.parseMaybeDefault=function(startPos,startLoc,left){left=left||this.parseBindingAtom();if(this.options.ecmaVersion<6||!this.eat(tt.eq))return left;var node=this.startNodeAt(startPos,startLoc);node.left=left;node.right=this.parseMaybeAssign();return this.finishNode(node,"AssignmentPattern")};pp$2.checkLVal=function(expr,isBinding,checkClashes){var this$1=this;switch(expr.type){case"Identifier":if(this.strict&&this.reservedWordsStrictBind.test(expr.name))this.raiseRecoverable(expr.start,(isBinding?"Binding ":"Assigning to ")+expr.name+" in strict mode");if(checkClashes){if(has(checkClashes,expr.name))this.raiseRecoverable(expr.start,"Argument name clash");checkClashes[expr.name]=true}break;case"MemberExpression":if(isBinding)this.raiseRecoverable(expr.start,(isBinding?"Binding":"Assigning to")+" member expression");break;case"ObjectPattern":for(var i=0;i<expr.properties.length;i++)this$1.checkLVal(expr.properties[i].value,isBinding,checkClashes);break;case"ArrayPattern":for(var i$1=0;i$1<expr.elements.length;i$1++){var elem=expr.elements[i$1];if(elem)this$1.checkLVal(elem,isBinding,checkClashes)}break;case"AssignmentPattern":this.checkLVal(expr.left,isBinding,checkClashes);break;case"RestElement":this.checkLVal(expr.argument,isBinding,checkClashes);break;case"ParenthesizedExpression":this.checkLVal(expr.expression,isBinding,checkClashes);break;default:this.raise(expr.start,(isBinding?"Binding":"Assigning to")+" rvalue")}};var pp$3=Parser.prototype;pp$3.checkPropClash=function(prop,propHash){if(this.options.ecmaVersion>=6&&(prop.computed||prop.method||prop.shorthand))return;var key=prop.key;var name;switch(key.type){case"Identifier":name=key.name;break;case"Literal":name=String(key.value);break;default:return}var kind=prop.kind;if(this.options.ecmaVersion>=6){if(name==="__proto__"&&kind==="init"){if(propHash.proto)this.raiseRecoverable(key.start,"Redefinition of __proto__ property");propHash.proto=true}return}name="$"+name;var other=propHash[name];if(other){var isGetSet=kind!=="init";if((this.strict||isGetSet)&&other[kind]||!(isGetSet^other.init))this.raiseRecoverable(key.start,"Redefinition of property")}else{other=propHash[name]={init:false,get:false,set:false}}other[kind]=true};pp$3.parseExpression=function(noIn,refDestructuringErrors){var this$1=this;var startPos=this.start,startLoc=this.startLoc;var expr=this.parseMaybeAssign(noIn,refDestructuringErrors);if(this.type===tt.comma){var node=this.startNodeAt(startPos,startLoc);node.expressions=[expr];while(this.eat(tt.comma))node.expressions.push(this$1.parseMaybeAssign(noIn,refDestructuringErrors));return this.finishNode(node,"SequenceExpression")}return expr};pp$3.parseMaybeAssign=function(noIn,refDestructuringErrors,afterLeftParse){if(this.inGenerator&&this.isContextual("yield"))return this.parseYield();var ownDestructuringErrors=false;if(!refDestructuringErrors){refDestructuringErrors=new DestructuringErrors;ownDestructuringErrors=true}var startPos=this.start,startLoc=this.startLoc;if(this.type==tt.parenL||this.type==tt.name)this.potentialArrowAt=this.start;var left=this.parseMaybeConditional(noIn,refDestructuringErrors);if(afterLeftParse)left=afterLeftParse.call(this,left,startPos,startLoc);if(this.type.isAssign){this.checkPatternErrors(refDestructuringErrors,true);if(!ownDestructuringErrors)DestructuringErrors.call(refDestructuringErrors);var node=this.startNodeAt(startPos,startLoc);node.operator=this.value;node.left=this.type===tt.eq?this.toAssignable(left):left;refDestructuringErrors.shorthandAssign=0;this.checkLVal(left);this.next();node.right=this.parseMaybeAssign(noIn);return this.finishNode(node,"AssignmentExpression")}else{if(ownDestructuringErrors)this.checkExpressionErrors(refDestructuringErrors,true)}return left};pp$3.parseMaybeConditional=function(noIn,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc;var expr=this.parseExprOps(noIn,refDestructuringErrors);if(this.checkExpressionErrors(refDestructuringErrors))return expr;if(this.eat(tt.question)){var node=this.startNodeAt(startPos,startLoc);node.test=expr;node.consequent=this.parseMaybeAssign();this.expect(tt.colon);node.alternate=this.parseMaybeAssign(noIn);return this.finishNode(node,"ConditionalExpression")}return expr};pp$3.parseExprOps=function(noIn,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc;var expr=this.parseMaybeUnary(refDestructuringErrors,false);if(this.checkExpressionErrors(refDestructuringErrors))return expr;return this.parseExprOp(expr,startPos,startLoc,-1,noIn)};pp$3.parseExprOp=function(left,leftStartPos,leftStartLoc,minPrec,noIn){var prec=this.type.binop;if(prec!=null&&(!noIn||this.type!==tt._in)){if(prec>minPrec){var logical=this.type===tt.logicalOR||this.type===tt.logicalAND;var op=this.value;this.next();var startPos=this.start,startLoc=this.startLoc;var right=this.parseExprOp(this.parseMaybeUnary(null,false),startPos,startLoc,prec,noIn);var node=this.buildBinary(leftStartPos,leftStartLoc,left,right,op,logical);return this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec,noIn)}}return left};pp$3.buildBinary=function(startPos,startLoc,left,right,op,logical){var node=this.startNodeAt(startPos,startLoc);node.left=left;node.operator=op;node.right=right;return this.finishNode(node,logical?"LogicalExpression":"BinaryExpression")};pp$3.parseMaybeUnary=function(refDestructuringErrors,sawUnary){var this$1=this;var startPos=this.start,startLoc=this.startLoc,expr;if(this.inAsync&&this.isContextual("await")){expr=this.parseAwait(refDestructuringErrors);sawUnary=true}else if(this.type.prefix){var node=this.startNode(),update=this.type===tt.incDec;node.operator=this.value;node.prefix=true;this.next();node.argument=this.parseMaybeUnary(null,true);this.checkExpressionErrors(refDestructuringErrors,true);if(update)this.checkLVal(node.argument);else if(this.strict&&node.operator==="delete"&&node.argument.type==="Identifier")this.raiseRecoverable(node.start,"Deleting local variable in strict mode");else sawUnary=true;expr=this.finishNode(node,update?"UpdateExpression":"UnaryExpression")}else{expr=this.parseExprSubscripts(refDestructuringErrors);if(this.checkExpressionErrors(refDestructuringErrors))return expr;while(this.type.postfix&&!this.canInsertSemicolon()){var node$1=this$1.startNodeAt(startPos,startLoc);node$1.operator=this$1.value;node$1.prefix=false;node$1.argument=expr;this$1.checkLVal(expr);this$1.next();expr=this$1.finishNode(node$1,"UpdateExpression")}}if(!sawUnary&&this.eat(tt.starstar))return this.buildBinary(startPos,startLoc,expr,this.parseMaybeUnary(null,false),"**",false);else return expr};pp$3.parseExprSubscripts=function(refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc;var expr=this.parseExprAtom(refDestructuringErrors);var skipArrowSubscripts=expr.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")";if(this.checkExpressionErrors(refDestructuringErrors)||skipArrowSubscripts)return expr;return this.parseSubscripts(expr,startPos,startLoc)};pp$3.parseSubscripts=function(base,startPos,startLoc,noCalls){var this$1=this;for(;;){var maybeAsyncArrow=this$1.options.ecmaVersion>=8&&base.type==="Identifier"&&base.name==="async"&&!this$1.canInsertSemicolon();if(this$1.eat(tt.dot)){var node=this$1.startNodeAt(startPos,startLoc);node.object=base;node.property=this$1.parseIdent(true);node.computed=false;base=this$1.finishNode(node,"MemberExpression")}else if(this$1.eat(tt.bracketL)){var node$1=this$1.startNodeAt(startPos,startLoc);node$1.object=base;node$1.property=this$1.parseExpression();node$1.computed=true;this$1.expect(tt.bracketR);base=this$1.finishNode(node$1,"MemberExpression")}else if(!noCalls&&this$1.eat(tt.parenL)){var refDestructuringErrors=new DestructuringErrors,oldYieldPos=this$1.yieldPos,oldAwaitPos=this$1.awaitPos;this$1.yieldPos=0;this$1.awaitPos=0;var exprList=this$1.parseExprList(tt.parenR,this$1.options.ecmaVersion>=8,false,refDestructuringErrors);if(maybeAsyncArrow&&!this$1.canInsertSemicolon()&&this$1.eat(tt.arrow)){this$1.checkPatternErrors(refDestructuringErrors,true);this$1.checkYieldAwaitInDefaultParams();this$1.yieldPos=oldYieldPos;this$1.awaitPos=oldAwaitPos;return this$1.parseArrowExpression(this$1.startNodeAt(startPos,startLoc),exprList,true)}this$1.checkExpressionErrors(refDestructuringErrors,true);this$1.yieldPos=oldYieldPos||this$1.yieldPos;this$1.awaitPos=oldAwaitPos||this$1.awaitPos;var node$2=this$1.startNodeAt(startPos,startLoc);node$2.callee=base;node$2.arguments=exprList;base=this$1.finishNode(node$2,"CallExpression")}else if(this$1.type===tt.backQuote){var node$3=this$1.startNodeAt(startPos,startLoc);node$3.tag=base;node$3.quasi=this$1.parseTemplate();base=this$1.finishNode(node$3,"TaggedTemplateExpression")}else{return base}}};pp$3.parseExprAtom=function(refDestructuringErrors){var node,canBeArrow=this.potentialArrowAt==this.start;switch(this.type){case tt._super:if(!this.inFunction)this.raise(this.start,"'super' outside of function or class");case tt._this:var type=this.type===tt._this?"ThisExpression":"Super";node=this.startNode();this.next();return this.finishNode(node,type);case tt.name:var startPos=this.start,startLoc=this.startLoc;var id=this.parseIdent(this.type!==tt.name);if(this.options.ecmaVersion>=8&&id.name==="async"&&!this.canInsertSemicolon()&&this.eat(tt._function))return this.parseFunction(this.startNodeAt(startPos,startLoc),false,false,true);if(canBeArrow&&!this.canInsertSemicolon()){if(this.eat(tt.arrow))return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],false);if(this.options.ecmaVersion>=8&&id.name==="async"&&this.type===tt.name){id=this.parseIdent();if(this.canInsertSemicolon()||!this.eat(tt.arrow))this.unexpected();return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],true)}}return id;case tt.regexp:var value=this.value;node=this.parseLiteral(value.value);node.regex={pattern:value.pattern,flags:value.flags};return node;case tt.num:case tt.string:return this.parseLiteral(this.value);case tt._null:case tt._true:case tt._false:node=this.startNode();node.value=this.type===tt._null?null:this.type===tt._true;node.raw=this.type.keyword;this.next();return this.finishNode(node,"Literal");case tt.parenL:return this.parseParenAndDistinguishExpression(canBeArrow);case tt.bracketL:node=this.startNode();this.next();node.elements=this.parseExprList(tt.bracketR,true,true,refDestructuringErrors);return this.finishNode(node,"ArrayExpression");case tt.braceL:return this.parseObj(false,refDestructuringErrors);case tt._function:node=this.startNode();this.next();return this.parseFunction(node,false);case tt._class:return this.parseClass(this.startNode(),false);case tt._new:return this.parseNew();case tt.backQuote:return this.parseTemplate();default:this.unexpected()}};pp$3.parseLiteral=function(value){var node=this.startNode();node.value=value;node.raw=this.input.slice(this.start,this.end);this.next();return this.finishNode(node,"Literal")};pp$3.parseParenExpression=function(){this.expect(tt.parenL);var val=this.parseExpression();this.expect(tt.parenR);return val};pp$3.parseParenAndDistinguishExpression=function(canBeArrow){var this$1=this;var startPos=this.start,startLoc=this.startLoc,val,allowTrailingComma=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var innerStartPos=this.start,innerStartLoc=this.startLoc;var exprList=[],first=true,lastIsComma=false;var refDestructuringErrors=new DestructuringErrors,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,spreadStart,innerParenStart;this.yieldPos=0;this.awaitPos=0;while(this.type!==tt.parenR){first?first=false:this$1.expect(tt.comma);if(allowTrailingComma&&this$1.afterTrailingComma(tt.parenR,true)){lastIsComma=true;break}else if(this$1.type===tt.ellipsis){spreadStart=this$1.start;exprList.push(this$1.parseParenItem(this$1.parseRest()));if(this$1.type===tt.comma)this$1.raise(this$1.start,"Comma is not permitted after the rest element");break}else{if(this$1.type===tt.parenL&&!innerParenStart){innerParenStart=this$1.start}exprList.push(this$1.parseMaybeAssign(false,refDestructuringErrors,this$1.parseParenItem))}}var innerEndPos=this.start,innerEndLoc=this.startLoc;this.expect(tt.parenR);if(canBeArrow&&!this.canInsertSemicolon()&&this.eat(tt.arrow)){this.checkPatternErrors(refDestructuringErrors,true);this.checkYieldAwaitInDefaultParams();if(innerParenStart)this.unexpected(innerParenStart);this.yieldPos=oldYieldPos;this.awaitPos=oldAwaitPos;return this.parseParenArrowList(startPos,startLoc,exprList)}if(!exprList.length||lastIsComma)this.unexpected(this.lastTokStart);if(spreadStart)this.unexpected(spreadStart);this.checkExpressionErrors(refDestructuringErrors,true);this.yieldPos=oldYieldPos||this.yieldPos;this.awaitPos=oldAwaitPos||this.awaitPos;if(exprList.length>1){val=this.startNodeAt(innerStartPos,innerStartLoc);val.expressions=exprList;this.finishNodeAt(val,"SequenceExpression",innerEndPos,innerEndLoc)}else{val=exprList[0]}}else{val=this.parseParenExpression()}if(this.options.preserveParens){var par=this.startNodeAt(startPos,startLoc);par.expression=val;return this.finishNode(par,"ParenthesizedExpression")}else{return val}};pp$3.parseParenItem=function(item){return item};pp$3.parseParenArrowList=function(startPos,startLoc,exprList){return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList)};var empty$1=[];pp$3.parseNew=function(){var node=this.startNode();var meta=this.parseIdent(true);if(this.options.ecmaVersion>=6&&this.eat(tt.dot)){node.meta=meta;node.property=this.parseIdent(true);if(node.property.name!=="target")this.raiseRecoverable(node.property.start,"The only valid meta property for new is new.target");if(!this.inFunction)this.raiseRecoverable(node.start,"new.target can only be used in functions");return this.finishNode(node,"MetaProperty")}var startPos=this.start,startLoc=this.startLoc;node.callee=this.parseSubscripts(this.parseExprAtom(),startPos,startLoc,true);if(this.eat(tt.parenL))node.arguments=this.parseExprList(tt.parenR,this.options.ecmaVersion>=8,false);else node.arguments=empty$1;return this.finishNode(node,"NewExpression")};pp$3.parseTemplateElement=function(){var elem=this.startNode();elem.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value};this.next();elem.tail=this.type===tt.backQuote;return this.finishNode(elem,"TemplateElement")};pp$3.parseTemplate=function(){var this$1=this;var node=this.startNode();this.next();node.expressions=[];var curElt=this.parseTemplateElement();node.quasis=[curElt];while(!curElt.tail){this$1.expect(tt.dollarBraceL);node.expressions.push(this$1.parseExpression());this$1.expect(tt.braceR);node.quasis.push(curElt=this$1.parseTemplateElement())}this.next();return this.finishNode(node,"TemplateLiteral")};pp$3.parseObj=function(isPattern,refDestructuringErrors){var this$1=this;var node=this.startNode(),first=true,propHash={};node.properties=[];this.next();while(!this.eat(tt.braceR)){if(!first){this$1.expect(tt.comma);if(this$1.afterTrailingComma(tt.braceR))break}else first=false;var prop=this$1.startNode(),isGenerator,isAsync,startPos,startLoc;if(this$1.options.ecmaVersion>=6){prop.method=false;prop.shorthand=false;if(isPattern||refDestructuringErrors){startPos=this$1.start;startLoc=this$1.startLoc}if(!isPattern)isGenerator=this$1.eat(tt.star)}this$1.parsePropertyName(prop);if(!isPattern&&this$1.options.ecmaVersion>=8&&!isGenerator&&!prop.computed&&prop.key.type==="Identifier"&&prop.key.name==="async"&&this$1.type!==tt.parenL&&this$1.type!==tt.colon&&!this$1.canInsertSemicolon()){isAsync=true;this$1.parsePropertyName(prop,refDestructuringErrors)}else{isAsync=false}this$1.parsePropertyValue(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors);this$1.checkPropClash(prop,propHash);node.properties.push(this$1.finishNode(prop,"Property"))}return this.finishNode(node,isPattern?"ObjectPattern":"ObjectExpression")};pp$3.parsePropertyValue=function(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors){if((isGenerator||isAsync)&&this.type===tt.colon)this.unexpected();if(this.eat(tt.colon)){prop.value=isPattern?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(false,refDestructuringErrors);prop.kind="init"}else if(this.options.ecmaVersion>=6&&this.type===tt.parenL){if(isPattern)this.unexpected();prop.kind="init";prop.method=true;prop.value=this.parseMethod(isGenerator,isAsync)}else if(this.options.ecmaVersion>=5&&!prop.computed&&prop.key.type==="Identifier"&&(prop.key.name==="get"||prop.key.name==="set")&&(this.type!=tt.comma&&this.type!=tt.braceR)){if(isGenerator||isAsync||isPattern)this.unexpected();prop.kind=prop.key.name;this.parsePropertyName(prop);prop.value=this.parseMethod(false);var paramCount=prop.kind==="get"?0:1;if(prop.value.params.length!==paramCount){var start=prop.value.start;if(prop.kind==="get")this.raiseRecoverable(start,"getter should have no params");else this.raiseRecoverable(start,"setter should have exactly one param")}else{if(prop.kind==="set"&&prop.value.params[0].type==="RestElement")this.raiseRecoverable(prop.value.params[0].start,"Setter cannot use rest params")}}else if(this.options.ecmaVersion>=6&&!prop.computed&&prop.key.type==="Identifier"){if(this.keywords.test(prop.key.name)||(this.strict?this.reservedWordsStrict:this.reservedWords).test(prop.key.name)||this.inGenerator&&prop.key.name=="yield"||this.inAsync&&prop.key.name=="await")this.raiseRecoverable(prop.key.start,"'"+prop.key.name+"' can not be used as shorthand property");prop.kind="init";if(isPattern){prop.value=this.parseMaybeDefault(startPos,startLoc,prop.key)}else if(this.type===tt.eq&&refDestructuringErrors){if(!refDestructuringErrors.shorthandAssign)refDestructuringErrors.shorthandAssign=this.start;prop.value=this.parseMaybeDefault(startPos,startLoc,prop.key)}else{prop.value=prop.key}prop.shorthand=true}else this.unexpected()};pp$3.parsePropertyName=function(prop){if(this.options.ecmaVersion>=6){if(this.eat(tt.bracketL)){prop.computed=true;prop.key=this.parseMaybeAssign();this.expect(tt.bracketR);return prop.key}else{prop.computed=false}}return prop.key=this.type===tt.num||this.type===tt.string?this.parseExprAtom():this.parseIdent(true)};pp$3.initFunction=function(node){node.id=null;if(this.options.ecmaVersion>=6){node.generator=false;node.expression=false}if(this.options.ecmaVersion>=8)node.async=false};pp$3.parseMethod=function(isGenerator,isAsync){var node=this.startNode(),oldInGen=this.inGenerator,oldInAsync=this.inAsync,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos;this.initFunction(node);if(this.options.ecmaVersion>=6)node.generator=isGenerator;if(this.options.ecmaVersion>=8)node.async=!!isAsync;this.inGenerator=node.generator;this.inAsync=node.async;this.yieldPos=0;this.awaitPos=0;this.expect(tt.parenL);node.params=this.parseBindingList(tt.parenR,false,this.options.ecmaVersion>=8);this.checkYieldAwaitInDefaultParams();this.parseFunctionBody(node,false);this.inGenerator=oldInGen;this.inAsync=oldInAsync;this.yieldPos=oldYieldPos;this.awaitPos=oldAwaitPos;return this.finishNode(node,"FunctionExpression")};pp$3.parseArrowExpression=function(node,params,isAsync){var oldInGen=this.inGenerator,oldInAsync=this.inAsync,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos;this.initFunction(node);if(this.options.ecmaVersion>=8)node.async=!!isAsync;this.inGenerator=false;this.inAsync=node.async;this.yieldPos=0;this.awaitPos=0;node.params=this.toAssignableList(params,true);this.parseFunctionBody(node,true);this.inGenerator=oldInGen;this.inAsync=oldInAsync;this.yieldPos=oldYieldPos;this.awaitPos=oldAwaitPos;return this.finishNode(node,"ArrowFunctionExpression")};pp$3.parseFunctionBody=function(node,isArrowFunction){var isExpression=isArrowFunction&&this.type!==tt.braceL;if(isExpression){node.body=this.parseMaybeAssign();node.expression=true}else{var oldInFunc=this.inFunction,oldLabels=this.labels;this.inFunction=true;this.labels=[];node.body=this.parseBlock(true);node.expression=false;this.inFunction=oldInFunc;this.labels=oldLabels}var useStrict=!isExpression&&node.body.body.length&&this.isUseStrict(node.body.body[0])?node.body.body[0]:null;if(useStrict&&this.options.ecmaVersion>=7&&!this.isSimpleParamList(node.params))this.raiseRecoverable(useStrict.start,"Illegal 'use strict' directive in function with non-simple parameter list");if(this.strict||useStrict){var oldStrict=this.strict;this.strict=true;if(node.id)this.checkLVal(node.id,true);this.checkParams(node);this.strict=oldStrict}else if(isArrowFunction||!this.isSimpleParamList(node.params)){this.checkParams(node)}};pp$3.isSimpleParamList=function(params){for(var i=0;i<params.length;i++)if(params[i].type!=="Identifier")return false;return true};pp$3.checkParams=function(node){var this$1=this;var nameHash={};for(var i=0;i<node.params.length;i++)this$1.checkLVal(node.params[i],true,nameHash)};pp$3.parseExprList=function(close,allowTrailingComma,allowEmpty,refDestructuringErrors){var this$1=this;var elts=[],first=true;while(!this.eat(close)){if(!first){this$1.expect(tt.comma);if(allowTrailingComma&&this$1.afterTrailingComma(close))break}else first=false;var elt;if(allowEmpty&&this$1.type===tt.comma)elt=null;else if(this$1.type===tt.ellipsis){elt=this$1.parseSpread(refDestructuringErrors);if(this$1.type===tt.comma&&refDestructuringErrors&&!refDestructuringErrors.trailingComma){refDestructuringErrors.trailingComma=this$1.start}}else elt=this$1.parseMaybeAssign(false,refDestructuringErrors);elts.push(elt)}return elts};pp$3.parseIdent=function(liberal){var node=this.startNode();if(liberal&&this.options.allowReserved=="never")liberal=false;if(this.type===tt.name){if(!liberal&&(this.strict?this.reservedWordsStrict:this.reservedWords).test(this.value)&&(this.options.ecmaVersion>=6||this.input.slice(this.start,this.end).indexOf("\\")==-1))this.raiseRecoverable(this.start,"The keyword '"+this.value+"' is reserved");if(this.inGenerator&&this.value==="yield")this.raiseRecoverable(this.start,"Can not use 'yield' as identifier inside a generator");if(this.inAsync&&this.value==="await")this.raiseRecoverable(this.start,"Can not use 'await' as identifier inside an async function");node.name=this.value}else if(liberal&&this.type.keyword){node.name=this.type.keyword}else{this.unexpected()}this.next();return this.finishNode(node,"Identifier")};pp$3.parseYield=function(){if(!this.yieldPos)this.yieldPos=this.start;var node=this.startNode();this.next();if(this.type==tt.semi||this.canInsertSemicolon()||this.type!=tt.star&&!this.type.startsExpr){node.delegate=false;node.argument=null}else{node.delegate=this.eat(tt.star);node.argument=this.parseMaybeAssign()}return this.finishNode(node,"YieldExpression")};pp$3.parseAwait=function(){if(!this.awaitPos)this.awaitPos=this.start;var node=this.startNode();this.next();node.argument=this.parseMaybeUnary(null,true);return this.finishNode(node,"AwaitExpression")};var pp$4=Parser.prototype;pp$4.raise=function(pos,message){var loc=getLineInfo(this.input,pos);message+=" ("+loc.line+":"+loc.column+")";var err=new SyntaxError(message);err.pos=pos;err.loc=loc;err.raisedAt=this.pos;throw err};pp$4.raiseRecoverable=pp$4.raise;pp$4.curPosition=function(){if(this.options.locations){return new Position(this.curLine,this.pos-this.lineStart)}};var Node=function Node(parser,pos,loc){this.type="";this.start=pos;this.end=0;if(parser.options.locations)this.loc=new SourceLocation(parser,loc);if(parser.options.directSourceFile)this.sourceFile=parser.options.directSourceFile;if(parser.options.ranges)this.range=[pos,0]};var pp$5=Parser.prototype;pp$5.startNode=function(){return new Node(this,this.start,this.startLoc)};pp$5.startNodeAt=function(pos,loc){return new Node(this,pos,loc)};function finishNodeAt(node,type,pos,loc){node.type=type;node.end=pos;if(this.options.locations)node.loc.end=loc;if(this.options.ranges)node.range[1]=pos;return node}pp$5.finishNode=function(node,type){return finishNodeAt.call(this,node,type,this.lastTokEnd,this.lastTokEndLoc)};pp$5.finishNodeAt=function(node,type,pos,loc){return finishNodeAt.call(this,node,type,pos,loc)};var TokContext=function TokContext(token,isExpr,preserveSpace,override){this.token=token;this.isExpr=!!isExpr;this.preserveSpace=!!preserveSpace;this.override=override};var types={b_stat:new TokContext("{",false),b_expr:new TokContext("{",true),b_tmpl:new TokContext("${",true),p_stat:new TokContext("(",false),p_expr:new TokContext("(",true),q_tmpl:new TokContext("`",true,true,function(p){return p.readTmplToken()}),f_expr:new TokContext("function",true)};var pp$6=Parser.prototype;pp$6.initialContext=function(){return[types.b_stat]};pp$6.braceIsBlock=function(prevType){if(prevType===tt.colon){var parent=this.curContext();if(parent===types.b_stat||parent===types.b_expr)return!parent.isExpr}if(prevType===tt._return)return lineBreak.test(this.input.slice(this.lastTokEnd,this.start));if(prevType===tt._else||prevType===tt.semi||prevType===tt.eof||prevType===tt.parenR)return true;if(prevType==tt.braceL)return this.curContext()===types.b_stat;return!this.exprAllowed};pp$6.updateContext=function(prevType){var update,type=this.type;if(type.keyword&&prevType==tt.dot)this.exprAllowed=false;else if(update=type.updateContext)update.call(this,prevType);else this.exprAllowed=type.beforeExpr};tt.parenR.updateContext=tt.braceR.updateContext=function(){if(this.context.length==1){this.exprAllowed=true;return}var out=this.context.pop();if(out===types.b_stat&&this.curContext()===types.f_expr){this.context.pop();this.exprAllowed=false}else if(out===types.b_tmpl){this.exprAllowed=true}else{this.exprAllowed=!out.isExpr}};tt.braceL.updateContext=function(prevType){this.context.push(this.braceIsBlock(prevType)?types.b_stat:types.b_expr);this.exprAllowed=true};tt.dollarBraceL.updateContext=function(){this.context.push(types.b_tmpl);this.exprAllowed=true};tt.parenL.updateContext=function(prevType){var statementParens=prevType===tt._if||prevType===tt._for||prevType===tt._with||prevType===tt._while;this.context.push(statementParens?types.p_stat:types.p_expr);this.exprAllowed=true};tt.incDec.updateContext=function(){};tt._function.updateContext=function(prevType){if(prevType.beforeExpr&&prevType!==tt.semi&&prevType!==tt._else&&!((prevType===tt.colon||prevType===tt.braceL)&&this.curContext()===types.b_stat))this.context.push(types.f_expr);this.exprAllowed=false};tt.backQuote.updateContext=function(){if(this.curContext()===types.q_tmpl)this.context.pop();else this.context.push(types.q_tmpl);this.exprAllowed=false};var Token=function Token(p){this.type=p.type;this.value=p.value;this.start=p.start;this.end=p.end;if(p.options.locations)this.loc=new SourceLocation(p,p.startLoc,p.endLoc);if(p.options.ranges)this.range=[p.start,p.end]};var pp$7=Parser.prototype;var isRhino=typeof Packages=="object"&&Object.prototype.toString.call(Packages)=="[object JavaPackage]";pp$7.next=function(){if(this.options.onToken)this.options.onToken(new Token(this));this.lastTokEnd=this.end;this.lastTokStart=this.start;this.lastTokEndLoc=this.endLoc;this.lastTokStartLoc=this.startLoc;this.nextToken()};pp$7.getToken=function(){this.next();return new Token(this)};if(typeof Symbol!=="undefined")pp$7[Symbol.iterator]=function(){var self=this;return{next:function(){var token=self.getToken();return{done:token.type===tt.eof,value:token}}}};pp$7.setStrict=function(strict){var this$1=this;this.strict=strict;if(this.type!==tt.num&&this.type!==tt.string)return;this.pos=this.start;if(this.options.locations){while(this.pos<this.lineStart){this$1.lineStart=this$1.input.lastIndexOf("\n",this$1.lineStart-2)+1;--this$1.curLine}}this.nextToken()};pp$7.curContext=function(){return this.context[this.context.length-1]};pp$7.nextToken=function(){var curContext=this.curContext();if(!curContext||!curContext.preserveSpace)this.skipSpace();this.start=this.pos;if(this.options.locations)this.startLoc=this.curPosition();if(this.pos>=this.input.length)return this.finishToken(tt.eof);if(curContext.override)return curContext.override(this);else this.readToken(this.fullCharCodeAtPos())};pp$7.readToken=function(code){if(isIdentifierStart(code,this.options.ecmaVersion>=6)||code===92)return this.readWord();return this.getTokenFromCode(code)};pp$7.fullCharCodeAtPos=function(){var code=this.input.charCodeAt(this.pos);if(code<=55295||code>=57344)return code;var next=this.input.charCodeAt(this.pos+1);return(code<<10)+next-56613888};pp$7.skipBlockComment=function(){var this$1=this;var startLoc=this.options.onComment&&this.curPosition();var start=this.pos,end=this.input.indexOf("*/",this.pos+=2);if(end===-1)this.raise(this.pos-2,"Unterminated comment");this.pos=end+2;if(this.options.locations){lineBreakG.lastIndex=start;var match;while((match=lineBreakG.exec(this.input))&&match.index<this.pos){++this$1.curLine;this$1.lineStart=match.index+match[0].length}}if(this.options.onComment)this.options.onComment(true,this.input.slice(start+2,end),start,this.pos,startLoc,this.curPosition())};pp$7.skipLineComment=function(startSkip){var this$1=this;var start=this.pos;var startLoc=this.options.onComment&&this.curPosition();var ch=this.input.charCodeAt(this.pos+=startSkip);while(this.pos<this.input.length&&ch!==10&&ch!==13&&ch!==8232&&ch!==8233){++this$1.pos;ch=this$1.input.charCodeAt(this$1.pos)}if(this.options.onComment)this.options.onComment(false,this.input.slice(start+startSkip,this.pos),start,this.pos,startLoc,this.curPosition())};pp$7.skipSpace=function(){var this$1=this;loop:while(this.pos<this.input.length){var ch=this$1.input.charCodeAt(this$1.pos);switch(ch){case 32:case 160:++this$1.pos;break;case 13:if(this$1.input.charCodeAt(this$1.pos+1)===10){++this$1.pos}case 10:case 8232:case 8233:++this$1.pos;if(this$1.options.locations){++this$1.curLine;this$1.lineStart=this$1.pos}break;case 47:switch(this$1.input.charCodeAt(this$1.pos+1)){case 42:this$1.skipBlockComment();break;case 47:this$1.skipLineComment(2);break;default:break loop}break;default:if(ch>8&&ch<14||ch>=5760&&nonASCIIwhitespace.test(String.fromCharCode(ch))){++this$1.pos}else{break loop}}}};pp$7.finishToken=function(type,val){this.end=this.pos;if(this.options.locations)this.endLoc=this.curPosition();var prevType=this.type;this.type=type;this.value=val;this.updateContext(prevType)};pp$7.readToken_dot=function(){var next=this.input.charCodeAt(this.pos+1);if(next>=48&&next<=57)return this.readNumber(true);var next2=this.input.charCodeAt(this.pos+2);if(this.options.ecmaVersion>=6&&next===46&&next2===46){this.pos+=3;return this.finishToken(tt.ellipsis)}else{++this.pos;return this.finishToken(tt.dot)}};pp$7.readToken_slash=function(){var next=this.input.charCodeAt(this.pos+1);if(this.exprAllowed){++this.pos;return this.readRegexp()}if(next===61)return this.finishOp(tt.assign,2);return this.finishOp(tt.slash,1)};pp$7.readToken_mult_modulo_exp=function(code){var next=this.input.charCodeAt(this.pos+1);var size=1;var tokentype=code===42?tt.star:tt.modulo;if(this.options.ecmaVersion>=7&&next===42){++size;tokentype=tt.starstar;next=this.input.charCodeAt(this.pos+2)}if(next===61)return this.finishOp(tt.assign,size+1);return this.finishOp(tokentype,size)};pp$7.readToken_pipe_amp=function(code){var next=this.input.charCodeAt(this.pos+1);if(next===code)return this.finishOp(code===124?tt.logicalOR:tt.logicalAND,2);if(next===61)return this.finishOp(tt.assign,2);return this.finishOp(code===124?tt.bitwiseOR:tt.bitwiseAND,1)};pp$7.readToken_caret=function(){var next=this.input.charCodeAt(this.pos+1);if(next===61)return this.finishOp(tt.assign,2);return this.finishOp(tt.bitwiseXOR,1)};pp$7.readToken_plus_min=function(code){var next=this.input.charCodeAt(this.pos+1);if(next===code){if(next==45&&this.input.charCodeAt(this.pos+2)==62&&lineBreak.test(this.input.slice(this.lastTokEnd,this.pos))){this.skipLineComment(3);this.skipSpace();return this.nextToken()}return this.finishOp(tt.incDec,2)}if(next===61)return this.finishOp(tt.assign,2);return this.finishOp(tt.plusMin,1)};pp$7.readToken_lt_gt=function(code){var next=this.input.charCodeAt(this.pos+1);var size=1;if(next===code){size=code===62&&this.input.charCodeAt(this.pos+2)===62?3:2;if(this.input.charCodeAt(this.pos+size)===61)return this.finishOp(tt.assign,size+1);return this.finishOp(tt.bitShift,size)}if(next==33&&code==60&&this.input.charCodeAt(this.pos+2)==45&&this.input.charCodeAt(this.pos+3)==45){if(this.inModule)this.unexpected();this.skipLineComment(4);this.skipSpace();return this.nextToken()}if(next===61)size=2;return this.finishOp(tt.relational,size)};pp$7.readToken_eq_excl=function(code){var next=this.input.charCodeAt(this.pos+1);if(next===61)return this.finishOp(tt.equality,this.input.charCodeAt(this.pos+2)===61?3:2);if(code===61&&next===62&&this.options.ecmaVersion>=6){this.pos+=2;return this.finishToken(tt.arrow)}return this.finishOp(code===61?tt.eq:tt.prefix,1)};pp$7.getTokenFromCode=function(code){switch(code){case 46:return this.readToken_dot();case 40:++this.pos;return this.finishToken(tt.parenL);case 41:++this.pos;return this.finishToken(tt.parenR);case 59:++this.pos;return this.finishToken(tt.semi);case 44:++this.pos;return this.finishToken(tt.comma);case 91:++this.pos;return this.finishToken(tt.bracketL);case 93:++this.pos;return this.finishToken(tt.bracketR);case 123:++this.pos;return this.finishToken(tt.braceL);case 125:++this.pos;return this.finishToken(tt.braceR);case 58:++this.pos;return this.finishToken(tt.colon);case 63:++this.pos;return this.finishToken(tt.question);case 96:if(this.options.ecmaVersion<6)break;++this.pos;return this.finishToken(tt.backQuote);case 48:var next=this.input.charCodeAt(this.pos+1);if(next===120||next===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(next===111||next===79)return this.readRadixNumber(8);if(next===98||next===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(false);case 34:case 39:return this.readString(code);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(code);case 124:case 38:return this.readToken_pipe_amp(code);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(code);case 60:case 62:return this.readToken_lt_gt(code);case 61:case 33:return this.readToken_eq_excl(code);case 126:return this.finishOp(tt.prefix,1)}this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'")};pp$7.finishOp=function(type,size){var str=this.input.slice(this.pos,this.pos+size);this.pos+=size;return this.finishToken(type,str)};function tryCreateRegexp(src,flags,throwErrorAt,parser){try{return new RegExp(src,flags)}catch(e){if(throwErrorAt!==undefined){if(e instanceof SyntaxError)parser.raise(throwErrorAt,"Error parsing regular expression: "+e.message);throw e}}}var regexpUnicodeSupport=!!tryCreateRegexp("￿","u");pp$7.readRegexp=function(){var this$1=this;var escaped,inClass,start=this.pos;for(;;){if(this$1.pos>=this$1.input.length)this$1.raise(start,"Unterminated regular expression");var ch=this$1.input.charAt(this$1.pos);if(lineBreak.test(ch))this$1.raise(start,"Unterminated regular expression");if(!escaped){if(ch==="[")inClass=true;else if(ch==="]"&&inClass)inClass=false;else if(ch==="/"&&!inClass)break;escaped=ch==="\\"}else escaped=false;++this$1.pos}var content=this.input.slice(start,this.pos);++this.pos;var mods=this.readWord1();var tmp=content,tmpFlags="";if(mods){var validFlags=/^[gim]*$/;if(this.options.ecmaVersion>=6)validFlags=/^[gimuy]*$/;if(!validFlags.test(mods))this.raise(start,"Invalid regular expression flag");if(mods.indexOf("u")>=0){if(regexpUnicodeSupport){tmpFlags="u"}else{tmp=tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g,function(_match,code,offset){code=Number("0x"+code);if(code>1114111)this$1.raise(start+offset+3,"Code point out of bounds");return"x"});tmp=tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"x");tmpFlags=tmpFlags.replace("u","")}}}var value=null;if(!isRhino){tryCreateRegexp(tmp,tmpFlags,start,this);value=tryCreateRegexp(content,mods)}return this.finishToken(tt.regexp,{pattern:content,flags:mods,value:value})};pp$7.readInt=function(radix,len){var this$1=this;var start=this.pos,total=0;for(var i=0,e=len==null?Infinity:len;i<e;++i){var code=this$1.input.charCodeAt(this$1.pos),val;if(code>=97)val=code-97+10;else if(code>=65)val=code-65+10;else if(code>=48&&code<=57)val=code-48;else val=Infinity;if(val>=radix)break;++this$1.pos;total=total*radix+val}if(this.pos===start||len!=null&&this.pos-start!==len)return null;return total};pp$7.readRadixNumber=function(radix){this.pos+=2;var val=this.readInt(radix);if(val==null)this.raise(this.start+2,"Expected number in radix "+radix);if(isIdentifierStart(this.fullCharCodeAtPos()))this.raise(this.pos,"Identifier directly after number");return this.finishToken(tt.num,val)};pp$7.readNumber=function(startsWithDot){var start=this.pos,isFloat=false,octal=this.input.charCodeAt(this.pos)===48;if(!startsWithDot&&this.readInt(10)===null)this.raise(start,"Invalid number");if(octal&&this.pos==start+1)octal=false;var next=this.input.charCodeAt(this.pos);if(next===46&&!octal){++this.pos;this.readInt(10);isFloat=true;next=this.input.charCodeAt(this.pos)}if((next===69||next===101)&&!octal){next=this.input.charCodeAt(++this.pos);if(next===43||next===45)++this.pos;if(this.readInt(10)===null)this.raise(start,"Invalid number");isFloat=true}if(isIdentifierStart(this.fullCharCodeAtPos()))this.raise(this.pos,"Identifier directly after number");var str=this.input.slice(start,this.pos),val;if(isFloat)val=parseFloat(str);else if(!octal||str.length===1)val=parseInt(str,10);else if(/[89]/.test(str)||this.strict)this.raise(start,"Invalid number");else val=parseInt(str,8);return this.finishToken(tt.num,val)};pp$7.readCodePoint=function(){var ch=this.input.charCodeAt(this.pos),code;if(ch===123){if(this.options.ecmaVersion<6)this.unexpected();var codePos=++this.pos;code=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos);++this.pos;if(code>1114111)this.raise(codePos,"Code point out of bounds")}else{code=this.readHexChar(4)}return code};function codePointToString(code){if(code<=65535)return String.fromCharCode(code);code-=65536;return String.fromCharCode((code>>10)+55296,(code&1023)+56320)}pp$7.readString=function(quote){var this$1=this;var out="",chunkStart=++this.pos;for(;;){if(this$1.pos>=this$1.input.length)this$1.raise(this$1.start,"Unterminated string constant");var ch=this$1.input.charCodeAt(this$1.pos);if(ch===quote)break;if(ch===92){out+=this$1.input.slice(chunkStart,this$1.pos);out+=this$1.readEscapedChar(false);chunkStart=this$1.pos}else{if(isNewLine(ch))this$1.raise(this$1.start,"Unterminated string constant");++this$1.pos}}out+=this.input.slice(chunkStart,this.pos++);return this.finishToken(tt.string,out)};pp$7.readTmplToken=function(){var this$1=this;var out="",chunkStart=this.pos;for(;;){if(this$1.pos>=this$1.input.length)this$1.raise(this$1.start,"Unterminated template");var ch=this$1.input.charCodeAt(this$1.pos);if(ch===96||ch===36&&this$1.input.charCodeAt(this$1.pos+1)===123){if(this$1.pos===this$1.start&&this$1.type===tt.template){if(ch===36){this$1.pos+=2;return this$1.finishToken(tt.dollarBraceL)}else{++this$1.pos;return this$1.finishToken(tt.backQuote)}}out+=this$1.input.slice(chunkStart,this$1.pos);return this$1.finishToken(tt.template,out)}if(ch===92){out+=this$1.input.slice(chunkStart,this$1.pos);out+=this$1.readEscapedChar(true);chunkStart=this$1.pos}else if(isNewLine(ch)){out+=this$1.input.slice(chunkStart,this$1.pos);++this$1.pos;switch(ch){case 13:if(this$1.input.charCodeAt(this$1.pos)===10)++this$1.pos;case 10:out+="\n";break;default:out+=String.fromCharCode(ch);break}if(this$1.options.locations){++this$1.curLine;this$1.lineStart=this$1.pos}chunkStart=this$1.pos}else{++this$1.pos}}};pp$7.readEscapedChar=function(inTemplate){var ch=this.input.charCodeAt(++this.pos);++this.pos;switch(ch){case 110:return"\n";case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return codePointToString(this.readCodePoint());case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:if(this.input.charCodeAt(this.pos)===10)++this.pos;case 10:if(this.options.locations){this.lineStart=this.pos;++this.curLine}return"";default:if(ch>=48&&ch<=55){var octalStr=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0];var octal=parseInt(octalStr,8);if(octal>255){octalStr=octalStr.slice(0,-1);octal=parseInt(octalStr,8)}if(octalStr!=="0"&&(this.strict||inTemplate)){this.raise(this.pos-2,"Octal literal in strict mode")}this.pos+=octalStr.length-1;return String.fromCharCode(octal)}return String.fromCharCode(ch)}};pp$7.readHexChar=function(len){var codePos=this.pos;var n=this.readInt(16,len);if(n===null)this.raise(codePos,"Bad character escape sequence");return n};pp$7.readWord1=function(){var this$1=this;this.containsEsc=false;var word="",first=true,chunkStart=this.pos;var astral=this.options.ecmaVersion>=6;while(this.pos<this.input.length){var ch=this$1.fullCharCodeAtPos();if(isIdentifierChar(ch,astral)){this$1.pos+=ch<=65535?1:2}else if(ch===92){this$1.containsEsc=true;word+=this$1.input.slice(chunkStart,this$1.pos);var escStart=this$1.pos;if(this$1.input.charCodeAt(++this$1.pos)!=117)this$1.raise(this$1.pos,"Expecting Unicode escape sequence \\uXXXX");++this$1.pos;var esc=this$1.readCodePoint();if(!(first?isIdentifierStart:isIdentifierChar)(esc,astral))this$1.raise(escStart,"Invalid Unicode escape");word+=codePointToString(esc);chunkStart=this$1.pos}else{break}first=false}return word+this.input.slice(chunkStart,this.pos)};pp$7.readWord=function(){var word=this.readWord1();var type=tt.name;if((this.options.ecmaVersion>=6||!this.containsEsc)&&this.keywords.test(word))type=keywordTypes[word];return this.finishToken(type,word)};var version="4.0.3";function parse(input,options){return new Parser(options,input).parse()}function parseExpressionAt(input,pos,options){var p=new Parser(options,input,pos);p.nextToken();return p.parseExpression()}function tokenizer(input,options){return new Parser(options,input)}function addLooseExports(parse,Parser,plugins){parse_dammit=parse;LooseParser=Parser;pluginsLoose=plugins}window.call_acorn_parse=parse})();function isNumeric(num){return num>=0||num<0&&parseInt(num)===num}var binaryOperators={"+":"add","-":"sub","*":"multiply","/":"divide",">":"greater",">=":"greaterorequal","<":"less","<=":"lessorequal","+=":"plusequal","-=":"minusequal","*=":"timesequal","/=":"divideequal"};var unaryOperators={"-":"negate","+":"plus"};function papercompile(code){var insertions=[];function getOffset(offset){for(var i=0,l=insertions.length;i<l;i++){var insertion=insertions[i];if(insertion[0]>=offset)break;offset+=insertion[1]}return offset}function getCode(node){return code.substring(getOffset(node.range[0]),getOffset(node.range[1]))}function replaceCode(node,str){var start=getOffset(node.range[0]),end=getOffset(node.range[1]);var insert=0;for(var i=insertions.length-1;i>=0;i--){if(start>insertions[i][0]){insert=i+1;break}}insertions.splice(insert,0,[start,str.length-end+start]);code=code.substring(0,start)+str+code.substring(end)}function walkAST(node,parent){if(!node)return;for(var key in node){if(key==="range")continue;var value=node[key];if(Array.isArray(value)){for(var i=0,l=value.length;i<l;i++)walkAST(value[i],node)}else if(value&&typeof value==="object"){walkAST(value,node)}}var left;var right;var arg;switch(node&&node.type){case"BinaryExpression":if(node.operator in binaryOperators){left=getCode(node.left);right=getCode(node.right);arg=binaryOperators[node.operator];replaceCode(node,left+'["'+node.operator+'"]('+right+")")}break;case"AssignmentExpression":if(node.operator in binaryOperators){left=getCode(node.left);right=getCode(node.right);replaceCode(node,left+"="+left+'["'+node.operator+'"]('+right+")")}break;case"UnaryExpression":if(node.operator in unaryOperators){arg=getCode(node.argument);if(node.operator=="-")replaceCode(node,arg+'["-u"]()');else replaceCode(node,arg)}break}}walkAST(window.call_acorn_parse(code,{ranges:true}));return code}if(!Object.create||!Object.defineProperty||!Object.defineProperties)alert("Example will fail because your browser does not support ECMAScript 5. Try with another browser!");var __filename=""+window.location;window.Streamline={globals:{}};function srequire(str){if(str=="streamline/lib/util/flows")return Streamline.flows;else if(str=="streamline/lib/globals")return Streamline.globals;else if(str=="streamline/lib/version")return Streamline.version;else if(str=="streamline/lib/callbacks/runtime")return Streamline.runtime;else if(str=="streamline/lib/callbacks/transform")return Streamline;else if(str=="streamline/lib/callbacks/builtins")return Streamline.builtins;else if(str=="streamline/lib/util/future")return Streamline.future;else if(str=="streamline/lib/util/source-map")return Streamline.sourceMap.exports;else throw new Error("Cannot require "+str)}(function(){var narcissus={options:{version:185},hostGlobal:this};Narcissus=narcissus})();Narcissus.definitions=function(){var tokens=["END","\n",";",",","=","?",":","CONDITIONAL","||","&&","|","^","&","==","!=","===","!==","<","<=",">=",">","<<",">>",">>>","+","-","*","/","%","!","~","UNARY_PLUS","UNARY_MINUS","++","--",".","[","]","{","}","(",")","SCRIPT","BLOCK","LABEL","FOR_IN","CALL","NEW_WITH_ARGS","INDEX","ARRAY_INIT","OBJECT_INIT","PROPERTY_INIT","GETTER","SETTER","GROUP","LIST","LET_BLOCK","ARRAY_COMP","GENERATOR","COMP_TAIL","IDENTIFIER","NUMBER","STRING","REGEXP","break","case","catch","const","continue","debugger","default","delete","do","else","false","finally","for","function","if","in","instanceof","let","new","null","return","switch","this","throw","true","try","typeof","var","void","yield","while","with"];var statementStartTokens=["break","const","continue","debugger","do","for","if","return","switch","throw","try","var","yield","while","with"];var opTypeNames={"\n":"NEWLINE",";":"SEMICOLON",",":"COMMA","?":"HOOK",":":"COLON","||":"OR","&&":"AND","|":"BITWISE_OR","^":"BITWISE_XOR","&":"BITWISE_AND","===":"STRICT_EQ","==":"EQ","=":"ASSIGN","!==":"STRICT_NE","!=":"NE","<<":"LSH","<=":"LE","<":"LT",">>>":"URSH",">>":"RSH",">=":"GE",">":"GT","++":"INCREMENT","--":"DECREMENT","+":"PLUS","-":"MINUS","*":"MUL","/":"DIV","%":"MOD","!":"NOT","~":"BITWISE_NOT",".":"DOT","[":"LEFT_BRACKET","]":"RIGHT_BRACKET","{":"LEFT_CURLY","}":"RIGHT_CURLY","(":"LEFT_PAREN",")":"RIGHT_PAREN"};var keywords={__proto__:null};var tokenIds={};var consts="var ";for(var i=0,j=tokens.length;i<j;i++){if(i>0)consts+=", ";var t=tokens[i];var name;if(/^[a-z]/.test(t)){name=t.toUpperCase();keywords[t]=i}else{name=/^\W/.test(t)?opTypeNames[t]:t}consts+=name+" = "+i;tokenIds[name]=i;tokens[t]=i}consts+=";";var isStatementStartCode={__proto__:null};for(i=0,j=statementStartTokens.length;i<j;i++)isStatementStartCode[keywords[statementStartTokens[i]]]=true;var assignOps=["|","^","&","<<",">>",">>>","+","-","*","/","%"];for(i=0,j=assignOps.length;i<j;i++){t=assignOps[i];assignOps[t]=tokens[t]}function defineGetter(obj,prop,fn,dontDelete,dontEnum){Object.defineProperty(obj,prop,{get:fn,configurable:!dontDelete,enumerable:!dontEnum})}function defineProperty(obj,prop,val,dontDelete,readOnly,dontEnum){Object.defineProperty(obj,prop,{value:val,writable:!readOnly,configurable:!dontDelete,enumerable:!dontEnum})}function isNativeCode(fn){return typeof fn==="function"&&fn.toString().match(/\[native code\]/)}function getPropertyDescriptor(obj,name){while(obj){if({}.hasOwnProperty.call(obj,name))return Object.getOwnPropertyDescriptor(obj,name);obj=Object.getPrototypeOf(obj)}}function getOwnProperties(obj){var map={};for(var name in Object.getOwnPropertyNames(obj))map[name]=Object.getOwnPropertyDescriptor(obj,name);return map}function makePassthruHandler(obj){return{getOwnPropertyDescriptor:function(name){var desc=Object.getOwnPropertyDescriptor(obj,name);desc.configurable=true;return desc},getPropertyDescriptor:function(name){var desc=getPropertyDescriptor(obj,name);desc.configurable=true;return desc},getOwnPropertyNames:function(){return Object.getOwnPropertyNames(obj)},defineProperty:function(name,desc){Object.defineProperty(obj,name,desc)},delete:function(name){return delete obj[name]},fix:function(){if(Object.isFrozen(obj)){return getOwnProperties(obj)}return undefined},has:function(name){return name in obj},hasOwn:function(name){return{}.hasOwnProperty.call(obj,name)},get:function(receiver,name){return obj[name]},set:function(receiver,name,val){obj[name]=val;return true},enumerate:function(){var result=[];for(name in obj){result.push(name)}return result},keys:function(){return Object.keys(obj)}}}function noPropFound(){return undefined}var hasOwnProperty={}.hasOwnProperty;function StringMap(){this.table=Object.create(null,{});this.size=0}StringMap.prototype={has:function(x){return hasOwnProperty.call(this.table,x)},set:function(x,v){if(!hasOwnProperty.call(this.table,x))this.size++;this.table[x]=v},get:function(x){return this.table[x]},getDef:function(x,thunk){if(!hasOwnProperty.call(this.table,x)){this.size++;this.table[x]=thunk()}return this.table[x]},forEach:function(f){var table=this.table;for(var key in table)f.call(this,key,table[key])},toString:function(){return"[object StringMap]"}};function Stack(elts){this.elts=elts||null}Stack.prototype={push:function(x){return new Stack({top:x,rest:this.elts})},top:function(){if(!this.elts)throw new Error("empty stack");return this.elts.top},isEmpty:function(){return this.top===null},find:function(test){for(var elts=this.elts;elts;elts=elts.rest){if(test(elts.top))return elts.top}return null},has:function(x){return Boolean(this.find(function(elt){return elt===x}))},forEach:function(f){for(var elts=this.elts;elts;elts=elts.rest){f(elts.top)}}};return{tokens:tokens,opTypeNames:opTypeNames,keywords:keywords,isStatementStartCode:isStatementStartCode,tokenIds:tokenIds,consts:consts,assignOps:assignOps,defineGetter:defineGetter,defineProperty:defineProperty,isNativeCode:isNativeCode,makePassthruHandler:makePassthruHandler,noPropFound:noPropFound,StringMap:StringMap,Stack:Stack}}();Narcissus.lexer=function(){var definitions=Narcissus.definitions;eval(definitions.consts);var opTokens={};for(var op in definitions.opTypeNames){if(op==="\n"||op===".")continue;var node=opTokens;for(var i=0;i<op.length;i++){var ch=op[i];if(!(ch in node))node[ch]={};node=node[ch];node.op=op}}function Tokenizer(s,f,l){this.cursor=0;this.source=String(s);this.tokens=[];this.tokenIndex=0;this.lookahead=0;this.scanNewlines=false;this.unexpectedEOF=false;this.filename=f||"";this.lineno=l||1}Tokenizer.prototype={get done(){return this.peek(true)===END},get token(){return this.tokens[this.tokenIndex]},match:function(tt,scanOperand){return this.get(scanOperand)===tt||this.unget()},mustMatch:function(tt){if(!this.match(tt)){throw this.newSyntaxError("Missing "+definitions.tokens[tt].toLowerCase())}return this.token},forceIdentifier:function(){if(!this.match(IDENTIFIER)){if(this.get()>=definitions.keywords[0]||this.unget){this.token.type=IDENTIFIER}else{throw this.newSyntaxError("Missing identifier")}}return this.token},peek:function(scanOperand){var tt,next;if(this.lookahead){next=this.tokens[this.tokenIndex+this.lookahead&3];tt=this.scanNewlines&&next.lineno!==this.lineno?NEWLINE:next.type}else{tt=this.get(scanOperand);this.unget()}return tt},peekOnSameLine:function(scanOperand){this.scanNewlines=true;var tt=this.peek(scanOperand);this.scanNewlines=false;return tt},skip:function(){var input=this.source;for(;;){var ch=input[this.cursor++];var next=input[this.cursor];if(ch==="\n"&&!this.scanNewlines){this.lineno++}else if(ch==="/"&&next==="*"){this.cursor++;for(;;){ch=input[this.cursor++];if(ch===undefined)throw this.newSyntaxError("Unterminated comment");if(ch==="*"){next=input[this.cursor];if(next==="/"){this.cursor++;break}}else if(ch==="\n"){this.lineno++}}}else if(ch==="/"&&next==="/"){this.cursor++;for(;;){ch=input[this.cursor++];if(ch===undefined)return;if(ch==="\n"){this.lineno++;break}}}else if(ch!==" "&&ch!=="\t"){this.cursor--;return}}},lexExponent:function(){var input=this.source;var next=input[this.cursor];if(next==="e"||next==="E"){this.cursor++;ch=input[this.cursor++];if(ch==="+"||ch==="-")ch=input[this.cursor++];if(ch<"0"||ch>"9")throw this.newSyntaxError("Missing exponent");do{ch=input[this.cursor++]}while(ch>="0"&&ch<="9");this.cursor--;return true}return false},lexZeroNumber:function(ch){var token=this.token,input=this.source;token.type=NUMBER;ch=input[this.cursor++];if(ch==="."){do{ch=input[this.cursor++]}while(ch>="0"&&ch<="9");this.cursor--;this.lexExponent();token.value=parseFloat(input.substring(token.start,this.cursor))}else if(ch==="x"||ch==="X"){do{ch=input[this.cursor++]}while(ch>="0"&&ch<="9"||ch>="a"&&ch<="f"||ch>="A"&&ch<="F");this.cursor--;token.value=parseInt(input.substring(token.start,this.cursor))}else if(ch>="0"&&ch<="7"){do{ch=input[this.cursor++]}while(ch>="0"&&ch<="7");this.cursor--;token.value=parseInt(input.substring(token.start,this.cursor),8);token.value.isOctal=true}else{this.cursor--;this.lexExponent();token.value=0}},lexNumber:function(ch){var token=this.token,input=this.source;token.type=NUMBER;var floating=false;do{ch=input[this.cursor++];if(ch==="."&&!floating){floating=true;ch=input[this.cursor++]}}while(ch>="0"&&ch<="9");this.cursor--;var exponent=this.lexExponent();floating=floating||exponent;var str=input.substring(token.start,this.cursor);token.value=floating?parseFloat(str):parseInt(str)},lexDot:function(ch){var token=this.token,input=this.source;var next=input[this.cursor];if(next>="0"&&next<="9"){do{ch=input[this.cursor++]}while(ch>="0"&&ch<="9");this.cursor--;this.lexExponent();token.type=NUMBER;token.value=parseFloat(input.substring(token.start,this.cursor))}else{token.type=DOT;token.assignOp=null;token.value="."}},lexString:function(ch){var token=this.token,input=this.source;token.type=STRING;var hasEscapes=false;var delim=ch;while((ch=input[this.cursor++])!==delim){if(this.cursor==input.length)throw this.newSyntaxError("Unterminated string literal");if(ch==="\\"){hasEscapes=true;if(input[this.cursor]==="\n")this.lineno++;if(++this.cursor==input.length)throw this.newSyntaxError("Unterminated string literal")}}token.value=hasEscapes?eval(input.substring(token.start,this.cursor)):input.substring(token.start+1,this.cursor-1)},lexRegExp:function(ch){var token=this.token,input=this.source;token.type=REGEXP;do{ch=input[this.cursor++];if(ch==="\\"){this.cursor++}else if(ch==="["){do{if(ch===undefined)throw this.newSyntaxError("Unterminated character class");if(ch==="\\")this.cursor++;ch=input[this.cursor++]}while(ch!=="]")}else if(ch===undefined){throw this.newSyntaxError("Unterminated regex")}}while(ch!=="/");do{ch=input[this.cursor++]}while(ch>="a"&&ch<="z");this.cursor--;token.value=eval(input.substring(token.start,this.cursor))},lexOp:function(ch){var token=this.token,input=this.source;var node=opTokens[ch];var next=input[this.cursor];if(next in node){node=node[next];this.cursor++;next=input[this.cursor];if(next in node){node=node[next];this.cursor++;next=input[this.cursor]}}var op=node.op;if(definitions.assignOps[op]&&input[this.cursor]==="="){this.cursor++;token.type=ASSIGN;token.assignOp=definitions.tokenIds[definitions.opTypeNames[op]];op+="="}else{token.type=definitions.tokenIds[definitions.opTypeNames[op]];token.assignOp=null}token.value=op},lexIdent:function(ch){var token=this.token,input=this.source;do{ch=input[this.cursor++]}while(ch>="a"&&ch<="z"||ch>="A"&&ch<="Z"||ch>="0"&&ch<="9"||ch==="$"||ch==="_");this.cursor--;var id=input.substring(token.start,this.cursor);token.type=definitions.keywords[id]||IDENTIFIER;token.value=id},get:function(scanOperand){var token;while(this.lookahead){--this.lookahead;this.tokenIndex=this.tokenIndex+1&3;token=this.tokens[this.tokenIndex];if(token.type!==NEWLINE||this.scanNewlines)return token.type}this.skip();this.tokenIndex=this.tokenIndex+1&3;token=this.tokens[this.tokenIndex];if(!token)this.tokens[this.tokenIndex]=token={};var input=this.source;if(this.cursor===input.length)return token.type=END;token.start=this.cursor;token.lineno=this.lineno;var ch=input[this.cursor++];if(ch>="a"&&ch<="z"||ch>="A"&&ch<="Z"||ch==="$"||ch==="_"){this.lexIdent(ch)}else if(scanOperand&&ch==="/"){this.lexRegExp(ch)}else if(ch in opTokens){this.lexOp(ch)}else if(ch==="."){this.lexDot(ch)}else if(ch>="1"&&ch<="9"){this.lexNumber(ch)}else if(ch==="0"){this.lexZeroNumber(ch)}else if(ch==='"'||ch==="'"){this.lexString(ch)}else if(this.scanNewlines&&ch==="\n"){token.type=NEWLINE;token.value="\n";this.lineno++}else{throw this.newSyntaxError("Illegal token")}token.end=this.cursor;return token.type},unget:function(){if(++this.lookahead===4)throw"PANIC: too much lookahead!";this.tokenIndex=this.tokenIndex-1&3},newSyntaxError:function(m){var e=new SyntaxError(this.filename+":"+this.lineno+":"+m);e.source=this.source;e.cursor=this.lookahead?this.tokens[this.tokenIndex+this.lookahead&3].start:this.cursor;return e}};return{Tokenizer:Tokenizer}}();Narcissus.parser=function(){var lexer=Narcissus.lexer;var definitions=Narcissus.definitions;const StringMap=definitions.StringMap;const Stack=definitions.Stack;eval(definitions.consts);function pushDestructuringVarDecls(n,s){for(var i in n){var sub=n[i];if(sub.type===IDENTIFIER){s.varDecls.push(sub)}else{pushDestructuringVarDecls(sub,s)}}}const NESTING_TOP=0,NESTING_SHALLOW=1,NESTING_DEEP=2;function StaticContext(parentScript,parentBlock,inFunction,inForLoopInit,nesting){this.parentScript=parentScript;this.parentBlock=parentBlock;this.inFunction=inFunction;this.inForLoopInit=inForLoopInit;this.nesting=nesting;this.allLabels=new Stack;this.currentLabels=new Stack;this.labeledTargets=new Stack;this.defaultTarget=null;Narcissus.options.ecma3OnlyMode&&(this.ecma3OnlyMode=true);Narcissus.options.parenFreeMode&&(this.parenFreeMode=true)}StaticContext.prototype={ecma3OnlyMode:false,parenFreeMode:false,update:function(ext){var desc={};for(var key in ext){desc[key]={value:ext[key],writable:true,enumerable:true,configurable:true}}return Object.create(this,desc)},pushLabel:function(label){return this.update({currentLabels:this.currentLabels.push(label),allLabels:this.allLabels.push(label)})},pushTarget:function(target){var isDefaultTarget=target.isLoop||target.type===SWITCH;if(isDefaultTarget)target.target=this.defaultTarget;if(this.currentLabels.isEmpty()){return isDefaultTarget?this.update({defaultTarget:target}):this}target.labels=new StringMap;this.currentLabels.forEach(function(label){target.labels.set(label,true)});return this.update({currentLabels:new Stack,labeledTargets:this.labeledTargets.push(target),defaultTarget:isDefaultTarget?target:this.defaultTarget})},nest:function(atLeast){var nesting=Math.max(this.nesting,atLeast);return nesting!==this.nesting?this.update({nesting:nesting}):this}};function Script(t,inFunction){var n=new Node(t,scriptInit());var x=new StaticContext(n,n,inFunction,false,NESTING_TOP);Statements(t,x,n);return n}definitions.defineProperty(Array.prototype,"top",function(){return this.length&&this[this.length-1]},false,false,true);function Node(t,init){var token=t.token;if(token){this.type=token.type;this.value=token.value;this.lineno=token.lineno;this.start=token.start;this.end=token.end}else{this.lineno=t.lineno}this.tokenizer=t;this.children=[];for(var prop in init)this[prop]=init[prop]}var Np=Node.prototype={};Np.constructor=Node;Np.toSource=Object.prototype.toSource;Np.push=function(kid){if(kid!==null){if(kid.start<this.start)this.start=kid.start;if(this.end<kid.end)this.end=kid.end}return this.children.push(kid)};Node.indentLevel=0;function tokenString(tt){var t=definitions.tokens[tt];return/^\W/.test(t)?definitions.opTypeNames[t]:t.toUpperCase()}Np.toString=function(){var a=[];for(var i in this){if(this.hasOwnProperty(i)&&i!=="type"&&i!=="target")a.push({id:i,value:this[i]})}a.sort(function(a,b){return a.id<b.id?-1:1});const INDENTATION="    ";var n=++Node.indentLevel;var s="{\n"+INDENTATION.repeat(n)+"type: "+tokenString(this.type);for(i=0;i<a.length;i++)s+=", "+a[i].id+": "+a[i].value;n=--Node.indentLevel;s+="\n"+INDENTATION.repeat(n)+"}";return s};Np.getSource=function(){return this.tokenizer.source.slice(this.start,this.end)};const LOOP_INIT={isLoop:true};function blockInit(){return{type:BLOCK,varDecls:[]}}function scriptInit(){return{type:SCRIPT,funDecls:[],varDecls:[],modDecls:[],impDecls:[],expDecls:[],loadDeps:[],hasEmptyReturn:false,hasReturnWithValue:false,isGenerator:false}}definitions.defineGetter(Np,"filename",function(){return this.tokenizer.filename});definitions.defineGetter(Np,"length",function(){throw new Error("Node.prototype.length is gone; "+"use n.children.length instead")});definitions.defineProperty(String.prototype,"repeat",function(n){var s="",t=this+s;while(--n>=0)s+=t;return s},false,false,true);function MaybeLeftParen(t,x){if(x.parenFreeMode)return t.match(LEFT_PAREN)?LEFT_PAREN:END;return t.mustMatch(LEFT_PAREN).type}function MaybeRightParen(t,p){if(p===LEFT_PAREN)t.mustMatch(RIGHT_PAREN)}function Statements(t,x,n){try{while(!t.done&&t.peek(true)!==RIGHT_CURLY)n.push(Statement(t,x))}catch(e){if(t.done)t.unexpectedEOF=true;throw e}}function Block(t,x){t.mustMatch(LEFT_CURLY);var n=new Node(t,blockInit());Statements(t,x.update({parentBlock:n}).pushTarget(n),n);t.mustMatch(RIGHT_CURLY);n.end=t.token.end;return n}const DECLARED_FORM=0,EXPRESSED_FORM=1,STATEMENT_FORM=2;function Statement(t,x){var i,label,n,n2,p,c,ss,tt=t.get(true),tt2,x2,x3;switch(tt){case FUNCTION:return FunctionDefinition(t,x,true,x.nesting!==NESTING_TOP?STATEMENT_FORM:DECLARED_FORM);case LEFT_CURLY:n=new Node(t,blockInit());Statements(t,x.update({parentBlock:n}).pushTarget(n).nest(NESTING_SHALLOW),n);t.mustMatch(RIGHT_CURLY);n.end=t.token.end;return n;case IF:n=new Node(t);n.condition=HeadExpression(t,x);x2=x.pushTarget(n).nest(NESTING_DEEP);n.thenPart=Statement(t,x2);n.elsePart=t.match(ELSE)?Statement(t,x2):null;return n;case SWITCH:n=new Node(t,{cases:[],defaultIndex:-1});n.discriminant=HeadExpression(t,x);x2=x.pushTarget(n).nest(NESTING_DEEP);t.mustMatch(LEFT_CURLY);while((tt=t.get())!==RIGHT_CURLY){switch(tt){case DEFAULT:if(n.defaultIndex>=0)throw t.newSyntaxError("More than one switch default");case CASE:n2=new Node(t);if(tt===DEFAULT)n.defaultIndex=n.cases.length;else n2.caseLabel=Expression(t,x2,COLON);break;default:throw t.newSyntaxError("Invalid switch case")}t.mustMatch(COLON);n2.statements=new Node(t,blockInit());while((tt=t.peek(true))!==CASE&&tt!==DEFAULT&&tt!==RIGHT_CURLY)n2.statements.push(Statement(t,x2));n.cases.push(n2)}n.end=t.token.end;return n;case FOR:n=new Node(t,LOOP_INIT);if(t.match(IDENTIFIER)){if(t.token.value==="each")n.isEach=true;else t.unget()}if(!x.parenFreeMode)t.mustMatch(LEFT_PAREN);x2=x.pushTarget(n).nest(NESTING_DEEP);x3=x.update({inForLoopInit:true});if((tt=t.peek())!==SEMICOLON){if(tt===VAR||tt===CONST){t.get();n2=Variables(t,x3)}else if(tt===LET){t.get();if(t.peek()===LEFT_PAREN){n2=LetBlock(t,x3,false)}else{x3.parentBlock=n;n.varDecls=[];n2=Variables(t,x3)}}else{n2=Expression(t,x3)}}if(n2&&t.match(IN)){n.type=FOR_IN;n.object=Expression(t,x3);if(n2.type===VAR||n2.type===LET){c=n2.children;if(c.length!==1&&n2.destructurings.length!==1){throw new SyntaxError("Invalid for..in left-hand side",t.filename,n2.lineno)}if(n2.destructurings.length>0){n.iterator=n2.destructurings[0]}else{n.iterator=c[0]}n.varDecl=n2}else{if(n2.type===ARRAY_INIT||n2.type===OBJECT_INIT){n2.destructuredNames=checkDestructuring(t,x3,n2)}n.iterator=n2}}else{n.setup=n2;t.mustMatch(SEMICOLON);if(n.isEach)throw t.newSyntaxError("Invalid for each..in loop");n.condition=t.peek()===SEMICOLON?null:Expression(t,x3);t.mustMatch(SEMICOLON);tt2=t.peek();n.update=(x.parenFreeMode?tt2===LEFT_CURLY||definitions.isStatementStartCode[tt2]:tt2===RIGHT_PAREN)?null:Expression(t,x3)}if(!x.parenFreeMode)t.mustMatch(RIGHT_PAREN);n.body=Statement(t,x2);n.end=t.token.end;return n;case WHILE:n=new Node(t,{isLoop:true});n.condition=HeadExpression(t,x);n.body=Statement(t,x.pushTarget(n).nest(NESTING_DEEP));n.end=t.token.end;return n;case DO:n=new Node(t,{isLoop:true});n.body=Statement(t,x.pushTarget(n).nest(NESTING_DEEP));t.mustMatch(WHILE);n.condition=HeadExpression(t,x);if(!x.ecmaStrictMode){t.match(SEMICOLON);n.end=t.token.end;return n}break;case BREAK:case CONTINUE:n=new Node(t);x2=x.pushTarget(n);if(t.peekOnSameLine()===IDENTIFIER){t.get();n.label=t.token.value}n.target=n.label?x2.labeledTargets.find(function(target){return target.labels.has(n.label)}):x2.defaultTarget;if(!n.target)throw t.newSyntaxError("Invalid "+(tt===BREAK?"break":"continue"));if(tt===CONTINUE){for(var ttt=n.target;ttt&&!ttt.isLoop;ttt=ttt.target);if(!ttt)throw t.newSyntaxError("Invalid continue")}break;case TRY:n=new Node(t,{catchClauses:[]});n.tryBlock=Block(t,x);while(t.match(CATCH)){n2=new Node(t);p=MaybeLeftParen(t,x);switch(t.get()){case LEFT_BRACKET:case LEFT_CURLY:t.unget();n2.varName=DestructuringExpression(t,x,true);break;case IDENTIFIER:n2.varName=t.token.value;break;default:throw t.newSyntaxError("missing identifier in catch");break}if(t.match(IF)){if(x.ecma3OnlyMode)throw t.newSyntaxError("Illegal catch guard");if(n.catchClauses.length&&!n.catchClauses.top().guard)throw t.newSyntaxError("Guarded catch after unguarded");n2.guard=Expression(t,x)}MaybeRightParen(t,p);n2.block=Block(t,x);n.catchClauses.push(n2)}if(t.match(FINALLY))n.finallyBlock=Block(t,x);if(!n.catchClauses.length&&!n.finallyBlock)throw t.newSyntaxError("Invalid try statement");n.end=t.token.end;return n;case CATCH:case FINALLY:throw t.newSyntaxError(definitions.tokens[tt]+" without preceding try");case THROW:n=new Node(t);n.exception=Expression(t,x);break;case RETURN:n=ReturnOrYield(t,x);break;case WITH:n=new Node(t);n.object=HeadExpression(t,x);n.body=Statement(t,x.pushTarget(n).nest(NESTING_DEEP));n.end=t.token.end;return n;case VAR:case CONST:n=Variables(t,x);n.eligibleForASI=true;break;case LET:if(t.peek()===LEFT_PAREN)n=LetBlock(t,x,true);else n=Variables(t,x);n.eligibleForASI=true;break;case DEBUGGER:n=new Node(t);break;case NEWLINE:case SEMICOLON:n=new Node(t,{type:SEMICOLON});n.expression=null;return n;default:if(tt===IDENTIFIER){tt=t.peek();if(tt===COLON){label=t.token.value;if(x.allLabels.has(label))throw t.newSyntaxError("Duplicate label");t.get();n=new Node(t,{type:LABEL,label:label});n.statement=Statement(t,x.pushLabel(label).nest(NESTING_SHALLOW));n.target=n.statement.type===LABEL?n.statement.target:n.statement;n.end=t.token.end;return n}}n=new Node(t,{type:SEMICOLON});t.unget();n.expression=Expression(t,x);n.end=n.expression.end;break}MagicalSemicolon(t);n.end=t.token.end;return n}function MagicalSemicolon(t){var tt;if(t.lineno===t.token.lineno){tt=t.peekOnSameLine();if(tt!==END&&tt!==NEWLINE&&tt!==SEMICOLON&&tt!==RIGHT_CURLY)throw t.newSyntaxError("missing ; before statement")}t.match(SEMICOLON)}function ReturnOrYield(t,x){var n,b,tt=t.token.type,tt2;var parentScript=x.parentScript;if(tt===RETURN){if(false&&!x.inFunction)throw t.newSyntaxError("Return not in function")}else{if(!x.inFunction)throw t.newSyntaxError("Yield not in function");parentScript.isGenerator=true}n=new Node(t,{value:undefined});tt2=t.peek(true);if(tt2!==END&&tt2!==NEWLINE&&tt2!==SEMICOLON&&tt2!==RIGHT_CURLY&&(tt!==YIELD||tt2!==tt&&tt2!==RIGHT_BRACKET&&tt2!==RIGHT_PAREN&&tt2!==COLON&&tt2!==COMMA)){if(tt===RETURN){n.value=Expression(t,x);parentScript.hasReturnWithValue=true}else{n.value=AssignExpression(t,x)}}else if(tt===RETURN){parentScript.hasEmptyReturn=true}if(parentScript.hasReturnWithValue&&parentScript.isGenerator)throw t.newSyntaxError("Generator returns a value");return n}function FunctionDefinition(t,x,requireName,functionForm){var tt;var f=new Node(t,{params:[]});if(f.type!==FUNCTION)f.type=f.value==="get"?GETTER:SETTER;if(t.match(IDENTIFIER))f.name=t.token.value;else if(requireName)throw t.newSyntaxError("missing function identifier");var x2=new StaticContext(null,null,true,false,NESTING_TOP);t.mustMatch(LEFT_PAREN);if(!t.match(RIGHT_PAREN)){do{switch(t.get()){case LEFT_BRACKET:case LEFT_CURLY:t.unget();f.params.push(DestructuringExpression(t,x2));break;case IDENTIFIER:f.params.push(t.token.value);break;default:throw t.newSyntaxError("missing formal parameter");break}}while(t.match(COMMA));t.mustMatch(RIGHT_PAREN)}tt=t.get();if(tt!==LEFT_CURLY)t.unget();if(tt!==LEFT_CURLY){f.body=AssignExpression(t,x2);if(f.body.isGenerator)throw t.newSyntaxError("Generator returns a value")}else{f.body=Script(t,true)}if(tt===LEFT_CURLY)t.mustMatch(RIGHT_CURLY);f.end=t.token.end;f.functionForm=functionForm;if(functionForm===DECLARED_FORM)x.parentScript.funDecls.push(f);return f}function Variables(t,x,letBlock){var n,n2,ss,i,s,tt;tt=t.token.type;switch(tt){case VAR:case CONST:s=x.parentScript;break;case LET:s=x.parentBlock;break;case LEFT_PAREN:tt=LET;s=letBlock;break}n=new Node(t,{type:tt,destructurings:[]});do{tt=t.get();if(tt===LEFT_BRACKET||tt===LEFT_CURLY){t.unget();var dexp=DestructuringExpression(t,x,true);n2=new Node(t,{type:IDENTIFIER,name:dexp,readOnly:n.type===CONST});n.push(n2);pushDestructuringVarDecls(n2.name.destructuredNames,s);n.destructurings.push({exp:dexp,decl:n2});if(x.inForLoopInit&&t.peek()===IN){continue}t.mustMatch(ASSIGN);if(t.token.assignOp)throw t.newSyntaxError("Invalid variable initialization");n2.initializer=AssignExpression(t,x);continue}if(tt!==IDENTIFIER)throw t.newSyntaxError("missing variable name");n2=new Node(t,{type:IDENTIFIER,name:t.token.value,readOnly:n.type===CONST});n.push(n2);s.varDecls.push(n2);if(t.match(ASSIGN)){if(t.token.assignOp)throw t.newSyntaxError("Invalid variable initialization");n2.initializer=AssignExpression(t,x)}}while(t.match(COMMA));n.end=t.token.end;return n}function LetBlock(t,x,isStatement){var n,n2;n=new Node(t,{type:LET_BLOCK,varDecls:[]});t.mustMatch(LEFT_PAREN);n.variables=Variables(t,x,n);t.mustMatch(RIGHT_PAREN);if(isStatement&&t.peek()!==LEFT_CURLY){n2=new Node(t,{type:SEMICOLON,expression:n});isStatement=false}if(isStatement)n.block=Block(t,x);else n.expression=AssignExpression(t,x);return n}function checkDestructuring(t,x,n,simpleNamesOnly){if(n.type===ARRAY_COMP)throw t.newSyntaxError("Invalid array comprehension left-hand side");if(n.type!==ARRAY_INIT&&n.type!==OBJECT_INIT)return;var lhss={};var nn,n2,idx,sub,cc,c=n.children;for(var i=0,j=c.length;i<j;i++){if(!(nn=c[i]))continue;if(nn.type===PROPERTY_INIT){cc=nn.children;sub=cc[1];idx=cc[0].value}else if(n.type===OBJECT_INIT){sub=nn;idx=nn.value}else{sub=nn;idx=i}if(sub.type===ARRAY_INIT||sub.type===OBJECT_INIT){lhss[idx]=checkDestructuring(t,x,sub,simpleNamesOnly)}else{if(simpleNamesOnly&&sub.type!==IDENTIFIER){throw t.newSyntaxError("missing name in pattern")}lhss[idx]=sub}}return lhss}function DestructuringExpression(t,x,simpleNamesOnly){var n=PrimaryExpression(t,x);n.destructuredNames=checkDestructuring(t,x,n,simpleNamesOnly);return n}function GeneratorExpression(t,x,e){return new Node(t,{type:GENERATOR,expression:e,tail:ComprehensionTail(t,x)})}function ComprehensionTail(t,x){var body,n,n2,n3,p;body=new Node(t,{type:COMP_TAIL});do{n=new Node(t,{type:FOR_IN,isLoop:true});if(t.match(IDENTIFIER)){if(t.token.value==="each")n.isEach=true;else t.unget()}p=MaybeLeftParen(t,x);switch(t.get()){case LEFT_BRACKET:case LEFT_CURLY:t.unget();n.iterator=DestructuringExpression(t,x);break;case IDENTIFIER:n.iterator=n3=new Node(t,{type:IDENTIFIER});n3.name=n3.value;n.varDecl=n2=new Node(t,{type:VAR});n2.push(n3);x.parentScript.varDecls.push(n3);break;default:throw t.newSyntaxError("missing identifier")}t.mustMatch(IN);n.object=Expression(t,x);MaybeRightParen(t,p);body.push(n)}while(t.match(FOR));if(t.match(IF))body.guard=HeadExpression(t,x);return body}function HeadExpression(t,x){var p=MaybeLeftParen(t,x);var n=ParenExpression(t,x);MaybeRightParen(t,p);if(p===END&&!n.parenthesized){var tt=t.peek();if(tt!==LEFT_CURLY&&!definitions.isStatementStartCode[tt])throw t.newSyntaxError("Unparenthesized head followed by unbraced body")}return n}function ParenExpression(t,x){var n=Expression(t,x.update({inForLoopInit:x.inForLoopInit&&t.token.type===LEFT_PAREN}));if(t.match(FOR)){if(n.type===YIELD&&!n.parenthesized)throw t.newSyntaxError("Yield expression must be parenthesized");if(n.type===COMMA&&!n.parenthesized)throw t.newSyntaxError("Generator expression must be parenthesized");n=GeneratorExpression(t,x,n)}return n}function Expression(t,x){var n,n2;n=AssignExpression(t,x);if(t.match(COMMA)){n2=new Node(t,{type:COMMA});n2.push(n);n=n2;do{n2=n.children[n.children.length-1];if(n2.type===YIELD&&!n2.parenthesized)throw t.newSyntaxError("Yield expression must be parenthesized");n.push(AssignExpression(t,x))}while(t.match(COMMA))}return n}function AssignExpression(t,x){var n,lhs;if(t.match(YIELD,true))return ReturnOrYield(t,x);n=new Node(t,{type:ASSIGN});lhs=ConditionalExpression(t,x);if(!t.match(ASSIGN)){return lhs}switch(lhs.type){case OBJECT_INIT:case ARRAY_INIT:lhs.destructuredNames=checkDestructuring(t,x,lhs);case IDENTIFIER:case DOT:case INDEX:case CALL:break;default:throw t.newSyntaxError("Bad left-hand side of assignment");break}n.assignOp=t.token.assignOp;n.push(lhs);n.push(AssignExpression(t,x));return n}function ConditionalExpression(t,x){var n,n2;n=OrExpression(t,x);if(t.match(HOOK)){n2=n;n=new Node(t,{type:HOOK});n.push(n2);n.push(AssignExpression(t,x.update({inForLoopInit:false})));if(!t.match(COLON))throw t.newSyntaxError("missing : after ?");n.push(AssignExpression(t,x))}return n}function OrExpression(t,x){var n,n2;n=AndExpression(t,x);while(t.match(OR)){n2=new Node(t);n2.push(n);n2.push(AndExpression(t,x));n=n2}return n}function AndExpression(t,x){var n,n2;n=BitwiseOrExpression(t,x);while(t.match(AND)){n2=new Node(t);n2.push(n);n2.push(BitwiseOrExpression(t,x));n=n2}return n}function BitwiseOrExpression(t,x){var n,n2;n=BitwiseXorExpression(t,x);while(t.match(BITWISE_OR)){n2=new Node(t);n2.push(n);n2.push(BitwiseXorExpression(t,x));n=n2}return n}function BitwiseXorExpression(t,x){var n,n2;n=BitwiseAndExpression(t,x);while(t.match(BITWISE_XOR)){n2=new Node(t);n2.push(n);n2.push(BitwiseAndExpression(t,x));n=n2}return n}function BitwiseAndExpression(t,x){var n,n2;n=EqualityExpression(t,x);while(t.match(BITWISE_AND)){n2=new Node(t);n2.push(n);n2.push(EqualityExpression(t,x));n=n2}return n}function EqualityExpression(t,x){var n,n2;n=RelationalExpression(t,x);while(t.match(EQ)||t.match(NE)||t.match(STRICT_EQ)||t.match(STRICT_NE)){n2=new Node(t);n2.push(n);n2.push(RelationalExpression(t,x));n=n2}return n}function RelationalExpression(t,x){var n,n2;var x2=x.update({inForLoopInit:false});n=ShiftExpression(t,x2);while(t.match(LT)||t.match(LE)||t.match(GE)||t.match(GT)||!x.inForLoopInit&&t.match(IN)||t.match(INSTANCEOF)){n2=new Node(t);n2.push(n);n2.push(ShiftExpression(t,x2));n=n2}return n}function ShiftExpression(t,x){var n,n2;n=AddExpression(t,x);while(t.match(LSH)||t.match(RSH)||t.match(URSH)){n2=new Node(t);n2.push(n);n2.push(AddExpression(t,x));n=n2}return n}function AddExpression(t,x){var n,n2;n=MultiplyExpression(t,x);while(t.match(PLUS)||t.match(MINUS)){n2=new Node(t);n2.push(n);n2.push(MultiplyExpression(t,x));n=n2}return n}function MultiplyExpression(t,x){var n,n2;n=UnaryExpression(t,x);while(t.match(MUL)||t.match(DIV)||t.match(MOD)){n2=new Node(t);n2.push(n);n2.push(UnaryExpression(t,x));n=n2}return n}function UnaryExpression(t,x){var n,n2,tt;switch(tt=t.get(true)){case DELETE:case VOID:case TYPEOF:case NOT:case BITWISE_NOT:case PLUS:case MINUS:if(tt===PLUS)n=new Node(t,{type:UNARY_PLUS});else if(tt===MINUS)n=new Node(t,{type:UNARY_MINUS});else n=new Node(t);n.push(UnaryExpression(t,x));break;case INCREMENT:case DECREMENT:n=new Node(t);n.push(MemberExpression(t,x,true));break;default:t.unget();n=MemberExpression(t,x,true);if(t.tokens[t.tokenIndex+t.lookahead-1&3].lineno===t.lineno){if(t.match(INCREMENT)||t.match(DECREMENT)){n2=new Node(t,{postfix:true});n2.push(n);n=n2}}break}return n}function MemberExpression(t,x,allowCallSyntax){var n,n2,name,tt;if(t.match(NEW)){n=new Node(t);n.push(MemberExpression(t,x,false));if(t.match(LEFT_PAREN)){n.type=NEW_WITH_ARGS;n.push(ArgumentList(t,x))}}else{n=PrimaryExpression(t,x)}while((tt=t.get())!==END){switch(tt){case DOT:n2=new Node(t);n2.push(n);t.forceIdentifier();n2.push(new Node(t));break;case LEFT_BRACKET:n2=new Node(t,{type:INDEX});n2.push(n);n2.push(Expression(t,x));t.mustMatch(RIGHT_BRACKET);n2.end=t.token.end;break;case LEFT_PAREN:if(allowCallSyntax){n2=new Node(t,{type:CALL});n2.push(n);n2.push(ArgumentList(t,x));break}default:t.unget();return n}n=n2}return n}function ArgumentList(t,x){var n,n2;n=new Node(t,{type:LIST});if(t.match(RIGHT_PAREN,true)){n.end=t.token.end;return n}do{n2=AssignExpression(t,x);if(n2.type===YIELD&&!n2.parenthesized&&t.peek()===COMMA)throw t.newSyntaxError("Yield expression must be parenthesized");if(t.match(FOR)){n2=GeneratorExpression(t,x,n2);if(n.children.length>1||t.peek(true)===COMMA)throw t.newSyntaxError("Generator expression must be parenthesized")}n.push(n2)}while(t.match(COMMA));t.mustMatch(RIGHT_PAREN);n.end=t.token.end;return n}function PrimaryExpression(t,x){var n,n2,tt=t.get(true);switch(tt){case FUNCTION:n=FunctionDefinition(t,x,false,EXPRESSED_FORM);break;case LEFT_BRACKET:n=new Node(t,{type:ARRAY_INIT});while((tt=t.peek(true))!==RIGHT_BRACKET){if(tt===COMMA){t.get();n.push(null);continue}n.push(AssignExpression(t,x));if(tt!==COMMA&&!t.match(COMMA))break}if(n.children.length===1&&t.match(FOR)){n2=new Node(t,{type:ARRAY_COMP,expression:n.children[0],tail:ComprehensionTail(t,x)});n=n2}t.mustMatch(RIGHT_BRACKET);n.end=t.token.end;break;case LEFT_CURLY:var id,fd;n=new Node(t,{type:OBJECT_INIT});object_init:if(!t.match(RIGHT_CURLY)){do{tt=t.get();if((t.token.value==="get"||t.token.value==="set")&&t.peek()===IDENTIFIER){if(x.ecma3OnlyMode)throw t.newSyntaxError("Illegal property accessor");n.push(FunctionDefinition(t,x,true,EXPRESSED_FORM))}else{switch(tt){case IDENTIFIER:case NUMBER:case STRING:id=new Node(t,{type:IDENTIFIER});break;case RIGHT_CURLY:if(x.ecma3OnlyMode)throw t.newSyntaxError("Illegal trailing ,");break object_init;default:if(t.token.value in definitions.keywords){id=new Node(t,{type:IDENTIFIER});break}throw t.newSyntaxError("Invalid property name")}if(t.match(COLON)){n2=new Node(t,{type:PROPERTY_INIT});n2.push(id);n2.push(AssignExpression(t,x));n.push(n2)}else{if(t.peek()!==COMMA&&t.peek()!==RIGHT_CURLY)throw t.newSyntaxError("missing : after property");n.push(id)}}}while(t.match(COMMA));t.mustMatch(RIGHT_CURLY)}n.end=t.token.end;break;case LEFT_PAREN:var start=t.token.start;n=ParenExpression(t,x);t.mustMatch(RIGHT_PAREN);n.start=start;n.end=t.token.end;n.parenthesized=true;break;case LET:n=LetBlock(t,x,false);break;case NULL:case THIS:case TRUE:case FALSE:case IDENTIFIER:case NUMBER:case STRING:case REGEXP:n=new Node(t);break;default:throw t.newSyntaxError("missing operand");break}return n}function parse(s,f,l){var t=new lexer.Tokenizer(s,f,l);var n=Script(t,false);if(!t.done)throw t.newSyntaxError("Syntax error");return n}function parseStdin(s,ln){for(;;){try{var t=new lexer.Tokenizer(s,"stdin",ln.value);var n=Script(t,false);ln.value=t.lineno;return n}catch(e){if(!t.unexpectedEOF)throw e;var more=readline();if(!more)throw e;s+="\n"+more}}}return{parse:parse,parseStdin:parseStdin,Node:Node,DECLARED_FORM:DECLARED_FORM,EXPRESSED_FORM:EXPRESSED_FORM,STATEMENT_FORM:STATEMENT_FORM,Tokenizer:lexer.Tokenizer,FunctionDefinition:FunctionDefinition}}();Narcissus.decompiler=function(){const parser=Narcissus.parser;const definitions=Narcissus.definitions;const tokens=definitions.tokens;eval(definitions.consts);function indent(n,s){var ss="",d=true;for(var i=0,j=s.length;i<j;i++){if(d)for(var k=0;k<n;k++)ss+=" ";ss+=s[i];d=s[i]==="\n"}return ss}function isBlock(n){return n&&n.type===BLOCK}function isNonEmptyBlock(n){return isBlock(n)&&n.children.length>0}function nodeStr(n){return'"'+n.value.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\n/g,"\\n").replace(/\r/g,"\\r")+'"'}function pp(n,d,inLetHead){var topScript=false;if(!n)return"";if(!(n instanceof Object))return n;if(!d){topScript=true;d=1}var p="";if(n.parenthesized)p+="(";switch(n.type){case FUNCTION:case GETTER:case SETTER:if(n.type===FUNCTION)p+="function";else if(n.type===GETTER)p+="get";else p+="set";p+=(n.name?" "+n.name:"")+"(";for(var i=0,j=n.params.length;i<j;i++)p+=(i>0?", ":"")+pp(n.params[i],d);p+=") "+pp(n.body,d);break;case SCRIPT:case BLOCK:var nc=n.children;if(topScript){for(var i=0,j=nc.length;i<j;i++){if(i>0)p+="\n";p+=pp(nc[i],d);var eoc=p[p.length-1];if(eoc!=";")p+=";"}break}p+="{";if(n.id!==undefined)p+=" /* "+n.id+" */";p+="\n";for(var i=0,j=nc.length;i<j;i++){if(i>0)p+="\n";p+=indent(4,pp(nc[i],d));var eoc=p[p.length-1];if(eoc!=";")p+=";"}p+="\n}";break;case LET_BLOCK:p+="let ("+pp(n.variables,d,true)+") ";if(n.expression)p+=pp(n.expression,d);else p+=pp(n.block,d);break;case IF:p+="if ("+pp(n.condition,d)+") ";var tp=n.thenPart,ep=n.elsePart;var b=isBlock(tp)||isBlock(ep);if(!b)p+="{\n";p+=(b?pp(tp,d):indent(4,pp(tp,d)))+"\n";if(ep){if(!b)p+="} else {\n";else p+=" else ";p+=(b?pp(ep,d):indent(4,pp(ep,d)))+"\n"}if(!b)p+="}";break;case SWITCH:p+="switch ("+pp(n.discriminant,d)+") {\n";for(var i=0,j=n.cases.length;i<j;i++){var ca=n.cases[i];if(ca.type===CASE)p+="  case "+pp(ca.caseLabel,d)+":\n";else p+="  default:\n";ps=pp(ca.statements,d);p+=ps.slice(2,ps.length-2)+"\n"}p+="}";break;case FOR:p+="for ("+pp(n.setup,d)+"; "+pp(n.condition,d)+"; "+pp(n.update,d)+") ";var pb=pp(n.body,d);if(!isBlock(n.body))p+="{\n"+indent(4,pb)+";\n}";else if(n.body)p+=pb;break;case WHILE:p+="while ("+pp(n.condition,d)+") ";var pb=pp(n.body,d);if(!isBlock(n.body))p+="{\n"+indent(4,pb)+";\n}";else p+=pb;break;case FOR_IN:var u=n.varDecl;p+=n.isEach?"for each (":"for (";p+=(u?pp(u,d):pp(n.iterator,d))+" in "+pp(n.object,d)+") ";var pb=pp(n.body,d);if(!isBlock(n.body))p+="{\n"+indent(4,pb)+";\n}";else if(n.body)p+=pb;break;case DO:p+="do "+pp(n.body,d);p+=" while ("+pp(n.condition,d)+");";break;case BREAK:p+="break"+(n.label?" "+n.label:"")+";";break;case CONTINUE:p+="continue"+(n.label?" "+n.label:"")+";";break;case TRY:p+="try ";p+=pp(n.tryBlock,d);for(var i=0,j=n.catchClauses.length;i<j;i++){var t=n.catchClauses[i];p+=" catch ("+pp(t.varName,d)+(t.guard?" if "+pp(t.guard,d):"")+") ";p+=pp(t.block,d)}if(n.finallyBlock){p+=" finally ";p+=pp(n.finallyBlock,d)}break;case THROW:p+="throw "+pp(n.exception,d);break;case RETURN:p+="return";if(n.value)p+=" "+pp(n.value,d);break;case YIELD:p+="yield";if(n.value.type)p+=" "+pp(n.value,d);break;case GENERATOR:p+=pp(n.expression,d)+" "+pp(n.tail,d);break;case WITH:p+="with ("+pp(n.object,d)+") ";p+=pp(n.body,d);break;case LET:case VAR:case CONST:var nc=n.children;if(!inLetHead){p+=tokens[n.type]+" "}for(var i=0,j=nc.length;i<j;i++){if(i>0)p+=", ";var u=nc[i];p+=pp(u.name,d);if(u.initializer)p+=" = "+pp(u.initializer,d)}break;case DEBUGGER:p+="debugger\n";break;case SEMICOLON:if(n.expression){p+=pp(n.expression,d)+";"}break;case LABEL:p+=n.label+":\n"+pp(n.statement,d);break;case COMMA:case LIST:var nc=n.children;for(var i=0,j=nc.length;i<j;i++){if(i>0)p+=", ";p+=pp(nc[i],d)}break;case ASSIGN:var nc=n.children;var t=n.assignOp;p+=pp(nc[0],d)+" "+(t?tokens[t]:"")+"="+" "+pp(nc[1],d);break;case HOOK:var nc=n.children;p+="("+pp(nc[0],d)+" ? "+pp(nc[1],d)+" : "+pp(nc[2],d);p+=")";break;case OR:case AND:var nc=n.children;p+="("+pp(nc[0],d)+" "+tokens[n.type]+" "+pp(nc[1],d);p+=")";break;case BITWISE_OR:case BITWISE_XOR:case BITWISE_AND:case EQ:case NE:case STRICT_EQ:case STRICT_NE:case LT:case LE:case GE:case GT:case IN:case INSTANCEOF:case LSH:case RSH:case URSH:case PLUS:case MINUS:case MUL:case DIV:case MOD:var nc=n.children;p+="("+pp(nc[0],d)+" "+tokens[n.type]+" "+pp(nc[1],d)+")";break;case DELETE:case VOID:case TYPEOF:p+=tokens[n.type]+" "+pp(n.children[0],d);break;case NOT:case BITWISE_NOT:p+=tokens[n.type]+pp(n.children[0],d);break;case UNARY_PLUS:p+="+"+pp(n.children[0],d);break;case UNARY_MINUS:p+="-"+pp(n.children[0],d);break;case INCREMENT:case DECREMENT:if(n.postfix){p+=pp(n.children[0],d)+tokens[n.type]}else{p+=tokens[n.type]+pp(n.children[0],d)}break;case DOT:var nc=n.children;p+=pp(nc[0],d)+"."+pp(nc[1],d);break;case INDEX:var nc=n.children;p+=pp(nc[0],d)+"["+pp(nc[1],d)+"]";break;case CALL:var nc=n.children;p+=pp(nc[0],d)+"("+pp(nc[1],d)+")";break;case NEW:case NEW_WITH_ARGS:var nc=n.children;p+="new "+pp(nc[0],d);if(nc[1])p+="("+pp(nc[1],d)+")";break;case ARRAY_INIT:p+="[";var nc=n.children;for(var i=0,j=nc.length;i<j;i++){if(nc[i])p+=pp(nc[i],d);p+=","}p+="]";break;case ARRAY_COMP:p+="["+pp(n.expression,d)+" ";p+=pp(n.tail,d);p+="]";break;case COMP_TAIL:var nc=n.children;for(var i=0,j=nc.length;i<j;i++){if(i>0)p+=" ";p+=pp(nc[i],d)}if(n.guard)p+=" if ("+pp(n.guard,d)+")";break;case OBJECT_INIT:var nc=n.children;if(nc[0]&&nc[0].type===PROPERTY_INIT)p+="{\n";else p+="{";for(var i=0,j=nc.length;i<j;i++){if(i>0){p+=",\n"}var t=nc[i];if(t.type===PROPERTY_INIT){var tc=t.children;var l;if(typeof tc[0].value==="string"&&!/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(tc[0].value)){l=nodeStr(tc[0])}else{l=pp(tc[0],d)}p+=indent(4,l)+": "+indent(4,pp(tc[1],d)).substring(4)}else{p+=indent(4,pp(t,d))}}p+="\n}";break;case NULL:p+="null";break;case THIS:p+="this";break;case TRUE:p+="true";break;case FALSE:p+="false";break;case IDENTIFIER:case NUMBER:case REGEXP:if(n.value.isOctal)p+="0"+n.value.toString(8);else p+=n.value;break;case STRING:p+=nodeStr(n);break;case GROUP:p+="("+pp(n.children[0],d)+")";break;default:throw"PANIC: unknown operation "+tokens[n.type]+" "+n.toSource()}if(n.parenthesized)p+=")";return p}return{pp:pp}}();"use strict";(function(exports){exports.version="0.10.8"})(typeof exports!=="undefined"?exports:Streamline.version=Streamline.version||{});"use strict";(function(){var sourceMap;if(typeof exports!=="undefined"){var req=srequire;try{sourceMap=req("source-map")}catch(ex){}}if(!sourceMap){sourceMap={SourceNode:function(lineno,column,source,content){this.children=content?[content]:[]}};sourceMap.SourceNode.prototype.add=function(elt){if(Array.isArray(elt))this.children=this.children.concat(elt);else this.children.push(elt);return this};sourceMap.SourceNode.prototype.prepend=function(elt){if(Array.isArray(elt))this.children=elt.concat(this.children.concat);else this.children.unshift(elt);return this};sourceMap.SourceNode.prototype.toString=function(){var str="";this.walk(function(chunk){str+=chunk});return str};sourceMap.SourceNode.prototype.walk=function(f){this.children.forEach(function(n){if(n instanceof sourceMap.SourceNode)n.walk(f);else f(n)});return this}}(function(module){function SourceNode(){sourceMap.SourceNode.apply(this,arguments)}SourceNode.prototype=Object.create(sourceMap.SourceNode.prototype,{constructor:{value:SourceNode,enumerable:false,writable:true,configurable:true},length:{get:function(){var len=0;this.walk(function(str){len+=str.length});return len}}});SourceNode.prototype.stripPrefix=function(offset){var _len;while(this.children.length>0&&offset>0&&(_len=this.children[0].length)<=offset){this.children.shift();offset-=_len}if(this.children.length==0||offset==0)return this;if(typeof this.children[0]=="string"){this.children[0]=this.children[0].substring(offset)}else{this.children[0].stripPrefix(offset)}return this};SourceNode.prototype.stripSuffix=function(offset){var _len,chlen;while((chlen=this.children.length)>0&&offset>0&&(_len=this.children[chlen-1].length)<=offset){this.children.pop();offset-=_len}if(chlen==0||offset==0)return this;if(typeof this.children[chlen-1]=="string"){this.children[chlen-1]=this.children[0].slice(0,-offset)}else{this.children[chlen-1].stripSuffix(offset)}return this};SourceNode.prototype.map=function(f){this.children=this.children.map(function(chunk){if(chunk instanceof sourceMap.SourceNode){return chunk.map(f)}else{return f(chunk)}});return this};SourceNode.prototype.lastChar=function(){for(var i=this.children.length;i--;){var ret;if(typeof this.children[i]=="string"){ret=this.children[i].slice(-1)}else{ret=this.children[i].lastChar()}if(ret)return ret}return""};module.exports=Object.create(sourceMap,{SourceNode:{value:SourceNode}})})(typeof exports!=="undefined"?module:Streamline.sourceMap=Streamline.sourceMap||{})})();if(typeof exports!=="undefined"){var Narcissus=srequire("streamline/deps/narcissus")}var sourceMap=srequire("streamline/lib/util/source-map");(function(exports){eval(Narcissus.definitions.consts);var tokens=Narcissus.definitions.tokens;exports.format=function(node,linesOpt){var result="";var ppOut=_pp(node);if(linesOpt=="sourcemap"){return ppOut.source}ppOut.source=ppOut.source.toString();if(linesOpt=="ignore")return ppOut.source;var lineMap=ppOut.lineMap;var lines=ppOut.source.split("\n");if(linesOpt=="preserve"){var outputLineNo=1,bol=true;for(var i=0;i<lines.length;i++){var sourceNodes=(lineMap[i]||[]).filter(function(n){return n._isSourceNode});if(sourceNodes.length>0){var sourceLineNo=sourceNodes[0].lineno;while(outputLineNo<sourceLineNo){result+="\n";outputLineNo+=1;bol=true}}result+=bol?lines[i]:lines[i].replace(/^\s+/," ");bol=false}result+="\n"}else if(linesOpt=="mark"){for(var i=0;i<lines.length;i++){var line=lines[i];var sourceNodes=(lineMap[i]||[]).filter(function(n){return n._isSourceNode});var linePrefix="            ";if(sourceNodes.length>0){var sourceLineNo=""+sourceNodes[0].lineno;linePrefix="/* ";for(var j=sourceLineNo.length;j<5;j++)linePrefix+=" ";linePrefix+=sourceLineNo+" */ "}result+=linePrefix+line+"\n"}}else throw new Error("bad --lines option: "+linesOpt);return result};function _pp(node){var curLineNo=0;var lineNodeMap={};var src=pp(node);return{source:src,lineMap:lineNodeMap};function countNewline(s){curLineNo+=1;return s}function indent(n,s){var dent=new Array(n+1).join(" ");s.map(function(str){return str.replace(/\n/g,"\n"+dent)});s.prepend(new sourceMap.SourceNode(null,null,null,dent));return s}function isBlock(n){return n&&n.type===BLOCK}function isNonEmptyBlock(n){return isBlock(n)&&n.children.length>0}var lines;function sourceNodeFromNode(n,content){var lineno,column,source=n.tokenizer&&n.tokenizer.filename;source=source||void 0;var start=n.start,end=n.end;var sourceString=n.tokenizer&&n.tokenizer.source;if(!source||!start||!end||!sourceString){return new sourceMap.SourceNode(void 0,void 0,void 0,content)}if(source&&!lines){lines=[];lines[-1]=0;var lineno=1;for(var index=sourceString.indexOf("\n");index>=0;index=sourceString.indexOf("\n",index+1)){lines[index]=lineno;lineno++}}while(start<end&&" \n\t;{}".indexOf(sourceString[start])>=0)start++;if(start<end){var fragment=sourceString.substring(start,end);var newline=sourceString.lastIndexOf("\n",start);lineno=lines[newline]+1;column=start-(newline+1)}else{source=void 0}return new sourceMap.SourceNode(lineno,column,source,content)}function nodeStr(n){return sourceNodeFromNode(n,'"'+n.value.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\n/g,"\\n").replace(/\r/g,"\\r")+'"')}function pp(n,d,inLetHead){var topScript=false;if(!n)return"";if(!(n instanceof Object))return""+n;if(!d){topScript=true;d=1}if(!lineNodeMap[curLineNo])lineNodeMap[curLineNo]=[];lineNodeMap[curLineNo].push(n);var p=sourceNodeFromNode(n);if(n.parenthesized)p.add("(");switch(n.type){case FUNCTION:case GETTER:case SETTER:if(n.type===FUNCTION)p.add("function");else if(n.type===GETTER)p.add("get");else p.add("set");if(n.name){p.add([" ",sourceNodeFromNode(n,n.name)])}p.add("(");for(var i=0,j=n.params.length;i<j;i++){p.add([i>0?", ":"",pp(n.params[i],d)])}p.add([") ",pp(n.body,d)]);break;case SCRIPT:case BLOCK:var nc=n.children;if(topScript){for(var i=0,j=nc.length;i<j;i++){if(i>0)p.add(countNewline("\n"));p.add(pp(nc[i],d));if(p.lastChar()!=";")p.add(";")}break}p.add("{");if(n.id!==undefined)p.add(" /* "+n.id+" */");p.add(countNewline("\n"));for(var i=0,j=nc.length;i<j;i++){if(i>0)p.add(countNewline("\n"));p.add(indent(2,pp(nc[i],d)));if(p.lastChar()!=";")p.add(";")}p.add(countNewline("\n}"));break;case LET_BLOCK:p.add(["let (",pp(n.variables,d,true),") "]);if(n.expression)p.add(pp(n.expression,d));else p.add(pp(n.block,d));break;case IF:p.add(["if (",pp(n.condition,d),") "]);var tp=n.thenPart,ep=n.elsePart;var b=isBlock(tp)||isBlock(ep);if(!b)p.add(countNewline("{\n"));p.add(b?pp(tp,d):indent(2,pp(tp,d)));if(ep&&";}".indexOf(p.lastChar())<0)p.add(";");p.add(countNewline("\n"));if(ep){if(!b)p.add(countNewline("} else {\n"));else p.add(" else ");p.add([b?pp(ep,d):indent(2,pp(ep,d)),countNewline("\n")])}if(!b)p.add("}");break;case SWITCH:p.add(["switch (",pp(n.discriminant,d),countNewline(") {\n")]);for(var i=0,j=n.cases.length;i<j;i++){var ca=n.cases[i];if(ca.type===CASE)p.add(["case ",pp(ca.caseLabel,d),countNewline(":\n")]);else p.add(countNewline("  default:\n"));p.add([pp(ca.statements,d).stripPrefix(2).stripSuffix(2),countNewline("\n")]);curLineNo-=2}p.add("}");break;case FOR:p.add(["for (",pp(n.setup,d),"; ",pp(n.condition,d),"; ",pp(n.update,d),") "]);var pb=pp(n.body,d);if(!isBlock(n.body)){p.add([countNewline("{\n"),indent(2,pb),countNewline(";\n}")])}else if(n.body)p.add(pb);break;case WHILE:p.add(["while (",pp(n.condition,d),") "]);var pb=pp(n.body,d);if(!isBlock(n.body)){p.add([countNewline("{\n"),indent(2,pb),countNewline(";\n}")])}else p.add(pb);break;case FOR_IN:var u=n.varDecl;p.add([n.isEach?"for each (":"for (",u?pp(u,d):pp(n.iterator,d)," in ",pp(n.object,d),") "]);var pb=pp(n.body,d);if(!isBlock(n.body)){p.add([countNewline("{\n"),indent(2,pb),countNewline(";\n}")])}else if(n.body)p.add(pb);break;case DO:p.add(["do ",pp(n.body,d)," while (",pp(n.condition,d),");"]);break;case BREAK:p.add(["break",n.label?" "+n.label:"",";"]);break;case CONTINUE:p.add(["continue",n.label?" "+n.label:"",";"]);break;case TRY:p.add(["try ",pp(n.tryBlock,d)]);for(var i=0,j=n.catchClauses.length;i<j;i++){var t=n.catchClauses[i];p.add([" catch (",pp(t.varName,d),t.guard?" if "+pp(t.guard,d):"",") ",pp(t.block,d)])}if(n.finallyBlock){p.add([" finally ",pp(n.finallyBlock,d)])}break;case THROW:p.add(["throw ",pp(n.exception,d)]);break;case RETURN:p.add("return");if(n.value){p.add([" ",pp(n.value,d)])}break;case YIELD:p.add("yield");if(n.value.type){p.add([" ",pp(n.value,d)])}break;case GENERATOR:p.add([pp(n.expression,d)," ",pp(n.tail,d)]);break;case WITH:p.add(["with (",pp(n.object,d),") ",pp(n.body,d)]);break;case LET:case VAR:case CONST:var nc=n.children;if(!inLetHead){p.add([tokens[n.type]," "])}for(var i=0,j=nc.length;i<j;i++){if(i>0)p.add(", ");var u=nc[i];p.add(pp(u.name,d));if(u.initializer){p.add([" = ",pp(u.initializer,d)])}}break;case DEBUGGER:p.add(countNewline("debugger\n"));break;case SEMICOLON:if(n.expression){p.add([pp(n.expression,d),";"])}break;case LABEL:p.add([n.label,countNewline(":\n"),pp(n.statement,d)]);break;case COMMA:case LIST:var nc=n.children;for(var i=0,j=nc.length;i<j;i++){if(i>0)p.add(", ");p.add(pp(nc[i],d))}break;case ASSIGN:var nc=n.children;var t=n.assignOp;p.add([pp(nc[0],d)," ",t?tokens[t]:"","="," ",pp(nc[1],d)]);break;case HOOK:var nc=n.children;p.add(["(",pp(nc[0],d)," ? ",pp(nc[1],d)," : ",pp(nc[2],d),")"]);break;case OR:case AND:var nc=n.children;p.add(["(",pp(nc[0],d)," ",tokens[n.type]," ",pp(nc[1],d),")"]);break;case BITWISE_OR:case BITWISE_XOR:case BITWISE_AND:case EQ:case NE:case STRICT_EQ:case STRICT_NE:case LT:case LE:case GE:case GT:case IN:case INSTANCEOF:case LSH:case RSH:case URSH:case PLUS:case MINUS:case MUL:case DIV:case MOD:var nc=n.children;p.add(["(",pp(nc[0],d)," ",tokens[n.type]," ",pp(nc[1],d),")"]);break;case DELETE:case VOID:case TYPEOF:p.add([tokens[n.type]," ",pp(n.children[0],d)]);break;case NOT:case BITWISE_NOT:p.add([tokens[n.type],pp(n.children[0],d)]);break;case UNARY_PLUS:p.add(["+",pp(n.children[0],d)]);break;case UNARY_MINUS:p.add(["-",pp(n.children[0],d)]);break;case INCREMENT:case DECREMENT:if(n.postfix){p.add([pp(n.children[0],d),tokens[n.type]])}else{p.add([tokens[n.type],pp(n.children[0],d)])}break;case DOT:var nc=n.children;p.add([pp(nc[0],d),".",pp(nc[1],d)]);break;case INDEX:var nc=n.children;p.add([pp(nc[0],d),"[",pp(nc[1],d),"]"]);break;case CALL:var nc=n.children;p.add([pp(nc[0],d),"(",pp(nc[1],d),")"]);break;case NEW:case NEW_WITH_ARGS:var nc=n.children;p.add("new ");p.add(pp(nc[0],d));if(nc[1]){p.add(["(",pp(nc[1],d),")"])}break;case ARRAY_INIT:p.add("[");var nc=n.children;for(var i=0,j=nc.length;i<j;i++){if(nc[i])p.add(pp(nc[i],d));p.add(",")}p.add("]");break;case ARRAY_COMP:p.add(["[",pp(n.expression,d)," ",pp(n.tail,d),"]"]);break;case COMP_TAIL:var nc=n.children;for(var i=0,j=nc.length;i<j;i++){if(i>0)p.add(" ");p.add(pp(nc[i],d))}if(n.guard){p.add([" if (",pp(n.guard,d),")"])}break;case OBJECT_INIT:var nc=n.children;if(nc[0]&&nc[0].type===PROPERTY_INIT)p.add(countNewline("{\n"));else p.add("{");for(var i=0,j=nc.length;i<j;i++){if(i>0){p.add(countNewline(",\n"))}var t=nc[i];if(t.type===PROPERTY_INIT){var tc=t.children;var l;if(typeof tc[0].value==="string"&&!/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(tc[0].value)){l=nodeStr(tc[0]);p.add(l)}else{l=pp(tc[0],d);p.add(indent(2,l))}p.add([": ",indent(2,pp(tc[1],d)).stripPrefix(2)])}else{p.add(indent(2,pp(t,d)))}}p.add(countNewline("\n}"));break;case NULL:p.add("null");break;case THIS:p.add("this");break;case TRUE:p.add("true");break;case FALSE:p.add("false");break;case IDENTIFIER:case NUMBER:case REGEXP:if(n.value.isOctal)p.add("0"+n.value.toString(8));else p.add(""+n.value);break;case STRING:p.add(nodeStr(n));break;case GROUP:p.add(["(",pp(n.children[0],d),")"]);break;default:throw"PANIC: unknown operation "+tokens[n.type]+" "+n.toSource()}if(n.parenthesized)p.add(")");return p}}})(typeof exports!=="undefined"?exports:window.Streamline=window.Streamline||{});if(typeof exports!=="undefined"){var Narcissus=srequire("../../deps/narcissus");var format=srequire("./format").format}else{var format=Streamline.format}(function(exports){exports.version=srequire("streamline/lib/version").version+" (callbacks)";var parse=Narcissus.parser.parse;var pp=Narcissus.decompiler.pp;var definitions=Narcissus.definitions;eval(definitions.consts.replace(/const /g,"var "));function _assert(cond){if(!cond)throw new Error("Assertion failed!")}function _tag(node){if(!node||!node.type)return"*NOT_A_NODE*";var t=definitions.tokens[node.type];return/^\W/.test(t)?definitions.opTypeNames[t]:t.toUpperCase()}function originalLine(options,line,col){if(!options.prevMap)return line;if(col==null)col=1e3;var r=options.prevMap.originalPositionFor({line:line,column:col}).line;return r==null?line:r}function originalCol(options,line,col){if(!options.prevMap)return col;return options.prevMap.originalPositionFor({line:line,column:col}).column||0}function _node(ref,type,children){return{_scope:ref&&ref._scope,_async:ref&&ref._async,type:type,children:children}}function _identifier(name,initializer){return{_scope:initializer&&initializer._scope,type:IDENTIFIER,name:name,value:name,initializer:initializer}}function _number(val){return{type:NUMBER,value:val}}function _string(val){return{type:STRING,value:val}}function _return(node){return{type:RETURN,_scope:node._scope,value:node}}function _semicolon(node){var stmt=_node(node,SEMICOLON);stmt.expression=node;return stmt}function _safeName(precious,name){if(name.substring(0,2)==="__")while(precious[name])name+="A";return name}function _flatten(node){if(node.type==BLOCK||node.type==SCRIPT){do{var found=false;var children=[];node.children.forEach(function(child){if(child._isFunctionReference||child.type==SEMICOLON&&(child.expression==null||child.expression._isFunction))return;node._async|=child._async;if(child.type==BLOCK||child.type==SCRIPT){children=children.concat(child.children);found=true}else children.push(child)});node.children=children}while(found)}return node}function _propagate(node,fn,doAll,clone){var result=clone?clone:node;for(var prop in node){if(node.hasOwnProperty(prop)&&prop.indexOf("Decls")<0&&(doAll||prop!="target")&&prop[0]!="_"){var child=node[prop];if(child!=null){if(Array.isArray(child)){if(clone)result[prop]=child=[].concat(child);var undef=false;for(var i=0;i<child.length;i++){if(doAll||child[i]&&child[i].type){child[i]=fn(child[i],node);undef|=typeof child[i]==="undefined"}}if(undef){result[prop]=child.filter(function(elt){return typeof elt!=="undefined"})}}else{if(doAll||child&&child.type)result[prop]=fn(child,node)}}}}return result}function _clone(node){var lastId=0;var clones={};function cloneOne(child){if(!child||!child.type)return child;var cloneId=child._cloneId;if(!cloneId)cloneId=child._cloneId=++lastId;var clone=clones[cloneId];if(clone)return clone;clones[cloneId]=clone={_cloneId:cloneId};return _propagate(child,cloneOne,true,clone)}return _propagate(node,cloneOne,true,{})}function Template(pass,str,isExpression,createScope){var _root=parse("function _t(){"+str+"}").children[0].body;if(_root.children.length==1)_root=_root.children[0];else _root=_node(_root.children[0],BLOCK,_root.children);this.generate=function(scopeNode,bindings){var scope=scopeNode._scope;_assert(scope!=null);bindings=bindings||{};var fn=null;function gen(node){if(node.type!=SCRIPT&&node.type!=BLOCK)node._pass=pass;if(node.type==FUNCTION&&createScope){_assert(fn==null);fn=node}if(!node||!node.type){if(node=="_")return scope.options.callback;if(typeof node==="string"){if(node[0]==="$")return bindings[node];return _safeName(scope.options.precious,node)}return node}node._scope=scope;var ident=node.type==SEMICOLON?node.expression:node;if(ident&&ident.type==IDENTIFIER&&ident.value[0]==="$"){var result=bindings[ident.value];if(ident.initializer){result.initializer=gen(ident.initializer);if(result.initializer._async)result._async=true}return result}else{node=_propagate(node,function(child){child=gen(child);if(child&&(child._async||child===scope.options.callback&&createScope)&&node.type!==FUNCTION)node._async=true;return child},true);node=_flatten(node);return node}}var result=gen(_clone(_root));if(fn){fn.parenthesized=true;var scope=new Scope(fn.body,fn._scope.options);scope.name=fn._scope.name;scope.line=fn._scope.line;scope.last=fn._scope.last;_assert(fn.params[0]===fn._scope.options.callback);scope.cbIndex=0;function _changeScope(node,parent){if(node.type==FUNCTION)return node;node._scope=scope;return _propagate(node,_changeScope)}_propagate(fn,_changeScope)}return isExpression?result.value:result};this.root=isExpression?_root.value:_root}function Scope(script,options){this.script=script;this.line=0;this.last=0;this.vars=[];this.functions=[];this.options=options;this.cbIndex=-1;this.isAsync=function(){return this.cbIndex>=0}}function _genId(node){return _safeName(node._scope.options.precious,"__"+ ++node._scope.last)}function _removeFast(node,options){function _isMarker(node){return node.type===IDENTIFIER&&node.value===options.callback}function _isStar(node){return node.type===CALL&&_isMarker(node.children[0])&&node.children[1].children.length===2}if(node.type===BITWISE_NOT&&_isMarker(node.children[0])){options.needsTransform=true;return node.children[0]}if(node.type===ARRAY_INIT&&node.children.length===1&&_isMarker(node.children[0])){options.needsTransform=true;node.children[0]._returnArray=true;return node.children[0]}if(node.type===RSH&&_isMarker(node.children[0])){options.needsTransform=true;return node.children[1]}if(node.type===LSH&&_isMarker(node.children[0])){options.needsTransform=true;return node.children[1]}if(node.type===NOT&&_isMarker(node.children[0])){options.needsTransform=true;node.type=FALSE;node.children=[];return node}if(_isStar(node)){node._isStar=true;options.needsTransform=true;node.children[0].value=_safeName(options.precious,"__rt")+".streamlinify";return node}return node}function _markSource(node,options){function _markOne(node){if(typeof node.value==="string")options.precious[node.value]=true;node.params&&node.params.forEach(function(param){options.precious[param]=true});node._isSourceNode=true;_propagate(node,function(child){child=_removeFast(child,options);_markOne(child);return child})}_markOne(node)}function _isScriptAsync(script,options){var async=false;function _doIt(node,parent){switch(node.type){case FUNCTION:return node;case IDENTIFIER:if(node.value==options.callback){async=true}else{_propagate(node,_doIt)}return node;case CALL:var fn=node.children[0],args=node.children[1],ident;if(fn.type===DOT&&(ident=fn.children[1]).value==="call"&&(fn=fn.children[0]).type===FUNCTION&&fn.params.length===0&&!fn.name&&args.children.length===1&&args.children[0].type===THIS){_propagate(fn.body,_doIt);return node}default:if(!async){_propagate(node,_doIt)}return node}}_propagate(script,_doIt);if(async&&options.verbose)console.log("WARNING: async calls found at top level in "+script.filename);return async}var _rootTemplate=new Template("root","(function main(_){ $script }).call(this, __trap);");function _canonTopLevelScript(script,options){script._scope=new Scope(script,options);if(_isScriptAsync(script,options))return _rootTemplate.generate(script,{$script:script});else return script}var _assignTemplate=new Template("canon","$lhs = $rhs;");function _guessName(node,parent){function _sanitize(name){name=name.replace(/[^A-Z0-9_$]/gi,"_o_");return name&&!/^\d/.test(name)?name:"_o_"+name}var id=_genId(node),n,nn;if(parent.type===IDENTIFIER)return _sanitize(parent.value)+id;if(parent.type===ASSIGN){n=parent.children[0];var s="";while(n.type===DOT&&(nn=n.children[1]).type===IDENTIFIER||n.type===INDEX&&(nn=n.children[1]).type===STRING){s=s?nn.value+"_"+s:nn.value;n=n.children[0]}if(n.type===IDENTIFIER)s=s?n.value+"_"+s:n.value;if(s)return _sanitize(s)+id}else if(parent.type==PROPERTY_INIT){n=parent.children[0];if(n.type===IDENTIFIER||n.type===STRING)return _sanitize(n.value)+id}return id}function _canonScopes(node,options){function _doIt(node,parent){var scope=parent._scope;node._scope=scope;var async=scope.isAsync();if(!async&&node.type!==FUNCTION){if(node.type===IDENTIFIER&&node.value===options.callback&&!parent._isStar){throw new Error(node.filename+": Function contains async calls but does not have _ parameter: "+node.name+" at line "+node.lineno)}return _propagate(node,_doIt)}if(node.type===TRY)node._async=true;switch(node.type){case FUNCTION:var result=node;var cbIndex=node.params.reduce(function(index,param,i){if(param!=options.callback)return index;if(index<0)return i;else throw new Error("duplicate _ parameter")},-1);if(cbIndex>=0){if(_isFatArrow(node))return node;options.needsTransform=true;if(!node.name)node.name=_guessName(node,parent)}if(async&&(parent.type===SCRIPT||parent.type===BLOCK)){scope.functions.push(node);result=undefined}var bodyScope=new Scope(node.body,options);node.body._scope=bodyScope;bodyScope.name=node.name;bodyScope.cbIndex=cbIndex;bodyScope.line=node.lineno;node.body=_propagate(node.body,_doIt);if(cbIndex>=0)bodyScope.functions.push(_string("BEGIN_BODY"));node.body.children=bodyScope.functions.concat(node.body.children);if(bodyScope.hasThis&&!node._inhibitThis){bodyScope.vars.push(_identifier(_safeName(options.precious,"__this"),_node(node,THIS)))}if(bodyScope.hasArguments&&!node._inhibitArguments){bodyScope.vars.push(_identifier(_safeName(options.precious,"__arguments"),_identifier("arguments")))}if(bodyScope.vars.length>0){node.body.children.splice(0,0,_node(node,VAR,bodyScope.vars))}return result;case VAR:var children=node.children.map(function(child){if(!scope.vars.some(function(elt){return elt.value==child.value})){scope.vars.push(_identifier(child.value))}if(!child.initializer)return null;child=_assignTemplate.generate(parent,{$lhs:_identifier(child.value),$rhs:child.initializer});if(parent.type===FOR)child=child.expression;return child}).filter(function(child){return child!=null});if(children.length==0){return}var type=parent.type==BLOCK||parent.type===SCRIPT?BLOCK:COMMA;var result=_node(parent,type,children);result=_propagate(result,_doIt);parent._async|=result._async;return result;case THIS:scope.hasThis=true;return _identifier(_safeName(options.precious,"__this"));case IDENTIFIER:if(node.value==="arguments"){scope.hasArguments=true;return _identifier(_safeName(options.precious,"__arguments"))}node=_propagate(node,_doIt);node._async|=node.value===options.callback;if(node._async&&!parent.isArgsList&&!(parent.type===PROPERTY_INIT&&node===parent.children[0])&&!(parent.type===DOT&&node===parent.children[1]))throw new Error("invalid usage of '_'");parent._async|=node._async;return node;case NEW_WITH_ARGS:var cbIndex=node.children[1].children.reduce(function(index,arg,i){if(arg.type!==IDENTIFIER||arg.value!==options.callback)return index;if(index<0)return i;else throw new Error("duplicate _ argument")},-1);if(cbIndex>=0){var constr=_node(node,CALL,[_identifier(_safeName(options.precious,"__construct")),_node(node,LIST,[node.children[0],_number(cbIndex)])]);node=_node(node,CALL,[constr,node.children[1]])}node.children[1].isArgsList=true;node=_propagate(node,_doIt);parent._async|=node._async;return node;case CALL:node.children[1].isArgsList=true;_convertCoffeeScriptCalls(node,options);_convertApply(node,options);node.children[1].isArgsList=true;default:node=_propagate(node,_doIt);_setBreaks(node);parent._async|=node._async;return node}}return _propagate(node,_doIt)}function _convertCoffeeScriptCalls(node,options){var fn=node.children[0];var args=node.children[1];if(fn.type===FUNCTION&&fn.params.length===0&&!fn.name&&args.children.length==0){fn._noFuture=true;fn.name="___closure";fn.params=[options.callback];args.children=[_identifier(options.callback)]}else if(fn.type===DOT){var ident=fn.children[1];fn=fn.children[0];if(fn.type===FUNCTION&&fn.params.length===0&&!fn.name&&ident.type===IDENTIFIER){if(ident.value==="call"&&args.children.length===1&&args.children[0].type===THIS){node.children[0]=fn;fn._noFuture=true;fn.name="___closure";fn.params=[options.callback];args.children=[_identifier(options.callback)];node._scope.hasThis=true;fn._inhibitThis=true}else if(ident.value==="apply"&&args.children.length===2&&args.children[0].type===THIS&&args.children[1].type===IDENTIFIER&&args.children[1].value==="arguments"){node.children[0]=fn;fn._noFuture=true;fn.name="___closure";fn.params=[options.callback];args.children=[_identifier(options.callback)];node._scope.hasThis=true;node._scope.hasArguments=true;fn._inhibitThis=true;fn._inhibitArguments=true}}}}function _isFatArrow(node){if(node.body.children.length!==1)return false;var n=node.body.children[0];if(n.type!==RETURN||!n.value)return false;n=n.value;if(n.type!==CALL)return false;var args=n.children[1].children;var target=n.children[0];if(args.length!==2||args[0].value!=="_this"||args[1].value!=="arguments")return false;if(target.type!==DOT||target.children[1].value!=="apply")return false;target=target.children[0];if(target.type!==DOT||target.children[1].type!==IDENTIFIER)return false;target=target.children[0];if(target.type!==DOT||target.children[1].value!=="prototype")return false;target=target.children[0];if(target.type!==IDENTIFIER)return false;node.params=[];return true}function _convertApply(node,options){var dot=node.children[0];var args=node.children[1];if(dot.type===DOT){var ident=dot.children[1];if(ident.type===IDENTIFIER&&ident.value==="apply"&&args.children.length===2&&args.children[0].type===THIS&&args.children[1].type===IDENTIFIER&&args.children[1].value==="arguments"){var f=dot.children[0];node.children[0]=_identifier("__apply");args.children=[_identifier(options.callback),f,_identifier("__this"),_identifier("__arguments"),_number(node._scope.cbIndex)];node._scope.hasThis=true;node._scope.hasArguments=true}}}var _switchVarTemplate=new Template("canon","{ var $v = true; }");var _switchIfTemplate=new Template("canon","if ($v) { $block; }");function _setBreaks(node){switch(node.type){case IF:node._breaks=node.thenPart._breaks&&node.elsePart&&node.elsePart._breaks;break;case SWITCH:for(var i=0;i<node.cases.length;i++){var stmts=node.cases[i].statements;if(node._async&&stmts.children.length>0&&!stmts._breaks){if(i==node.cases.length-2&&node.cases[i+1].type===DEFAULT&&node.cases[i+1].statements.children.length===1&&node.cases[i+1].statements.children[0].type===SEMICOLON&&node.cases[i+1].statements.children[0].expression==null){stmts.children.push(_node(node,BREAK));stmts._breaks=true}else if(i===node.cases.length-1){stmts.children.push(_node(node,BREAK));stmts._breaks=true}else{var v=_identifier(_genId(node));node.cases[i].statements=_switchVarTemplate.generate(node.cases[i],{$v:v});var ifStmt=_switchIfTemplate.generate(node.cases[i],{$v:v,$block:stmts});node.cases[i+1].statements.children.splice(0,0,ifStmt)}}}break;case TRY:node._breaks=node.tryBlock._breaks&&node.catchClauses[0]&&node.catchClauses[0].block._breaks;break;case BLOCK:case SCRIPT:node.children.forEach(function(child){node._breaks|=child._breaks});break;case RETURN:case THROW:case BREAK:node._breaks=true;break}}function _statementify(exp){if(!exp)return exp;var block=_node(exp,BLOCK,[]);function uncomma(node){if(node.type===COMMA){node.children.forEach(uncomma)}else{block.children.push(node.type==SEMICOLON?node:_semicolon(node))}}uncomma(exp);return block}function _blockify(node){if(!node||node.type==BLOCK)return node;if(node.type==COMMA)return _statementify(node);var block=_node(node,BLOCK,[node]);block._async=node._async;return block}var _flowsTemplates={WHILE:new Template("flows","{"+"\tfor (; $condition;) {"+"\t\t$body;"+"\t}"+"}"),DO:new Template("flows","{"+"\tvar $firstTime = true;"+"\tfor (; $firstTime || $condition;) {"+"\t\t$firstTime = false;"+"\t\t$body;"+"\t}"+"}"),FOR:new Template("flows","{"+"\t$setup;"+"\tfor (; $condition; $update) {"+"\t\t$body;"+"\t}"+"}"),FOR_IN:new Template("flows","{"+"\tvar $array = __forIn($object);"+"\tvar $i = 0;"+"\tfor (; $i < $array.length;) {"+"\t\t$iter = $array[$i++];"+"\t\t$body;"+"\t}"+"}"),TRY:new Template("flows",""+"try {"+"\ttry { $try; }"+"\tcatch ($ex) { $catch; }"+"}"+"finally { $finally; }"),AND:new Template("flows",""+"return (function $name(_){"+"\tvar $v = $op1;"+"\tif (!$v) {"+"\t\treturn $v;"+"\t}"+"\treturn $op2;"+"})(_)",true,true),OR:new Template("flows",""+"return (function $name(_){"+"\tvar $v = $op1;"+"\tif ($v) {"+"\t\treturn $v;"+"\t}"+"\treturn $op2;"+"})(_)",true,true),HOOK:new Template("flows",""+"return (function $name(_){"+"\tvar $v = $condition;"+"\tif ($v) {"+"\t\treturn $true;"+"\t}"+"\treturn $false;"+"})(_);",true,true),COMMA:new Template("flows",""+"return (function $name(_){"+"\t$body;"+"\treturn $result;"+"})(_);",true,true),CONDITION:new Template("flows",""+"return (function $name(_){"+"\treturn $condition;"+"})(_);",true,true),UPDATE:new Template("flows",""+"return (function $name(_){"+"\t$update;"+"})(_);",true,true)};function _canonFlows(node,options){function _doIt(node,parent,force){var scope=node._scope;function _doAsyncFor(node){if(node.condition&&node.condition._async&&node.condition.type!==CALL)node.condition=_flowsTemplates.CONDITION.generate(node,{$name:"__$"+node._scope.name,$condition:_doIt(node.condition,node,true)});if(node.update&&node.update._async)node.update=_flowsTemplates.UPDATE.generate(node,{$name:"__$"+node._scope.name,$update:_statementify(node.update)})}if(node.type==FOR&&node._pass==="flows")_doAsyncFor(node);if(!scope||!scope.isAsync()||!force&&node._pass==="flows")return _propagate(node,_doIt);switch(node.type){case IF:node.thenPart=_blockify(node.thenPart);node.elsePart=_blockify(node.elsePart);break;case SWITCH:if(node._async){var def=node.cases.filter(function(n){return n.type==DEFAULT})[0];if(!def){def=_node(node,DEFAULT);def.statements=_node(node,BLOCK,[]);node.cases.push(def)}if(!def._breaks){def.statements.children.push(_node(node,BREAK))}}break;case WHILE:node.body=_blockify(node.body);if(node._async){node=_flowsTemplates.WHILE.generate(node,{$condition:node.condition,$body:node.body})}break;case DO:node.body=_blockify(node.body);if(node._async){node=_flowsTemplates.DO.generate(node,{$firstTime:_identifier(_genId(node)),$condition:node.condition,$body:node.body})}break;case FOR:node.condition=node.condition||_number(1);node.body=_blockify(node.body);if(node._async){if(node.setup){node=_flowsTemplates.FOR.generate(node,{$setup:_statementify(node.setup),$condition:node.condition,$update:node.update,$body:node.body})}else{if(node._pass!=="flows"){node._pass="flows";_doAsyncFor(node)}}}break;case FOR_IN:node.body=_blockify(node.body);if(node._async){if(node.iterator.type!=IDENTIFIER){throw new Error("unsupported 'for ... in' syntax: type="+_tag(node.iterator))}node=_flowsTemplates.FOR_IN.generate(node,{$array:_identifier(_genId(node)),$i:_identifier(_genId(node)),$object:node.object,$iter:node.iterator,$body:node.body})}break;case TRY:if(node.tryBlock&&node.catchClauses[0]&&node.finallyBlock){node=_flowsTemplates.TRY.generate(node,{$try:node.tryBlock,$catch:node.catchClauses[0].block,$ex:node.catchClauses[0].varName,$finally:node.finallyBlock})}break;case AND:case OR:if(node._async){node=_flowsTemplates[_tag(node)].generate(node,{$name:"__$"+node._scope.name,$v:_identifier(_genId(node)),$op1:node.children[0],$op2:node.children[1]})}break;case HOOK:if(node._async){node=_flowsTemplates.HOOK.generate(node,{$name:"__$"+node._scope.name,$v:_identifier(_genId(node)),$condition:node.children[0],$true:node.children[1],$false:node.children[2]})}break;case COMMA:if(node._async){node=_flowsTemplates.COMMA.generate(node,{$name:"__$"+node._scope.name,$body:_node(node,BLOCK,node.children.slice(0,node.children.length-1).map(_semicolon)),$result:node.children[node.children.length-1]})}break}return _propagate(node,_doIt)}return _propagate(node,_doIt)}function _split(node,prop){var exp=node[prop];if(!exp||!exp._async)return node;var id=_genId(node);var v=_identifier(id,exp);node[prop]=_identifier(id);return _node(node,BLOCK,[_node(node,VAR,[v]),node])}function _disassemble(node,options){function _disassembleIt(node,parent,noResult){if(!node._async)return _propagate(node,_scanIt);node=_propagate(node,_disassembleIt);if(node.type===CALL){if(node.children[0].type===IDENTIFIER&&node.children[0].value.indexOf("__wrap")==0){node._isWrapper=true;return node}var args=node.children[1];if(args.children.some(function(arg){return arg.type===IDENTIFIER&&arg.value===options.callback||arg._isWrapper})){if(noResult){node._scope.disassembly.push(_statementify(node));return}else{if(parent.type==IDENTIFIER&&parent.value.indexOf("__")===0){node._skipDisassembly=true;return node}var id=_genId(node);var v=_identifier(id,node);node=_node(node,VAR,[v]);node._scope.disassembly.push(node);return _identifier(id)}}}return node}function _scanIt(node,parent){var scope=node._scope;if(!scope||!scope.isAsync()||!node._async)return _propagate(node,_scanIt);switch(node.type){case IF:node=_split(node,"condition");break;case SWITCH:node=_split(node,"discriminant");break;case FOR:break;case RETURN:node=_split(node,"value");break;case THROW:node=_split(node,"exception");break;case VAR:_assert(node.children.length===1);var ident=node.children[0];scope.disassembly=[];ident.initializer=_disassembleIt(ident.initializer,ident);node._async=ident.initializer._skipDisassembly;scope.disassembly.push(node);return _node(parent,BLOCK,scope.disassembly);case SEMICOLON:scope.disassembly=[];node.expression=_disassembleIt(node.expression,node,true);if(node.expression){node._async=false;scope.disassembly.push(node)}return _node(parent,BLOCK,scope.disassembly)}return _propagate(node,_scanIt)}return _propagate(node,_scanIt)}var _cbTemplates={FUNCTION:new Template("cb","{"+"\t$decls;"+"\tvar __frame = { name: $fname, line: $line };"+"\treturn __func(_, this, arguments, $fn, $index, __frame, function $name(){"+"\t\t$body;"+"\t\t_();"+"\t});"+"}"),FUNCTION_INTERNAL:new Template("cb","{ $decls; $body; _(); }"),RETURN:new Template("cb","return _(null, $value);"),RETURN_UNDEFINED:new Template("cb","return _(null);"),THROW:new Template("cb","return _($exception);"),IF:new Template("cb",""+"return (function $name(__then){"+"\tif ($condition) { $then; __then(); }"+"\telse { $else; __then(); }"+"})(function $name(){ $tail; });"),SWITCH:new Template("cb",""+"return (function $name(__break){"+"\t$statement;"+"})(function $name(){ $tail; });"),LABEL:new Template("cb",""+"$statement;"+"$tail;"),BREAK:new Template("cb","return __break();"),LABELLED_BREAK:new Template("cb","return $break();"),CONTINUE:new Template("cb",""+"while (__more) { __loop(); } __more = true;"+"return;"),LABELLED_CONTINUE:new Template("cb",""+"while ($more.get()) { $loop(); } $more.set(true);"+"return;"),LOOP1:new Template("cb",""+"if ($v) {"+"\t$body;"+"\twhile (__more) { __loop(); } __more = true;"+"}"+"else { __break(); }"),LOOP2:new Template("temp","var $v = $condition; $loop1;"),LOOP2_UPDATE:new Template("temp",""+"if ($beenHere) { $update; } else { $beenHere = true; }"+"var $v = $condition; $loop1;"),FOR:new Template("cb",""+"return (function ___(__break){"+"\tvar __more;"+"\tvar __loop = __cb(_, __frame, 0, 0, function $name(){"+"\t\t__more = false;"+"\t\t$loop2"+"\t});"+"\tdo { __loop(); } while (__more); __more = true;"+"})(function $name(){ $tail;});"),LABELLED_FOR:new Template("cb",""+"return (function ___(__break){"+"\tvar __more, $more = { get: function() { return __more; }, set: function(v) { __more = v; }};"+"\tvar __loop = __cb(_, __frame, 0, 0, function $name(){"+"\t\tvar $break = __break, $loop = __loop;"+"\t\t__more = false;"+"\t\t$loop2"+"\t});"+"\tdo { __loop(); } while (__more); __more = true;"+"})(function $name(){ $tail;});"),FOR_UPDATE:new Template("cb",""+"var $beenHere = false;"+"return (function ___(__break){"+"\tvar __more;"+"\tvar __loop = __cb(_, __frame, 0, 0, function $name(){"+"\t\t__more = false;"+"\t\t$loop2"+"\t});"+"\tdo { __loop(); } while (__more); __more = true;"+"})(function $name(){ $tail; });"),LABELLED_FOR_UPDATE:new Template("cb",""+"var $beenHere = false;"+"return (function ___(__break){"+"\tvar __more, $more = { get: function() { return __more; }, set: function(v) { __more = v; }};"+"\tvar __loop = __cb(_, __frame, 0, 0, function $name(){"+"\t\tvar $break = __break, $loop = __loop;"+"\t\t__more = false;"+"\t\t$loop2"+"\t});"+"\tdo { __loop(); } while (__more); __more = true;"+"})(function $name(){ $tail; });"),CATCH:new Template("cb",""+"return (function ___(__then){"+"\t(function ___(_){"+"\t\t__tryCatch(_, function $name(){ $try; __then(); });"+"\t})(function ___($ex, __result){"+"\t\t__catch(function $name(){"+"\t\t\tif ($ex) { $catch; __then(); }"+"\t\t\telse { _(null, __result); }"+"\t\t});"+"\t});"+"})(function ___(){"+"\t__tryCatch(_, function $name(){ $tail; });"+"});"),FINALLY:new Template("cb",""+"return (function ___(__then){"+"\t(function ___(_){"+"\t\t__tryCatch(_, function $name(){ $try; _(null, null, true); });"+"\t})(function ___(__e, __r, __cont){"+"\t\t(function ___(__then){"+"\t\t\t__tryCatch(_, function $name(){ $finally; __then(); });"+"\t\t})(function ___(){"+"\t\t\t__tryCatch(_, function ___(){"+"\t\t\t\tif (__cont) __then(); else _(__e, __r);"+"\t\t\t});"+"\t\t})"+"\t});"+"})(function ___(){"+"\t__tryCatch(_, function $name(){ $tail; });"+"});"),CALL_VOID:new Template("cb","return __cb(_, __frame, $offset, $col, function $name(){ $tail; }, true, $returnArray)",true),CALL_TMP:new Template("cb","return __cb(_, __frame, $offset, $col, function ___(__0, $result){ $tail }, true, $returnArray)",true),CALL_RESULT:new Template("cb",""+"return __cb(_, __frame, $offset, $col, function $name(__0, $v){"+"\tvar $result = $v;"+"\t$tail"+"}, true, $returnArray)",true)};function _callbackify(node,options){var label;function _scanIt(node,parent){node=_flatten(node);if(!node._scope||!node._scope.isAsync()||node._pass==="cb")return _propagate(node,_scanIt);switch(node.type){case SCRIPT:if(parent._pass!=="cb"){var decls;for(var cut=0;cut<node.children.length;cut++){var child=node.children[cut];if(child.type===STRING&&child.value==="BEGIN_BODY"){decls=node.children.splice(0,cut);node.children.splice(0,1);break}}var template=parent._noFuture||parent._pass==="flows"?_cbTemplates.FUNCTION_INTERNAL:_cbTemplates.FUNCTION;node=template.generate(node,{$fn:parent.name,$name:"__$"+node._scope.name,$fname:_string(parent.name),$line:_number(originalLine(options,node._scope.line)),$index:_number(node._scope.cbIndex),$decls:_node(node,BLOCK,decls||[]),$body:node})}node.type=SCRIPT;case BLOCK:for(var i=0;i<node.children.length;i++){node.children[i]=_restructureIt(node,i)}return node}return _propagate(node,_scanIt)}function _extractTail(parent,i){return _node(parent,BLOCK,parent.children.splice(i+1,parent.children.length-i-1))}function _restructureIt(parent,i){var node=parent.children[i];if(node._pass==="cb")return _propagate(node,_scanIt);switch(node.type){case RETURN:_extractTail(parent,i);var template=node.value?_cbTemplates.RETURN:_cbTemplates.RETURN_UNDEFINED;node=template.generate(node,{$value:node.value});break;case THROW:_extractTail(parent,i);node=_cbTemplates.THROW.generate(node,{$exception:node.exception});break;case BREAK:if(node.target&&!node.target._async){break}_extractTail(parent,i);if(node.label){node=_cbTemplates.LABELLED_BREAK.generate(node,{$break:_safeName(options.precious,"__break__"+node.label)})}else{node=_cbTemplates.BREAK.generate(node,{})}break;case CONTINUE:if(node.target&&!node.target._async){break}_extractTail(parent,i);if(node.label){node=_cbTemplates.LABELLED_CONTINUE.generate(node,{$loop:_safeName(options.precious,"__loop__"+node.label),$more:_safeName(options.precious,"__more__"+node.label)})}else{node=_cbTemplates.CONTINUE.generate(node,{})}break;case TRY:var tail=_extractTail(parent,i);if(node.catchClauses[0]){node=_cbTemplates.CATCH.generate(node,{$name:"__$"+node._scope.name,$try:node.tryBlock,$catch:node.catchClauses[0].block,$ex:node.catchClauses[0].varName,$tail:tail})}else{node=_cbTemplates.FINALLY.generate(node,{$name:"__$"+node._scope.name,$try:node.tryBlock,$finally:node.finallyBlock,$tail:tail})}break;default:if(node._async){var tail=_extractTail(parent,i);switch(node.type){case IF:node=_cbTemplates.IF.generate(node,{$name:"__$"+node._scope.name,$condition:node.condition,$then:node.thenPart,$else:node.elsePart||_node(node,BLOCK,[]),$tail:tail});break;case SWITCH:node._pass="cb";node=_cbTemplates.SWITCH.generate(node,{$name:"__$"+node._scope.name,$statement:node,$tail:tail});break;case LABEL:var l=label;label=node.label;node=_cbTemplates.LABEL.generate(node,{$name:"__$"+node._scope.name,$statement:node.statement,$tail:tail});node=_scanIt(node,parent);label=l;return node;case FOR:var v=_identifier(_genId(node));var loop1=_cbTemplates.LOOP1.generate(node,{$v:v,$body:node.body});var update=node.update;var beenHere=update&&_identifier(_genId(node));var loop2=(update?_cbTemplates.LOOP2_UPDATE:_cbTemplates.LOOP2).generate(node,{$v:v,$condition:node.condition,$beenHere:beenHere,$update:_statementify(update),$loop1:loop1});node=(update?label?_cbTemplates.LABELLED_FOR_UPDATE:_cbTemplates.FOR_UPDATE:label?_cbTemplates.LABELLED_FOR:_cbTemplates.FOR).generate(node,{$name:"__$"+node._scope.name,$loop:_identifier(_safeName(options.precious,"__loop__"+label)),$break:_identifier(_safeName(options.precious,"__break__"+label)),$more:_identifier(_safeName(options.precious,"__more__"+label)),$beenHere:beenHere,$loop2:loop2,$tail:tail});break;case VAR:_assert(node.children.length==1);var ident=node.children[0];_assert(ident.type===IDENTIFIER);var call=ident.initializer;delete ident.initializer;_assert(call&&call.type===CALL);return _restructureCall(call,tail,ident.value);case SEMICOLON:var call=node.expression;_assert(call.type===CALL);return _restructureCall(call,tail);default:throw new Error("internal error: bad node type: "+_tag(node)+": "+pp(node))}}}return _scanIt(node,parent);function _restructureCall(node,tail,result){var args=node.children[1];function _cbIndex(args){return args.children.reduce(function(index,arg,i){if(arg.type==IDENTIFIER&&arg.value===options.callback||arg._isWrapper)return i;else return index},-1)}var i=_cbIndex(args);_assert(i>=0);var returnArray=args.children[i]._returnArray;if(args.children[i]._isWrapper){args=args.children[i].children[1];i=_cbIndex(args)}var identifier=node.children[0];while(identifier.type==DOT){identifier=identifier.children[1]}var bol=options.source.lastIndexOf("\n",identifier.start)+1;var col=identifier.start-bol;args.children[i]=(result?result.indexOf("__")===0?_cbTemplates.CALL_TMP:_cbTemplates.CALL_RESULT:_cbTemplates.CALL_VOID).generate(node,{$v:_genId(node),$frameName:_string(node._scope.name),$offset:_number(originalLine(options,identifier.lineno,col)-originalLine(options,node._scope.line)),$col:_number(originalCol(options,identifier.lineno,col)),$name:"__$"+node._scope.name,$returnArray:returnArray,$result:result,$tail:tail});node=_propagate(node,_scanIt);var stmt=_node(node,RETURN,[]);stmt.value=node;stmt._pass="cb";return stmt}}return _propagate(node,_scanIt)}function _checkUsed(val,used){if(typeof val==="string"&&val.substring(0,2)==="__")used[val]=true}var _optims={function__0$fn:new Template("simplify","return function ___(__0) { $fn(); }",true).root,function$return:new Template("simplify","return function $fn1() { return $fn2(); }",true).root,function__0$arg1return_null$arg2:new Template("simplify","return function ___(__0, $arg1) { return _(null, $arg2); }",true).root,__cb__:new Template("simplify","return __cb(_, $frameVar, $line, $col, _)",true).root,__cbt__:new Template("simplify","return __cb(_, $frameVar, $line, $col, _, true)",true).root,function$fn:new Template("simplify","return function $fn1() { $fn2(); }",true).root,closure:new Template("simplify","return (function ___closure(_){ $body; })(__cb(_,$frameVar,$line,$col,function $fnName(){_();},true))",true).root,safeParam:new Template("simplify","return (function $fnName($param){ $body; })(function $fnName(){_();})",true).root};function _simplify(node,options,used){if(node._simplified)return node;node._simplified=true;_propagate(node,function(child){return _simplify(child,options,used)});_checkUsed(node.value,used);function _match(prop,v1,v2,result){var ignored=["parenthesized","lineno","start","end","tokenizer","hasReturnWithValue"];if(prop.indexOf("_")==0||ignored.indexOf(prop)>=0)return true;if(v1==v2)return true;if(v1==null||v2==null){if(prop=="children"&&v1&&v1.length===0)return true;return false}if(Array.isArray(v1)){if(v1.length!=v2.length)return false;for(var i=0;i<v1.length;i++){if(!_match(prop,v1[i],v2[i],result))return false}return true}if(v1.type===IDENTIFIER&&v1.value[0]==="$"&&v2.type===NUMBER){result[v1.value]=v2.value;return true}if(typeof v1=="string"&&v1[0]=="$"&&typeof v2=="string"){result[v1]=v2;return true}if(v1.type){var exp;if(v1.type==SCRIPT&&v1.children[0]&&(exp=v1.children[0].expression)&&typeof exp.value=="string"&&exp.value[0]=="$"){result[exp.value]=v2;return true}if(v1.type!=v2.type)return false;if(v1.type==IDENTIFIER&&v1.value=="$"){result[v1.value]=v2.value;return true}for(var prop in v1){if(v1.hasOwnProperty(prop)&&prop.indexOf("Decls")<0&&prop!="target"){if(!_match(prop,v1[prop],v2[prop],result))return false}}return true}return false}var result={};if(_match("",_optims.function__0$fn,node,result))return _identifier(result.$fn);if(_match("",_optims.function$return,node,result)&&(result.$fn1==="___"||result.$fn1.indexOf("__$")===0)&&result.$fn2==="__break")return _identifier(result.$fn2);if(_match("",_optims.function__0$arg1return_null$arg2,node,result)&&result.$arg1==result.$arg2)return _identifier("_");if(options.optimize&&_match("",_optims.__cb__,node,result))return _identifier("_");if(options.optimize&&_match("",_optims.__cbt__,node,result))return _identifier("_");if(_match("",_optims.function$fn,node,result)&&(result.$fn1==="___"||result.$fn1.indexOf("__$")===0)&&(result.$fn2==="__then"||result.$fn2==="__loop"))return _identifier(result.$fn2);if(_match("",_optims.closure,node,result))node.children[1]=_identifier("_");if(_match("",_optims.safeParam,node,result)&&(result.$param==="__then"||result.$param==="__break"))node.children[1]=_identifier("_");_flatten(node);return node}function _extend(obj,other){for(var i in other){obj[i]=other[i]}return obj}function _cl(obj){return _extend({},obj)}exports.transform=function(source,options){try{source=source.replace(/\r\n/g,"\n");options=options?_extend({},options):{};var sourceOptions=/streamline\.options\s*=\s*(\{.*\})/.exec(source);if(sourceOptions){_extend(options,JSON.parse(sourceOptions[1]))}options.source=source;options.callback=options.callback||"_";options.lines=options.lines||"preserve";options.precious={};var node=parse(source+"\n",options.sourceName);var strict=node.children[0]&&node.children[0].expression&&node.children[0].expression.value=="use strict";strict&&node.children.splice(0,1);_markSource(node,options);node=_canonTopLevelScript(node,options);node=_canonScopes(node,options);if(!options.needsTransform)return source;node=_canonFlows(node,options);node=_disassemble(node,options);node=_callbackify(node,options);var used={};node=_simplify(node,options,used);var result=format(node,options.lines);if(!options.noHelpers){var s=exports.helpersSource(options,used,strict);if(options.lines=="sourcemap"){result.prepend(s)}else{result=s+result}}return result}catch(err){var message="error streamlining "+(options.sourceName||"source")+": "+err.message;if(err.source&&err.cursor){var line=1;for(var i=0;i<err.cursor;i++){if(err.source[i]==="\n")line+=1}message+=" on line "+line}else if(err.stack){message+="\nSTACK:\n"+err.stack}throw new Error(message)}};exports.transform.version=exports.version;function _trim(fn){return fn.toString().replace(/\s+/g," ")}function include(mod,modules){var source=modules+"['"+mod+"']=(mod={exports:{}});";source+="(function(module, exports){";var req=srequire;source+=req("fs").readFileSync(__dirname+"/../"+mod+".js","utf8").replace(/(\/\/[^"\n]*\n|\/\*[\s\S]*?\*\/|\n)[ \t]*/g,"");source+="})(mod, mod.exports);";return source}function requireRuntime(options){if(!options.standalone)return"srequire('streamline/lib/callbacks/runtime').runtime(__filename, "+!!options.oldStyleFutures+")";var modules=_safeName(options.precious,"__modules");var s="(function(){var "+modules+"={},mod;";s+="function srequire(p){var m="+modules+"[p.substring(15)]; return m && m.exports};";s+=include("globals",modules);s+=include("util/future",modules);s+=include("callbacks/runtime",modules);if(["funnel","forEach_","map_","filter_","every_","some_","reduce_","reduceRight_","sort_","apply_"].some(function(name){return options.precious[name]}))s+=include("callbacks/builtins",modules);s+="return "+modules+"['callbacks/runtime'].exports.runtime('"+options.sourceName+"', "+!!options.oldStyleFutures+");";s+="})()";return s}exports.helpersSource=function(options,used,strict){var srcName=""+options.sourceName;var i=srcName.indexOf("node_modules/");if(i==-1&&typeof process==="object"&&typeof process.cwd==="function")i=process.cwd().length;srcName=i>=0?srcName.substring(i+13):srcName;var sep=options.lines=="preserve"?" ":"\n";strict=strict?'"use strict";'+sep:"";var s=sep+strict;var keys=["__g","__func","__cb","__future","__propagate","__trap","__catch","__tryCatch","__forIn","__apply","__construct","__setEF"];var __rt=_safeName(options.precious,"__rt");s+="var "+__rt+"="+requireRuntime(options);keys.forEach(function(key){var k=_safeName(options.precious,key);if(used[k])s+=","+k+"="+__rt+"."+key});s+=";"+sep;return s}})(typeof exports!=="undefined"?exports:window.Streamline=window.Streamline||{});(function(exports){exports.future=function(fn,args,i){var err,result,done,q=[],self=this;args=Array.prototype.slice.call(args);args[i]=function(e,r){err=e,result=r,done=true;q&&q.forEach(function(f){f.call(self,e,r)});q=null};fn.apply(this,args);return function F(cb){if(typeof cb!=="function"){if(cb!==false&&!srequire("streamline/lib/globals").oldStyleFutures)throw new Error("no callback given (argument #0). If you're a Streamline user, more info: https://github.com/Sage/streamlinejs/blob/master/FAQ.md#no-callback-given-error");return F}if(done)cb.call(self,err,result);else q.push(cb)}};exports.streamlinify=function(fn,idx){return function(){if(!arguments[idx])return exports.future.call(this,fn,arguments,idx);else return fn.apply(this,arguments)}}})(typeof exports!=="undefined"?exports:Streamline.future=Streamline.future||{});(function(exports){var __g=srequire("streamline/lib/globals");__g.runtime="callbacks";var __fut=srequire("streamline/lib/util/future");__g.context=__g.context||{};__g.depth=__g.depth||0;__g.trampoline=function(){var q=[];return{queue:function(fn){q.push(fn)},flush:function(){__g.depth++;try{var fn;while(fn=q.shift())fn()}finally{__g.depth--}}}}();exports.runtime=function(filename,oldStyleFutures){__g.oldStyleFutures=oldStyleFutures;function __func(_,__this,__arguments,fn,index,frame,body){if(typeof _!=="function"){if(_!==false&&!__g.oldStyleFutures)throw new Error("no callback given (argument #"+index+"). If you're a Streamline user, more info: https://github.com/Sage/streamlinejs/blob/master/FAQ.md#no-callback-given-error");return __fut.future.call(__this,fn,__arguments,index)}frame.file=filename;frame.prev=__g.frame;__g.frame=frame;__g.depth===0&&__g.emitter&&__g.emitter.emit("resume");__g.depth++;try{frame.active=true;body()}catch(e){__propagate(_,e)}finally{frame.active=false;__g.frame=frame.prev;if(--__g.depth===0&&__g.trampoline)__g.trampoline.flush();__g.depth===0&&__g.emitter&&__g.emitter.emit("yield")}}return{__g:__g,__func:__func,__cb:__cb,__future:__fut.future,__propagate:__propagate,__trap:__trap,__tryCatch:__tryCatch,__catch:__catch,__forIn:__forIn,__apply:__apply,__construct:__construct,__setEF:__setEF,streamlinify:__fut.streamlinify}};function __cb(_,frame,offset,col,fn,trampo,returnArray){frame.offset=offset;frame.col=col;var ctx=__g.context;return function ___(err,result){if(returnArray)result=Array.prototype.slice.call(arguments,1);returnArray=false;var oldFrame=__g.frame;__g.frame=frame;__g.context=ctx;__g.depth===0&&__g.emitter&&__g.emitter.emit("resume");__g.depth++;try{if(trampo&&frame.active&&__g.trampoline){__g.trampoline.queue(function(){return ___(err,result)})}else{___.dispatched=true;if(err){__setEF(err,frame);return _(err)}frame.active=true;return fn(null,result)}}catch(ex){return __propagate(_,ex)}finally{frame.active=false;__g.frame=oldFrame;if(--__g.depth===0&&__g.trampoline)__g.trampoline.flush();__g.depth===0&&__g.emitter&&__g.emitter.emit("yield")}}}function __propagate(_,err){try{_(err)}catch(ex){__trap(ex)}}function __trap(err){if(err){if(__g.context&&__g.context.errorHandler)__g.context.errorHandler(err);else process.nextTick(function(){throw err})}}function __tryCatch(_,fn){try{fn()}catch(e){try{_(e)}catch(ex){__trap(ex)}}}function __catch(fn){var frame=__g.frame,context=__g.context;__g.trampoline.queue(function(){var oldFrame=__g.frame,oldContext=__g.context;__g.frame=frame;__g.context=context;try{fn()}finally{__g.frame=oldFrame;__g.context=oldContext}})}function __forIn(object){var array=[];for(var obj in object){array.push(obj)}return array}function __apply(cb,fn,thisObj,args,index){if(cb==null)return __fut.future(__apply,arguments,0);args=Array.prototype.slice.call(args,0);args[index!=null?index:args.length]=cb;return fn.apply(thisObj,args)}function __construct(constructor,i){var key="__async"+i,f;return constructor[key]||(constructor[key]=function(){var args=arguments;function F(){var self=this;var cb=args[i];args[i]=function(e,r){cb(e,self)};return constructor.apply(self,args)}F.prototype=constructor.prototype;return new F})}function __setEF(e,f){function formatStack(e,raw){var ff=typeof navigator==="object"&&navigator.userAgent.toLowerCase().indexOf("firefox")>-1;if(ff)raw="Error: "+e.message+"\n"+raw;var s=raw,f,skip;if(s){var lines=s.split("\n");s=lines[0]+"\n    <<< async stack >>>\n"+lines.slice(1).map(function(l){var ffOffset=typeof navigator==="object"&&typeof srequire==="function"&&srequire.async?11:0;var m=/([^@]*)\@(.*?)\:(\d+)(?:\:(\d+))?$/.exec(l);l=m?"    at "+m[1]+" ("+m[2]+":"+(parseInt(m[3])-ffOffset)+":"+(m[4]||"0")+")":l;var i=l.indexOf("__$");if(i>=0&&!skip){skip=true;return l.substring(0,i)+l.substring(i+3)}return skip?"":l}).filter(function(l){return l}).join("\n");for(var f=e.__frame;f;f=f.prev){if(f.offset>=0)s+="\n    at "+f.name+" ("+f.file+":"+(f.line+f.offset)+":"+(f.col+1)+")"}}var nl=raw.indexOf("\n");s+="\n    <<< raw stack >>>"+(nl>=0?raw.substring(nl):raw);return s}e.__frame=e.__frame||f;if(exports.stackTraceEnabled&&e.__lookupGetter__&&e.__lookupGetter__("rawStack")==null){var getter=e.__lookupGetter__("stack");if(!getter){var raw=e.stack||"raw stack unavailable";getter=function(){return raw}}e.__defineGetter__("rawStack",getter);e.__defineGetter__("stack",function(){return formatStack(e,getter())})}}exports.stackTraceEnabled=true})(typeof exports!=="undefined"?exports:Streamline.runtime=Streamline.runtime||{});srequire&&srequire("streamline/lib/callbacks/builtins");var __rt=srequire("streamline/lib/callbacks/runtime").runtime(__filename,false),__func=__rt.__func,__cb=__rt.__cb;(function(exports){"use strict";var VERSION=3;var future=function(fn,args,i){var err,result,done,q=[],self=this;args=Array.prototype.slice.call(args);args[i]=function(e,r){err=e,result=r,done=true;q&&q.forEach(function(f){f.call(self,e,r)});q=null};fn.apply(this,args);return function F(cb){if(!cb){return F}if(done){cb.call(self,err,result)}else{q.push(cb)}}};exports.funnel=function(max){max=max==null?-1:max;if(max===0){max=funnel.defaultSize}if(typeof max!=="number"){throw new Error("bad max number: "+max)}var queue=[],active=0,closed=false;var funCb=function(callback,fn){if(callback==null){return future(funCb,arguments,0)}if(max<0||max==Infinity){return fn(callback)}queue.push({fn:fn,cb:callback});function _doOne(){var current=queue.splice(0,1)[0];if(!current.cb){return current.fn()}active++;current.fn(function(err,result){active--;if(!closed){current.cb(err,result);while(active<max&&queue.length>0){_doOne()}}})}while(active<max&&queue.length>0){_doOne()}};var fun=__rt.streamlinify(funCb,0);fun.close=function(){queue=[],closed=true};return fun};var funnel=exports.funnel;funnel.defaultSize=4;function _parallel(options){if(typeof options==="number"){return options}if(typeof options.parallel==="number"){return options.parallel}return options.parallel?-1:1}if(Array.prototype.forEach_&&Array.prototype.forEach_.version_>=VERSION){return}try{Object.defineProperty({},"x",{})}catch(e){return}var has=Object.prototype.hasOwnProperty;delete Array.prototype.forEach_;Object.defineProperty(Array.prototype,"forEach_",{configurable:true,writable:true,enumerable:false,value:function value__1(_,options,fn,thisObj){var par,len,i,__this=this;var __frame={name:"value__1",line:124};return __func(_,this,arguments,value__1,0,__frame,function __$value__1(){if(typeof options==="function"){thisObj=fn,fn=options,options=1}par=_parallel(options);thisObj=thisObj!==undefined?thisObj:__this;len=__this.length;return function __$value__1(__then){if(par===1||len<=1){i=0;var __2=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__1(){__more=false;if(__2){i++}else{__2=true}var __1=i<len;if(__1){return function __$value__1(__then){if(has.call(__this,i)){return fn.call(thisObj,__cb(_,__frame,7,31,__then,true),__this[i],i)}else{__then()}}(function __$value__1(){while(__more){__loop()}__more=true})}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}else{return __this.map_(__cb(_,__frame,10,9,__then,true),par,fn,thisObj)}}(function __$value__1(){return _(null,__this)})})}});Array.prototype.forEach_.version_=VERSION;delete Array.prototype.map_;Object.defineProperty(Array.prototype,"map_",{configurable:true,writable:true,enumerable:false,value:function value__2(_,options,fn,thisObj){var par,len,result,i,fun,__this=this;var __frame={name:"value__2",line:147};return __func(_,this,arguments,value__2,0,__frame,function __$value__2(){if(typeof options==="function"){thisObj=fn,fn=options,options=1}par=_parallel(options);thisObj=thisObj!==undefined?thisObj:__this;len=__this.length;return function __$value__2(__then){if(par===1||len<=1){result=new Array(len);i=0;var __4=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__2(){__more=false;if(__4){i++}else{__4=true}var __3=i<len;if(__3){return function __$value__2(__then){if(has.call(__this,i)){return fn.call(thisObj,__cb(_,__frame,9,43,function ___(__0,__1){result[i]=__1;__then()},true),__this[i],i)}else{__then()}}(function __$value__2(){while(__more){__loop()}__more=true})}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}else{fun=funnel(par);result=__this.map(function(elt,i){return fun(false,function __1(_){var __frame={name:"__1",line:161};return __func(_,this,arguments,__1,0,__frame,function __$__1(){return fn.call(thisObj,__cb(_,__frame,1,16,_,true),elt,i)})})});i=0;var __7=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__2(){__more=false;if(__7){i++}else{__7=true}var __6=i<len;if(__6){return function __$value__2(__then){if(has.call(__this,i)){return result[i](__cb(_,__frame,19,40,function ___(__0,__2){result[i]=__2;__then()},true))}else{__then()}}(function __$value__2(){while(__more){__loop()}__more=true})}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}}(function __$value__2(){return _(null,result)})})}});delete Array.prototype.filter_;Object.defineProperty(Array.prototype,"filter_",{configurable:true,writable:true,enumerable:false,value:function value__3(_,options,fn,thisObj){var par,result,len,i,elt,__this=this;var __frame={name:"value__3",line:179};return __func(_,this,arguments,value__3,0,__frame,function __$value__3(){if(typeof options==="function"){thisObj=fn,fn=options,options=1}par=_parallel(options);thisObj=thisObj!==undefined?thisObj:__this;result=[];len=__this.length;return function __$value__3(__then){if(par===1||len<=1){i=0;var __4=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__3(){__more=false;if(__4){i++}else{__4=true}var __3=i<len;if(__3){return function __$value__3(__then){if(has.call(__this,i)){elt=__this[i];return fn.call(thisObj,__cb(_,__frame,10,13,function ___(__0,__2){return function __$value__3(__then){if(__2){result.push(elt);__then()}else{__then()}}(__then)},true),elt)}else{__then()}}(function __$value__3(){while(__more){__loop()}__more=true})}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}else{return __this.map_(__cb(_,__frame,14,9,__then,true),par,function __1(_,elt){var __frame={name:"__1",line:193};return __func(_,this,arguments,__1,0,__frame,function __$__1(){return fn.call(thisObj,__cb(_,__frame,1,12,function ___(__0,__1){return function __$__1(__then){if(__1){result.push(elt);__then()}else{__then()}}(_)},true),elt)})},thisObj)}}(function __$value__3(){return _(null,result)})})}});delete Array.prototype.every_;Object.defineProperty(Array.prototype,"every_",{configurable:true,writable:true,enumerable:false,value:function value__4(_,options,fn,thisObj){var par,len,i,fun,futures,__this=this;var __frame={name:"value__4",line:207};return __func(_,this,arguments,value__4,0,__frame,function __$value__4(){if(typeof options==="function"){thisObj=fn,fn=options,options=1}par=_parallel(options);thisObj=thisObj!==undefined?thisObj:__this;len=__this.length;return function __$value__4(__then){if(par===1||len<=1){i=0;var __6=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__4(){__more=false;if(__6){i++}else{__6=true}var __5=i<len;if(__5){return function __$value__4(_){var __1=has.call(__this,i);if(!__1){return _(null,__1)}return fn.call(thisObj,__cb(_,__frame,8,34,function ___(__0,__3){var __2=!__3;return _(null,__2)},true),__this[i])}(__cb(_,__frame,-206,17,function ___(__0,__3){return function __$value__4(__then){if(__3){return _(null,false)}else{__then()}}(function __$value__4(){while(__more){__loop()}__more=true})},true))}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}else{fun=funnel(par);futures=__this.map(function(elt){return fun(false,function __1(_){var __frame={name:"__1",line:220};return __func(_,this,arguments,__1,0,__frame,function __$__1(){return fn.call(thisObj,__cb(_,__frame,1,16,_,true),elt)})})});i=0;var __9=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__4(){__more=false;if(__9){i++}else{__9=true}var __8=i<len;if(__8){return function __$value__4(_){var __2=has.call(__this,i);if(!__2){return _(null,__2)}return futures[i](__cb(_,__frame,18,31,function ___(__0,__4){var __3=!__4;return _(null,__3)},true))}(__cb(_,__frame,-206,17,function ___(__0,__4){return function __$value__4(__then){if(__4){fun.close();return _(null,false)}else{__then()}}(function __$value__4(){while(__more){__loop()}__more=true})},true))}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}}(function __$value__4(){return _(null,true)})})}});delete Array.prototype.some_;Object.defineProperty(Array.prototype,"some_",{configurable:true,writable:true,enumerable:false,value:function value__5(_,options,fn,thisObj){var par,len,i,fun,futures,__this=this;var __frame={name:"value__5",line:241};return __func(_,this,arguments,value__5,0,__frame,function __$value__5(){if(typeof options==="function"){thisObj=fn,fn=options,options=1}par=_parallel(options);thisObj=thisObj!==undefined?thisObj:__this;len=__this.length;return function __$value__5(__then){if(par===1||len<=1){i=0;var __6=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__5(){__more=false;if(__6){i++}else{__6=true}var __5=i<len;if(__5){return function __$value__5(_){var __1=has.call(__this,i);if(!__1){return _(null,__1)}return fn.call(thisObj,__cb(_,__frame,7,33,_,true),__this[i])}(__cb(_,__frame,-240,17,function ___(__0,__3){return function __$value__5(__then){if(__3){return _(null,true)}else{__then()}}(function __$value__5(){while(__more){__loop()}__more=true})},true))}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}else{fun=funnel(par);futures=__this.map(function(elt){return fun(false,function __1(_){var __frame={name:"__1",line:253};return __func(_,this,arguments,__1,0,__frame,function __$__1(){return fn.call(thisObj,__cb(_,__frame,1,16,_,true),elt)})})});i=0;var __9=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__5(){__more=false;if(__9){i++}else{__9=true}var __8=i<len;if(__8){return function __$value__5(_){var __2=has.call(__this,i);if(!__2){return _(null,__2)}return futures[i](__cb(_,__frame,17,30,_,true))}(__cb(_,__frame,-240,17,function ___(__0,__4){return function __$value__5(__then){if(__4){fun.close();return _(null,true)}else{__then()}}(function __$value__5(){while(__more){__loop()}__more=true})},true))}else{__break()}});do{__loop()}while(__more);__more=true}(__then)}}(function __$value__5(){return _(null,false)})})}});delete Array.prototype.reduce_;Object.defineProperty(Array.prototype,"reduce_",{configurable:true,writable:true,enumerable:false,value:function value__6(_,fn,v,thisObj){var len,i,__this=this;var __frame={name:"value__6",line:274};return __func(_,this,arguments,value__6,0,__frame,function __$value__6(){thisObj=thisObj!==undefined?thisObj:__this;len=__this.length;i=0;var __3=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__6(){__more=false;if(__3){i++}else{__3=true}var __2=i<len;if(__2){return function __$value__6(__then){if(has.call(__this,i)){return fn.call(thisObj,__cb(_,__frame,4,34,function ___(__0,__1){v=__1;__then()},true),v,__this[i],i,__this)}else{__then()}}(function __$value__6(){while(__more){__loop()}__more=true})}else{__break()}});do{__loop()}while(__more);__more=true}(function __$value__6(){return _(null,v)})})}});delete Array.prototype.reduceRight_;Object.defineProperty(Array.prototype,"reduceRight_",{configurable:true,writable:true,enumerable:false,value:function value__7(_,fn,v,thisObj){var len,i,__this=this;var __frame={name:"value__7",line:290};return __func(_,this,arguments,value__7,0,__frame,function __$value__7(){thisObj=thisObj!==undefined?thisObj:__this;len=__this.length;i=len-1;var __3=false;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$value__7(){__more=false;if(__3){i--}else{__3=true}var __2=i>=0;if(__2){return function __$value__7(__then){if(has.call(__this,i)){return fn.call(thisObj,__cb(_,__frame,4,34,function ___(__0,__1){v=__1;__then()},true),v,__this[i],i,__this)}else{__then()}}(function __$value__7(){while(__more){__loop()}__more=true})}else{__break()}});do{__loop()}while(__more);__more=true}(function __$value__7(){return _(null,v)})})}});delete Array.prototype.sort_;Object.defineProperty(Array.prototype,"sort_",{configurable:true,writable:true,enumerable:false,value:function value__8(_,compare,beg,end){var array,__this=this;function _qsort(_,beg,end){var tmp,mid,o,nbeg,nend;var __frame={name:"_qsort",line:313};return __func(_,this,arguments,_qsort,0,__frame,function __$_qsort(){if(beg>=end){return _(null)}return function __$_qsort(__then){if(end==beg+1){return compare(__cb(_,__frame,4,9,function ___(__0,__4){var __3=__4>0;return function __$_qsort(__then){if(__3){tmp=array[beg];array[beg]=array[end];array[end]=tmp;__then()}else{__then()}}(function __$_qsort(){return _(null)})},true),array[beg],array[end])}else{__then()}}(function __$_qsort(){mid=Math.floor((beg+end)/2);o=array[mid];nbeg=beg;nend=end;return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$_qsort(){__more=false;var __6=nbeg<=nend;if(__6){return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$_qsort(){__more=false;return function __$_qsort(_){return function __$_qsort(_){var __1=nbeg<end;if(!__1){return _(null,__1)}return compare(__cb(_,__frame,18,26,function ___(__0,__3){var __2=__3<0;return _(null,__2)},true),array[nbeg],o)}(__cb(_,__frame,-312,17,_,true))}(__cb(_,__frame,-312,17,function ___(__0,__7){if(__7){nbeg++;while(__more){__loop()}__more=true}else{__break()}},true))});do{__loop()}while(__more);__more=true}(function __$_qsort(){return function ___(__break){var __more;var __loop=__cb(_,__frame,0,0,function __$_qsort(){__more=false;return function __$_qsort(_){return function __$_qsort(_){var __2=beg<nend;if(!__2){return _(null,__2)}return compare(__cb(_,__frame,19,26,function ___(__0,__4){var __3=__4<0;return _(null,__3)},true),o,array[nend])}(__cb(_,__frame,-312,17,_,true))}(__cb(_,__frame,-312,17,function ___(__0,__9){if(__9){nend--;while(__more){__loop()}__more=true}else{__break()}},true))});do{__loop()}while(__more);__more=true}(function __$_qsort(){if(nbeg<=nend){tmp=array[nbeg];array[nbeg]=array[nend];array[nend]=tmp;nbeg++;nend--}while(__more){__loop()}__more=true})})}else{__break()}});do{__loop()}while(__more);__more=true}(function __$_qsort(){return function __$_qsort(__then){if(nbeg<end){return _qsort(__cb(_,__frame,30,20,__then,true),nbeg,end)}else{__then()}}(function __$_qsort(){return function __$_qsort(__then){if(beg<nend){return _qsort(__cb(_,__frame,31,20,__then,true),beg,nend)}else{__then()}}(_)})})})})}var __frame={name:"value__8",line:308};return __func(_,this,arguments,value__8,0,__frame,function __$value__8(){array=__this;beg=beg||0;end=end==null?array.length-1:end;return _qsort(__cb(_,__frame,38,3,function __$value__8(){return _(null,array)},true),beg,end)})}});delete Function.prototype.apply_;Object.defineProperty(Function.prototype,"apply_",{configurable:true,writable:true,enumerable:false,value:function(callback,thisObj,args,index){args=Array.prototype.slice.call(args,0);args.splice(index!=null&&index>=0?index:args.length,0,callback);return this.apply(thisObj,args)}})})(typeof exports!=="undefined"?exports:Streamline.builtins=Streamline.builtins||{});
/*This is a combined, compressed file.  Look at https://github.com/BruceSherwood/glowscript for source code and copyright information.*/
;(function(){})();